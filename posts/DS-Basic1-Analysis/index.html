<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="pv-proxy-endpoint" content="https://myochosite-291718.appspot.com/query?id=ahNwfm15b2Nob3NpdGUtMjkxNzE4chULEghBcGlRdWVyeRiAgIDo14eBCgw"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Data Structures - Basic 1 - Analysis" /><meta property="og:locale" content="en" /><meta name="description" content="Data Structures - Basic 1 - Analysis Objectives Experimental Studies Counting Primitive Operations The Seven Functions The Constant Function f(n) = c The Logarithm Function f(n) = logb n The Linear Function f(n) = n The N-Log-N Function f(n) = nlogn The Quadratic Function f(n) = n^2 The Cubic Function and Other Polynomials f(n) = n3 The Exponential Function f(n) = b^n Asymptotic Analysis 渐近分析 Big O Notation f(n)≤c·g(n), for n≥n0 最坏情况的度量 Big Omega Ω Notation f(n) ≥ cg(n), for n ≥ n0. 算法的最好情况 Big Theta Θ Notation c′g(n) ≤ f (n) ≤ c′′g(n), for n ≥ n0. Little O Notation Little ω Omega Notation Amortized analysis running time of operations on dynamic arrays. Comparative Analysis 对比分析 T(n) Examples of Algorithm Analysis 题目 O(1): Constant-Time Operations O(㏒N): 二分查找算法 O(n): 线性算法 linear time O(N㏒N: 二分查找算法 O($n^2$) O($n^3$) 做两个n阶矩阵的乘法运算 O($2^n$): 求具有n个元素集合的所有子集的算法 O(n!): 求具有N个元素的全排列的算法 Simple Justification Techniques counterexample: By Example contrapositive and the contradiction: The “Contra” Attack Induction and Loop Invariants 3.5. Performance of Python Data Structures 3.6. Lists 3.7. Dictionaries" /><meta property="og:description" content="Data Structures - Basic 1 - Analysis Objectives Experimental Studies Counting Primitive Operations The Seven Functions The Constant Function f(n) = c The Logarithm Function f(n) = logb n The Linear Function f(n) = n The N-Log-N Function f(n) = nlogn The Quadratic Function f(n) = n^2 The Cubic Function and Other Polynomials f(n) = n3 The Exponential Function f(n) = b^n Asymptotic Analysis 渐近分析 Big O Notation f(n)≤c·g(n), for n≥n0 最坏情况的度量 Big Omega Ω Notation f(n) ≥ cg(n), for n ≥ n0. 算法的最好情况 Big Theta Θ Notation c′g(n) ≤ f (n) ≤ c′′g(n), for n ≥ n0. Little O Notation Little ω Omega Notation Amortized analysis running time of operations on dynamic arrays. Comparative Analysis 对比分析 T(n) Examples of Algorithm Analysis 题目 O(1): Constant-Time Operations O(㏒N): 二分查找算法 O(n): 线性算法 linear time O(N㏒N: 二分查找算法 O($n^2$) O($n^3$) 做两个n阶矩阵的乘法运算 O($2^n$): 求具有n个元素集合的所有子集的算法 O(n!): 求具有N个元素的全排列的算法 Simple Justification Techniques counterexample: By Example contrapositive and the contradiction: The “Contra” Attack Induction and Loop Invariants 3.5. Performance of Python Data Structures 3.6. Lists 3.7. Dictionaries" /><link rel="canonical" href="https://ocholuo.github.io//posts/DS-Basic1-Analysis/" /><meta property="og:url" content="https://ocholuo.github.io//posts/DS-Basic1-Analysis/" /><meta property="og:site_name" content="Grace" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-08-25T11:11:11-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Data Structures - Basic 1 - Analysis" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-10-30T21:02:21-04:00","datePublished":"2019-08-25T11:11:11-04:00","description":"Data Structures - Basic 1 - Analysis Objectives Experimental Studies Counting Primitive Operations The Seven Functions The Constant Function f(n) = c The Logarithm Function f(n) = logb n The Linear Function f(n) = n The N-Log-N Function f(n) = nlogn The Quadratic Function f(n) = n^2 The Cubic Function and Other Polynomials f(n) = n3 The Exponential Function f(n) = b^n Asymptotic Analysis 渐近分析 Big O Notation f(n)≤c·g(n), for n≥n0 最坏情况的度量 Big Omega Ω Notation f(n) ≥ cg(n), for n ≥ n0. 算法的最好情况 Big Theta Θ Notation c′g(n) ≤ f (n) ≤ c′′g(n), for n ≥ n0. Little O Notation Little ω Omega Notation Amortized analysis running time of operations on dynamic arrays. Comparative Analysis 对比分析 T(n) Examples of Algorithm Analysis 题目 O(1): Constant-Time Operations O(㏒N): 二分查找算法 O(n): 线性算法 linear time O(N㏒N: 二分查找算法 O($n^2$) O($n^3$) 做两个n阶矩阵的乘法运算 O($2^n$): 求具有n个元素集合的所有子集的算法 O(n!): 求具有N个元素的全排列的算法 Simple Justification Techniques counterexample: By Example contrapositive and the contradiction: The “Contra” Attack Induction and Loop Invariants 3.5. Performance of Python Data Structures 3.6. Lists 3.7. Dictionaries","headline":"Data Structures - Basic 1 - Analysis","mainEntityOfPage":{"@type":"WebPage","@id":"https://ocholuo.github.io//posts/DS-Basic1-Analysis/"},"url":"https://ocholuo.github.io//posts/DS-Basic1-Analysis/"}</script><title>Data Structures - Basic 1 - Analysis | Grace</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Grace"><meta name="application-name" content="Grace"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://myochosite-291718.appspot.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://myochosite-291718.appspot.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/huoye.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Grace</a></div><div class="site-subtitle font-italic">2023 Mar 14 updated</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ocholuo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Data Structures - Basic 1 - Analysis</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Data Structures - Basic 1 - Analysis</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Grace JyL </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Aug 25, 2019, 11:11 AM -0400" >Aug 25, 2019<i class="unloaded">2019-08-25T11:11:11-04:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Oct 30, 2022, 6:02 PM -0700" >Oct 30, 2022<i class="unloaded">2022-10-30T21:02:21-04:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7512 words">41 min read</span> <span id="pv" class="pageviews"> <i class="fas fa-spinner fa-spin fa-fw"></i> </span> views</div></div><div class="post-content"><ul><li><a href="#data-structures---basic-1---analysis">Data Structures - Basic 1 - Analysis</a><ul><li><a href="#objectives">Objectives</a><li><a href="#experimental-studies">Experimental Studies</a><li><a href="#counting-primitive-operations">Counting Primitive Operations</a><ul><li><a href="#the-seven-functions">The Seven Functions</a><ul><li><a href="#the-constant-function-fn--c">The Constant Function <code class="language-plaintext highlighter-rouge">f(n) = c</code></a><li><a href="#the-logarithm-function-fn--logb-n">The Logarithm Function <code class="language-plaintext highlighter-rouge">f(n) = logb n</code></a><li><a href="#the-linear-function-fn--n">The Linear Function <code class="language-plaintext highlighter-rouge">f(n) = n</code></a><li><a href="#the-n-log-n-function-fn--nlogn">The N-Log-N Function <code class="language-plaintext highlighter-rouge">f(n) = nlogn</code></a><li><a href="#the-quadratic-function-fn--n2">The Quadratic Function <code class="language-plaintext highlighter-rouge">f(n) = n^2</code></a><li><a href="#the-cubic-function-and-other-polynomials-fn--n3">The Cubic Function and Other Polynomials <code class="language-plaintext highlighter-rouge">f(n) = n3</code></a><li><a href="#the-exponential-function-fn--bn">The Exponential Function <code class="language-plaintext highlighter-rouge">f(n) = b^n</code></a></ul></ul><li><a href="#asymptotic-analysis-渐近分析">Asymptotic Analysis 渐近分析</a><ul><li><a href="#big-o-notation-fncgn-for-nn0-最坏情况的度量">Big O Notation <code class="language-plaintext highlighter-rouge">f(n)≤c·g(n), for n≥n0</code> 最坏情况的度量</a><li><a href="#big-omega-ω-notation-fn--cgn-for-n--n0-算法的最好情况">Big Omega Ω Notation <code class="language-plaintext highlighter-rouge">f(n) ≥ cg(n), for n ≥ n0.</code> 算法的最好情况</a><li><a href="#big-theta-θ-notation-cgn--f-n--cgn-for-n--n0">Big Theta Θ Notation <code class="language-plaintext highlighter-rouge">c′g(n) ≤ f (n) ≤ c′′g(n), for n ≥ n0.</code></a><li><a href="#little-o-notation">Little O Notation</a><li><a href="#little-ω-omega-notation">Little ω Omega Notation</a></ul><li><a href="#amortized-analysis">Amortized analysis</a><ul><li><a href="#running-time-of-operations-on-dynamic-arrays">running time of operations on dynamic arrays.</a></ul><li><a href="#comparative-analysis-对比分析">Comparative Analysis 对比分析</a><ul><li><a href="#tn">T(n)</a><li><a href="#examples-of-algorithm-analysis">Examples of Algorithm Analysis</a><ul><li><a href="#题目">题目</a><li><a href="#o1-constant-time-operations">O(1): Constant-Time Operations</a><li><a href="#on-二分查找算法">O(㏒N): 二分查找算法</a><li><a href="#on-线性算法-linear-time">O(n): 线性算法 linear time</a><li><a href="#onn-二分查找算法">O(N㏒N: 二分查找算法</a><li><a href="#on2">O($n^2$)</a><li><a href="#on3-做两个n阶矩阵的乘法运算">O($n^3$) 做两个n阶矩阵的乘法运算</a><li><a href="#o2n-求具有n个元素集合的所有子集的算法">O($2^n$): 求具有n个元素集合的所有子集的算法</a><li><a href="#on-求具有n个元素的全排列的算法">O(n!): 求具有N个元素的全排列的算法</a></ul></ul><li><a href="#simple-justification-techniques">Simple Justification Techniques</a><ul><li><a href="#counterexample-by-example">counterexample: By Example</a><li><a href="#contrapositive-and-the-contradiction-the-contra-attack">contrapositive and the contradiction: The “Contra” Attack</a><li><a href="#induction-and-loop-invariants">Induction and Loop Invariants</a></ul></ul><li><a href="#35-performance-of-python-data-structures">3.5. Performance of Python Data Structures</a><ul><li><a href="#36-lists">3.6. Lists</a><li><a href="#37-dictionaries">3.7. Dictionaries</a></ul></ul><hr /><h1 id="data-structures---basic-1---analysis">Data Structures - Basic 1 - Analysis</h1><p>source:</p><ul><li>DS - pythonds3 - 3. Analysis<li>Problem Solving with Algorithms and Data Structures using Python 3<li>Data Structures and Algorithms in Java, 6th Edition.pdf</ul><hr /><h2 id="objectives">Objectives</h2><ul><li><strong>data structure</strong> is a systematic way of organizing and accessing data<li><strong>algorithm</strong> is a step-by-step procedure for performing some task in a finite amount of time.<li>to classify some data structures and algorithms as “good,” we must have precise ways of analyzing them.</ul><p>what we really mean by computing resources.two different ways to look at this.</p><ol><li><strong>Running time</strong><ol><li><code class="language-plaintext highlighter-rouge">the amount of time</code> require to execute.<li>“execution time, running time of the algorithm.<li>One way to measure is to do a benchmark analysis. track the actual time required for the program to compute its result.<ol><li>In Python, we can benchmark a function by noting the starting time and ending time with respect to the system we are using.<li>In the time module, function called time, will return the current system clock time in seconds since some arbitrary starting point.<li>By calling this function twice, at the beginning and at the end, and then computing the difference, we can get an exact number of seconds (fractions in most cases) for execution.</ol></ol><li><strong>Space usage</strong><ol><li><code class="language-plaintext highlighter-rouge">the amount of space or memory</code> an algorithm requires to solve the problem.<li>The amount of space required by a problem solution is typically dictated by the problem instance itself.<li>Every so often, however, there are algorithms that have very specific space requirements, and in those cases we will be very careful to explain the variations.</ol></ol><hr /><h2 id="experimental-studies">Experimental Studies</h2><ul><li>implement it and experiment by running the program on various test inputs while recording the time spent during each execution<ul><li>However, the measured times reported by both methods <code class="language-plaintext highlighter-rouge">currentTimeMillis</code> and <code class="language-plaintext highlighter-rouge">nanoTime</code> will vary greatly from machine to machine, and may likely vary from trial to trial, even on the same machine.<li>because many processes share use of a computer’s <strong>central processing unit (or CPU)</strong> and <strong>memory system</strong>;<li>therefore, the elapsed time will depend on what other processes are running on the computer when a test is performed.<li>While the precise running time may not be dependable, experiments are quite useful when comparing the efficiency of two or more algorithms, so long as they gathered under similar circumstances.</ul><li>three major limitations to algorithm analysis:<ul><li>Experimental running times of two algorithms are difficult to directly compare unless the experiments are performed in the same hardware and software environments.<li>Experiments can be done only on a limited set of test inputs; hence, they leave out the running times of inputs not included in the experiment (and these inputs may be important).<li>An algorithm must be fully implemented in order to execute it to study its running time experimentally.<ul><li>the most serious drawback<li>At early stages of design, when considering a choice of data structures or algorithms, it would be foolish to spend a significant amount of time implementing an approach that could easily be deemed inferior by a higher-level analysis.</ul></ul></ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="nb">long</span> <span class="n">startTime</span> <span class="o">=</span> <span class="n">System</span><span class="p">.</span><span class="nf">currentTimeMillis</span><span class="p">();</span>
<span class="nb">long</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">System</span><span class="p">.</span><span class="nf">currentTimeMillis</span><span class="p">();</span>
<span class="nb">long</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="n">endTime</span> <span class="err">−</span> <span class="n">startTime</span><span class="p">;</span>


<span class="c1"># =============== 1 =================
</span><span class="k">def</span> <span class="nf">sum_of_n_2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
    <span class="n">the_sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">the_sum</span> <span class="o">=</span> <span class="n">the_sum</span> <span class="o">+</span> <span class="n">i</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">the_sum</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Sum is %d required %10.7f seconds"</span> <span class="o">%</span> <span class="nf">sum_of_n_2</span><span class="p">(</span><span class="mi">10000</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Sum is %d required %10.7f seconds"</span> <span class="o">%</span> <span class="nf">sum_of_n_2</span><span class="p">(</span><span class="mi">100000</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Sum is %d required %10.7f seconds"</span> <span class="o">%</span> <span class="nf">sum_of_n_2</span><span class="p">(</span><span class="mi">1000000</span><span class="p">))</span>
<span class="c1"># Sum is 50005000     required  0.0018950 seconds
# Sum is 5000050000   required  0.0199420 seconds
# Sum is 500000500000 required  0.1948988 seconds
</span>

<span class="c1"># =============== 2 =================
</span><span class="k">def</span> <span class="nf">sum_of_n_3</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="nf">return </span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">sum_of_n_3</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="c1"># Sum is 50005000         required 0.00000095 seconds
# Sum is 5000050000       required 0.00000191 seconds
# Sum is 500000500000     required 0.00000095 seconds
# Sum is 50000005000000   required 0.00000095 seconds
# Sum is 5000000050000000 required 0.00000119 seconds
</span></pre></table></code></div></div><blockquote><p>First, the times recorded above are shorter than any of the previous examples. Second, they are very consistent no matter what the value of n. It appears that sum_of_n_3 is hardly impacted by the number of integers being added.</p></blockquote><blockquote><p>the iterative solutions is doing more work since some program steps are being repeated.</p></blockquote><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">repeat1</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">answer</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="n">answer</span> <span class="o">+=</span> <span class="n">c</span><span class="o">;</span> <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">repeat2</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="https://i.imgur.com/7qvnjE0.png" alt="Screen Shot 2022-03-04 at 12.36.59" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/jvLO3uz.png" alt="Screen Shot 2022-03-04 at 12.37.25" /></p><hr /><h2 id="counting-primitive-operations">Counting Primitive Operations</h2><ul><li>To analyze the running time of an algorithm without performing experiments, perform an analysis directly on a <code class="language-plaintext highlighter-rouge">high-level description of the algorithm</code><li>define a set of primitive operations such as the following:<ul><li>Assigning a value to a variable<li>Following an object reference<li>Performing an arithmetic operation (for example, adding two numbers)<li>Comparing two numbers<li>Accessing a single element of an array by index<li>Calling a method<li>Returning from a method</ul></ul><p><strong>Focusing on the Worst-Case Input</strong></p><ul><li>An algorithm may run faster on some inputs than it does on others of the same size.<li>to express the running time of an algorithm as the function of the input size obtained by taking the average over all possible inputs of the same size.<li>Unfortunately, such an average-case analysis is typically quite challenging. It requires us to define a probability distribution on the set of inputs, which is often a difficult task.</ul><hr /><h3 id="the-seven-functions">The Seven Functions</h3><p><img data-proofer-ignore data-src="https://i.imgur.com/jGC0vAA.png" alt="Screen Shot 2022-03-04 at 18.59.27" /></p><ul><li>Ideally, we would like <code class="language-plaintext highlighter-rouge">data structure operations</code> to run in times proportional to the <strong>constant or logarithm function</strong><li>would like our <code class="language-plaintext highlighter-rouge">algorithms</code> to run in <strong>linear or n-log-n time</strong>.<li>Algorithms with quadratic or cubic running times are less practical,<li><p>algorithms with exponential running times are infeasible for all but the smallest sized inputs.</p><li>analysis of an algorithm may sometimes involve the use of the <code class="language-plaintext highlighter-rouge">floor function</code> and <code class="language-plaintext highlighter-rouge">ceiling function</code>, which are defined respectively as follows:</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/TcZ7wKZ.png" alt="Screen Shot 2022-03-04 at 19.01.37" /></p><div class="table-wrapper"><table><thead><tr><th>f(n)<th>Name<tbody><tr><td><code class="language-plaintext highlighter-rouge">1</code><td><kbd>Constant</kbd> 表示算法的运行时间为常量<tr><td><code class="language-plaintext highlighter-rouge">log𝑛</code><td><kbd>Logarithmic</kbd> 二分查找算法<tr><td><code class="language-plaintext highlighter-rouge">𝑛</code><td><kbd>Linear</kbd><tr><td><code class="language-plaintext highlighter-rouge">𝑛log𝑛</code><td><kbd>Log Linear</kbd><tr><td>$𝑛^2$<td><kbd>Quadratic</kbd> 对数组进行排序的各种简单算法，例如直接插入排序的算法。<tr><td>$𝑛^3$<td><kbd>Cubic</kbd> 做两个n阶矩阵的乘法运算<tr><td>$2^𝑛$<td><kbd>Exponential</kbd> 求具有n个元素集合的所有子集的算法<tr><td>O(n!)<td>求具有N个元素的全排列的算法</table></div><p><img data-proofer-ignore data-src="https://i.imgur.com/mwyIctk.png" alt="Screen Shot 2021-10-26 at 3.07.39 AM" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/wDUItRW.png" alt="newplot" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/ZE0qJ9I.png" alt="newplot2" /></p><blockquote><p>when n is small, the functions are not very well defined with respect to one another. as n grows, there is a definite relationship and it is easy to see how they compare with one another.</p></blockquote><p>优&lt;—————————&lt;劣</p><p><code class="language-plaintext highlighter-rouge">O(1)&lt;O(㏒n)&lt;O(n)&lt;O(n ㏒n)&lt;O(n^2)&lt;O(2^n)&lt;O(n!)</code></p><p>常数阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n2)、立方阶O(n3)、……k次方阶O(nk)、指数阶O(2n)。</p><hr /><h4 id="the-constant-function-fn--c">The Constant Function <code class="language-plaintext highlighter-rouge">f(n) = c</code></h4><ul><li>The simplest functio<li>for some fixed constant c, such as c=5, c=27, or c=210.<li>for any argument n, the constant function f(n) assigns the value c.<li><p>it does not matter what the value of n is; f(n) will always be equal to the constant value c.</p><li>it characterizes the number of steps needed to do a basic operation on a computer, like<ul><li>adding two numbers,<li>assigning a value to a variable,<li>or comparing two numbers.</ul></ul><h4 id="the-logarithm-function-fn--logb-n">The Logarithm Function <code class="language-plaintext highlighter-rouge">f(n) = logb n</code></h4><ul><li>the ubiquitous presence of the logarithm function, f(n) = logb n, for some constant b &gt; 1.<li>This function is defined as the inverse of a power, as follows:</ul><div class="language-plaintext highlighter-rouge"><div class="code-header" text-data="plaintext"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>x=logbn ifandonlyif b^x =n.
⌈log3 27⌉ = 3, because ((27/3)/3)/3 = 1;
⌈log4 64⌉ = 3, because ((64/4)/4)/4 = 1;
⌈log2 12⌉ = 4, because (((12/2)/2)/2)/2 = 0.75 ≤ 1.
</pre></table></code></div></div><ul><li>The value b is known as <code class="language-plaintext highlighter-rouge">the base of the logarithm</code>.<li>for any base b &gt; 0, we have that logb 1 = 0.<li>The most common base for the logarithm function in computer science is 2 as computers store integers in binary. In fact, this base is so common that we will typically omit it from the notation when it is 2.: <code class="language-plaintext highlighter-rouge">log n = log2 n.</code></ul><h4 id="the-linear-function-fn--n">The Linear Function <code class="language-plaintext highlighter-rouge">f(n) = n</code></h4><ul><li>given an input value n, the linear function f assigns the value n itself.<li>This function arises in algorithm analysis any time we have to do a single basic operation for each of n elements.<li>For example<ul><li>comparing a number x to each element of an array of size n: require n comparisons.</ul><li>The linear function also represents the <code class="language-plaintext highlighter-rouge">best running time we can hope to achieve for any algorithm that processes each of n objects</code> that are not already in the computer’s memory, because reading in the n objects already requires n operations.</ul><h4 id="the-n-log-n-function-fn--nlogn">The N-Log-N Function <code class="language-plaintext highlighter-rouge">f(n) = nlogn</code></h4><ul><li>the function that assigns to an input n, the value of n times the logarithm base-two of n.<li>This function grows a little more rapidly than the linear function and a lot less rapidly than the quadratic function;<li>For example,<ul><li>the fastest possible algorithms for sorting n arbitrary values require time proportional to n log n.</ul></ul><h4 id="the-quadratic-function-fn--n2">The Quadratic Function <code class="language-plaintext highlighter-rouge">f(n) = n^2</code></h4><ul><li>given an input value n, the function f assigns the product of n with itself (“n squared”).<li>algorithms that have <strong>nested loops</strong>, where the inner loop performs a linear number of operations and the outer loop is performed a linear number of times.<ul><li>the operations in the inner loop increase by one each time,<li>then the total number of operations is quadratic in the number of times, n, we perform the outer loop.<li>the algorithm performs n · n = n^2 operations.</ul><li>To be fair, the number of operations is <code class="language-plaintext highlighter-rouge">n^2/2 + n/2</code><li>over half the number of operations than an algorithm that uses n operations each time the inner loop is performed.<li>But the order of growth is still quadratic in n.</ul><h4 id="the-cubic-function-and-other-polynomials-fn--n3">The Cubic Function and Other Polynomials <code class="language-plaintext highlighter-rouge">f(n) = n3</code></h4><p><strong>Cubic Function</strong></p><ul><li>The cubic function appears less frequently in the context of algorithm analysis than the constant, linear, and quadratic functions previously mentioned, but it does appear from time to time.</ul><p><strong>Polynomials</strong></p><ul><li>The linear, quadratic and cubic functions can each be viewed as being part of a larger class of functions, the polynomials.</ul><p><code class="language-plaintext highlighter-rouge">f(n) = a0 +a1n+a2n^2 +a3n3 +···+adn^d</code></p><ul><li>a0 , a1 , . . . , ad are constants, called the <strong>coefficients</strong> of the polynomial, and ad ̸= 0.<li>Integer d, which indicates the highest power in the polynomial, is called the <strong>degree</strong> of the polynomial.<li>For example, the following functions are all polynomials:<ul><li>f(n) = 2+5n+n2<li>f(n)=1+n^3<li>f(n)=1<li>f(n)=n<li>f(n)=n^2</ul></ul><p><strong>Summations</strong></p><ul><li>A notation that appears again and again in the analysis of data structures and algo- rithms is the summation, which is defined as follows:</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/l85IEU2.png" alt="Screen Shot 2022-03-04 at 18.55.08" /></p><h4 id="the-exponential-function-fn--bn">The Exponential Function <code class="language-plaintext highlighter-rouge">f(n) = b^n</code></h4><ul><li>where b is a positive constant, called the <strong>base</strong>,<li>and the argument n is the <strong>exponent</strong>.<li>That is, function f (n) assigns to the input argument n the value obtained by multiplying the base b by itself n times.<li>As was the case with the logarithm function, the most common base for the exponential function in algorithm analysis is b = 2.<ul><li>For example,<li>an integer word containing n bits can represent all the nonnegative integers less than 2n.<li>If we have a loop that starts by performing one operation and then doubles the number of operations performed with each iteration, then the number of operations performed in the nth iteration is 2n.</ul><li>the following exponent rules are quite helpful.<ol><li>(b^a)^c = b^ac<li>b^ab^c=b^a+c<li>b^a/b^c = b^a−c</ol></ul><p><strong>Geometric Sums</strong></p><ul><li>Suppose we have a loop for which each iteration takes a multiplicative factor longer than the previous one.<li>This loop can be analyzed using the following proposition.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/i5isO72.png" alt="Screen Shot 2022-03-04 at 18.58.48" /></p><hr /><h2 id="asymptotic-analysis-渐近分析">Asymptotic Analysis 渐近分析</h2><h3 id="big-o-notation-fncgn-for-nn0-最坏情况的度量">Big O Notation <code class="language-plaintext highlighter-rouge">f(n)≤c·g(n), for n≥n0</code> 最坏情况的度量</h3><p><img data-proofer-ignore data-src="https://i.imgur.com/Sm0gaI0.png" alt="bigO" /></p><ul><li>如果存在正数c和N，对于所有的n&gt;=N，有f(n)&lt;=c*g(n)，则f(n)=O(g(n))<li>求一个算法的worst-case，即是一个最坏情况的度量，求的是上界。<li>used to describe the upper bound of a particular algorithm.<li>Big O is used to describe <strong>worst case scenarios</strong><li>The big-Oh notation allows us to say that<ul><li>a function f(n) is “less than or equal to” another function g(n) up to a constant factor and in the asymptotic sense as n grows toward infinity.<li>f(n) is order of g(n)</ul><li><p><strong>describe the function in the big-Oh in simplest terms.</strong></p><li>use the names of these functions to refer to the running times of the algorithms<ul><li>for example<ul><li>an algorithm that runs in worst-case time <code class="language-plaintext highlighter-rouge">4n^2 + n log n</code> is a <strong>quadratic-time algorithm</strong>, since it runs in <code class="language-plaintext highlighter-rouge">O(n2)</code> time.<li>an algorithm running in time at most <code class="language-plaintext highlighter-rouge">5n + 20 log n + 4</code> would be called a <strong>linear-time algorithm</strong>.</ul></ul></ul><p><strong>example</strong></p><blockquote><p>5$n^4$ + $3n^3$ + $2n^2$ + 4n + 1 is O($n^4$). Justification: $5n^4$ + $3n^3$ + $2n^2$ + 4n+1 ≤ (5+3+2+4+1)$n^4$ =c$n^4$, for c=15, whenn≥n0 =1.</p></blockquote><blockquote><p>If f (n) is a polynomial of degree d: f(n) = a0 +a1n+···+adnd, and ad &gt; 0, Justification: a0 +a1n+a2n2 +···+adnd ≤ (|a0|+|a1|+|a2|+···+|ad|)n^d f(n) is O(n^d).</p></blockquote><blockquote><p>5n^2 + 3nlogn + 2n + 5 is O(n^2). Justification: 5n2 + 3nlogn + 2n + 5 ≤ (5+3+2+5)n^2 = cn^2,for c=15, when n≥n0 =1.</p></blockquote><hr /><h3 id="big-omega-ω-notation-fn--cgn-for-n--n0-算法的最好情况">Big Omega Ω Notation <code class="language-plaintext highlighter-rouge">f(n) ≥ cg(n), for n ≥ n0.</code> 算法的最好情况</h3><ul><li><p>如果存在正数c和N，对于所有的n&gt;=N，有f(n)&gt;=c*g(n)，则f(n)=Omega(g(n))</p><li><p>和Big O相反，这个玩意儿是很乐观的，求得是一个算法的最好情况，即下界，即best-case。</p><li><p>used to provide an asymptotic lower bound on a particular algorithm</p></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/ZzgElTm.png" alt="bigOmega" /></p><blockquote><p>3n log n − 2n is Ω(n log n). Justification: 3nlogn−2n = nlogn+2n(logn−1) ≥ nlogn for n ≥ 2; hence, c=1 and n0 =2</p></blockquote><hr /><h3 id="big-theta-θ-notation-cgn--f-n--cgn-for-n--n0">Big Theta Θ Notation <code class="language-plaintext highlighter-rouge">c′g(n) ≤ f (n) ≤ c′′g(n), for n ≥ n0.</code></h3><ul><li><p>如果存在正数c1，c2和N，对于所有的n&gt;=N，有c1<em>g(n)&lt;=f(n)&lt;=c2</em>g(n)，则f(n)=Theta(g(n))</p><li>这个记法表示一个算法不会好于XX，也不会坏于XX，太中庸了，没有激情啊。<li><p>所以也就是求average-case。</p><li>used to provide a bound on a particular algorithm such that it can be “sandwiched” between two constants (one for an upper limit and one for a lower limit) for sufficiently large values.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/aGbSgxo.png" alt="theta" /></p><blockquote><p>Example 4.15: 3nlogn+4n+5logn is Θ(nlogn). Justification: 3nlogn ≤ 3nlogn+4n+5logn ≤ (3+4+5)nlogn for n ≥ 2.</p></blockquote><hr /><h3 id="little-o-notation">Little O Notation</h3><ul><li>used to describe an upper bound of a particular algorithm;<li><p>however, Little O provides a bound that is not asymptotically tight</p><li>对于任意正数c，均存在正数N，对于所有的n&gt;=N，有f(n)&lt;c*g(n)，则f(n)=o(g(n))</ul><hr /><h3 id="little-ω-omega-notation">Little ω Omega Notation</h3><ul><li><p>used to provide a lower bound on a particular algorithm that is not asymptotically tight</p><li><p>对于任意正数c，均存在正数N，对于所有的n&gt;=N，有f(n)&gt;c*g(n)，则f(n)=omega(g(n))</p></ul><hr /><h2 id="amortized-analysis">Amortized analysis</h2><p><strong>amortization</strong> 分期偿还</p><ul><li>an algorithmic design pattern<li>amortized analysis,<ul><li>view the computer as a coin-operated appliance that requires the payment of one cyber-dollar for a constant amount of computing time.<li>When an operation is executed, should have enough cyber-dollars available in our current “bank account” to pay for that operation’s running time.<li>the total amount of cyber-dollars spent for any computation will be proportional to the total time spent on that computation.<li>we can overcharge some operations in order to save up cyber-dollars to pay for others.</ul></ul><h3 id="running-time-of-operations-on-dynamic-arrays">running time of operations on dynamic arrays.</h3><ul><li><p>the insertion of an element to be the last element in an array list as a push operation.</p><li>The strategy of replacing an array with a new, larger array<ul><li>might at first seem slow, because a single push operation may require Ω(n) time to perform, where n is the current number of elements in the array.<li>However, by doubling the capacity during an array replacement, our new array allows us to add n further elements before the array must be replaced again.<li>In this way, there are many simple push operations for each expensive one<li>a series of push operations on an initially empty <strong>dynamic array</strong> is efficient in terms of its total running time.</ul><li>Using amortization, performing a sequence of push operations on a dynamic array is actually quite efficient.</ul><p><strong>Proposition</strong></p><ul><li>Let L be an initially empty array list with capacity one, implemented by means of a dynamic array that doubles in size when full.<li>The total time to perform a series of n push operations in L is O(n). <strong>Justification</strong>:<li>assume that <code class="language-plaintext highlighter-rouge">one</code> cyber-dollar for the execution of each <strong>push</strong> operation in L, excluding the time spent for growing the array.<li>assume that <strong>growing the array from size k to size 2k</strong> requires <code class="language-plaintext highlighter-rouge">k</code> cyber-dollars for the time spent initializing the new array.<li>charge each <strong>push</strong> operation <code class="language-plaintext highlighter-rouge">three</code> cyber-dollars. Thus, we overcharge each push operation that does not cause an overflow by two cyber-dollars.<li>Think of the two cyber-dollars profited in an insertion that does not grow the array as being “stored” with the cell in which the element was inserted.<li>An overflow occurs when the array L has 2^i elements, for some integer i ≥ 0, and the size of the array used by the array representing L is 2i.<li>Thus, doubling the size of the array will require 2^i cyber-dollars.<li><p>Fortunately, these cyber-dollars can be found stored in cells 2i−1 through 2i − 1.</p><li>In other words, the amortized running time of each push operation is O(1); hence, the total running time of n push operations is O(n).</ul><hr /><h2 id="comparative-analysis-对比分析">Comparative Analysis 对比分析</h2><ul><li>an algorithm A has a running time of O(n), algorithm B has a running time of O(n^2).<li>algorithm A is <strong>asymptotically better</strong> than algorithm B, although for a small value of n, B may have a lower running time than A.</ul><p><strong>Some Words of Caution</strong></p><ul><li>the use of the big-Oh and related notations can be somewhat misleading should the constant factors they “hide” be very large.<li>For example<ul><li>function <code class="language-plaintext highlighter-rouge">10^100n is O(n)</code>, if this is the running time of an algorithm being compared to one whose running time is <code class="language-plaintext highlighter-rouge">10n log n</code>, we should prefer the O(n log n)- time algorithm, even though the linear-time algorithm is asymptotically faster.<li>This preference is because the constant factor, 10^100 “one googol,” is believed by many astronomers to be an upper bound on the number of atoms in the observable universe. So we are unlikely to ever have a real-world problem that has this number as its input size.</ul><li>The observation above raises the issue of what constitutes a “fast” algorithm.<li>Generally speaking, any algorithm running in <strong>O(nlogn)</strong> time (with a reasonable constant factor) should be considered efficient.<ul><li>Even an O(n^2)-time function may be fast enough in some contexts, an algorithm whose running time is an <strong>exponential function</strong>, e.g., O(2n), <code class="language-plaintext highlighter-rouge">should almost never be considered efficient</code></ul></ul><p>Sometimes the performance of an algorithm depends on the <code class="language-plaintext highlighter-rouge">exact values of the data</code> rather than simply <code class="language-plaintext highlighter-rouge">the size of the problem</code>.</p><ul><li>For these kinds of algorithms, characterize performance in terms of <code class="language-plaintext highlighter-rouge">best case</code>, <code class="language-plaintext highlighter-rouge">worst case</code>, or <code class="language-plaintext highlighter-rouge">average case</code> performance.<li>The <code class="language-plaintext highlighter-rouge">worst case performance</code> refers to a particular data set where the algorithm performs especially poorly. Whereas a different data set for the exact same algorithm might have extraordinarily good performance. However, in most cases the algorithm performs somewhere in between these two extremes (average case).</ul><p><strong>Common Data Structure Operations</strong> <img data-proofer-ignore data-src="https://i.imgur.com/ZOHJix6.png" alt="Screen Shot 2021-10-26 at 3.08.29 AM" /></p><p><strong>Array Sorting Algorithms</strong> <img data-proofer-ignore data-src="https://i.imgur.com/QKG1tjP.png" alt="Screen Shot 2021-10-26 at 3.09.05 AM" /></p><hr /><h3 id="tn">T(n)</h3><p><kbd>T(n)</kbd> is <strong>the time it takes to solve a problem of size n</strong></p><blockquote><p>the time required to solve the larger case would be greater than for the smaller case. Our goal then is to show how <code class="language-plaintext highlighter-rouge">the algorithm’s execution time changes</code> with respect to <code class="language-plaintext highlighter-rouge">the size of the problem</code>.</p></blockquote><p>It turns out that the exact number of operations is not as important as determining the most dominant part of the <code class="language-plaintext highlighter-rouge">𝑇(𝑛)</code> function.</p><ul><li>as the problem gets larger, some portion of the <code class="language-plaintext highlighter-rouge">𝑇(𝑛)</code> function tends to overpower the rest.<li>This dominant term is what, in the end, is used for comparison.</ul><p>variable name define info.</p><ul><li>存储空间<li>执行时间: <code class="language-plaintext highlighter-rouge">import time: time.time()=8888888</code></ul><p>The <strong>order of magnitude</strong> function</p><ul><li>describes the part of <code class="language-plaintext highlighter-rouge">𝑇(𝑛)</code> that increases the fastest as the value of <code class="language-plaintext highlighter-rouge">n</code> increases.<li><strong>Order of magnitude重要性</strong> is often called <strong>Big-O notation</strong> (for “order”) and written as <kbd>𝑂(𝑓(𝑛))</kbd>.</ul><p>It provides a useful approximation to the actual number of steps in the computation. The function <code class="language-plaintext highlighter-rouge">𝑓(𝑛)</code> provides a simple representation of the dominant part of the original <code class="language-plaintext highlighter-rouge">𝑇(𝑛)</code>.</p><blockquote><p>example 1</p></blockquote><p><code class="language-plaintext highlighter-rouge">𝑇(𝑛)=1+𝑛</code></p><ul><li>The parameter n is often referred to as the “size of the problem,”<li>read this as “T(n) is the time it takes to solve a problem of size n, namely 1 + n steps.”<li>As <code class="language-plaintext highlighter-rouge">n</code> gets large, the constant 1 will become less and less significant to the final result.<li>If looking for an approximation for <code class="language-plaintext highlighter-rouge">𝑇(𝑛)</code>, then can drop the 1 and simply say that the running time is <kbd>𝑂(𝑛)</kbd>.<li>It is important to note that the <strong>1 is certainly significant for <code class="language-plaintext highlighter-rouge">𝑇(𝑛)</code></strong>.<li>However, as <code class="language-plaintext highlighter-rouge">n</code> gets large, our approximation will be just as accurate without it.</ul><blockquote><p>example 2</p></blockquote><p><code class="language-plaintext highlighter-rouge">𝑇(𝑛)=5𝑛^2+27𝑛+1005</code>.</p><ul><li>When <code class="language-plaintext highlighter-rouge">n</code> is small, the constant 1005 seems to be the dominant part of the function.<li>However, as n gets larger<ul><li>the <code class="language-plaintext highlighter-rouge">𝑛^2</code> term becomes the most important.<li>the other two terms become insignificant in the role that they play in determining the final result.<li>can ignore the other terms and focus on <code class="language-plaintext highlighter-rouge">5𝑛^2</code>.<li>the <code class="language-plaintext highlighter-rouge">coefficient 5</code> also becomes insignificant as <code class="language-plaintext highlighter-rouge">n</code> gets large.</ul><li>the function <code class="language-plaintext highlighter-rouge">𝑇(𝑛)</code> has an <strong>order of magnitude</strong> 𝑓(𝑛)=𝑛^2, or simply that it is <kbd>𝑂(𝑛^2)</kbd>.</ul><hr /><h3 id="examples-of-algorithm-analysis">Examples of Algorithm Analysis</h3><h4 id="题目">题目</h4><ul><li><strong>The j th element can be found</strong><ul><li>not by iterating through the array one element at a time,<li>but by validating the index, and using it as an <code class="language-plaintext highlighter-rouge">offset from the beginning of the array in determining the appropriate memory address</code>.<li><p>Therefore, <code class="language-plaintext highlighter-rouge">A[j]</code> is evaluated in O(1) time for an array.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">sum</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
<span class="c1">// T(n)=1</span>
<span class="c1">// O(1): 表示算法的运行时间为常量</span>
<span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</pre></table></code></div></div></ul><li><strong>finding the largest element of an array.</strong><ul><li><p>loop through elements of the array while maintaining as a variable the largest element seen thus far.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">double</span> <span class="nf">arrayMax</span><span class="o">(</span><span class="kt">double</span><span class="o">[</span> <span class="o">]</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>            <span class="c1">// constant number of primitive operations.</span>
    <span class="kt">double</span> <span class="n">currentMax</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>    <span class="c1">// constant number of primitive operations.</span>
    <span class="c1">// Each iteration of the loop requires only a constant number of primitive operations,</span>

    <span class="c1">// and the loop executes n − 1 times.</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">currentMax</span><span class="o">)</span> <span class="n">currentMax</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">currentMax</span><span class="o">;</span>              <span class="c1">// constant number of primitive operations.</span>
<span class="o">}</span>
<span class="c1">// a(n−1)+b = an+(b−a) ≤ an</span>
<span class="c1">// arrayMax is O(n)</span>
</pre></table></code></div></div></ul><li><strong>Composing Long Strings</strong><ol><li><code class="language-plaintext highlighter-rouge">String</code><ul><li>strings in Java are <strong>immutable objects</strong>. Once created, an instance cannot be modified.<li>answer += c<ul><li>does not cause a new character to be added to the existing String instance;<li>instead it produces a new String with the desired sequence of characters,<li>and then it reassigns the variable, answer, to refer to that new string.</ul><li>the creation of a new string as a result of a concatenation, requires time that is proportional to the length of the resulting string.<li>Therefore, the overall time taken by this algorithm is proportional to <code class="language-plaintext highlighter-rouge">1+2+···+n &lt;= n^2</code></ul><li><code class="language-plaintext highlighter-rouge">StringBuilder</code><ul><li>uses Java’s StringBuilder class, demonstrate a trend of approximately doubling each time the problem size doubles.<li><p>The StringBuilder class relies on an advanced technique with a worst-case running time of <code class="language-plaintext highlighter-rouge">O(n)</code> for composing a string of length n;</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre> <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">repeat1</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
     <span class="nc">String</span> <span class="n">answer</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
     <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="n">answer</span> <span class="o">+=</span> <span class="n">c</span><span class="o">;</span>
     <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="c1">// total time complexity of the repeat1 algorithm is O(n2)</span>
</pre></table></code></div></div></ul></ol><li><strong>Three-Way Set Disjointness</strong><ul><li>if A and B are each sets of distinct elements, there can be at most <code class="language-plaintext highlighter-rouge">O(n)</code> such pairs with a equal to b.<li><p>Therefore, the innermost loop, over C, executes at most n times.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">disjoint2</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span> <span class="o">]</span> <span class="n">groupA</span><span class="o">,</span> <span class="kt">int</span><span class="o">[</span> <span class="o">]</span> <span class="n">groupB</span><span class="o">,</span> <span class="kt">int</span><span class="o">[</span> <span class="o">]</span> <span class="n">groupC</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">:</span> <span class="n">groupA</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">:</span> <span class="n">groupB</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">){</span>  <span class="c1">// n times</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">:</span> <span class="n">groupC</span><span class="o">)</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">c</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">// the worst-case running time for disjoint2 is O(n^2).</span>
</pre></table></code></div></div></ul><li><strong>Element Uniqueness</strong><ol><li>looping through all distinct pairs of indices j &lt; k: <code class="language-plaintext highlighter-rouge">O(n2)</code><li>Using Sorting as a Problem-Solving Tool:<ul><li>The best sorting algorithms (including those used by Array.sort in Java) guarantee a worst-case running time of <code class="language-plaintext highlighter-rouge">O(nlogn)</code>.<li>the subsequent loop runs in O(n) time,<li><p>and so the entire unique2 algorithm runs in <code class="language-plaintext highlighter-rouge">O(n log n)</code> time.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">unique2</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
     <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
     <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
     <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>             <span class="c1">// O(nlogn)</span>
     <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="err">−</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>   <span class="c1">// n</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">temp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">temp</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">])</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
     <span class="o">}</span>
     <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
 <span class="o">}</span>
</pre></table></code></div></div></ul></ol><li><strong>Prefix Averages</strong><ul><li>given a sequence x consisting of n numbers, compute a sequence a such that aj is the average of elements x0,…,xj<ol><li><p>Quadratic-Time Algorithm: <code class="language-plaintext highlighter-rouge">O(n^2)</code></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">double</span><span class="o">[</span> <span class="o">]</span> <span class="n">prefixAverage1</span><span class="o">(</span><span class="kt">double</span><span class="o">[</span> <span class="o">]</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
     <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>                <span class="c1">// O(1) time.</span>
     <span class="kt">double</span><span class="o">[</span> <span class="o">]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>     <span class="c1">// O(1) time.</span>
     <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>      <span class="c1">// n</span>
         <span class="kt">double</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
         <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>  <span class="c1">// n-1</span>
             <span class="n">total</span> <span class="o">+=</span> <span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
             <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">total</span> <span class="o">/</span> <span class="o">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
 <span class="o">}</span>
</pre></table></code></div></div></ol></ul><ol><li><p>Linear-Time Algorithm: <code class="language-plaintext highlighter-rouge">O(n)</code></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">double</span><span class="o">[</span> <span class="o">]</span> <span class="n">prefixAverage2</span><span class="o">(</span><span class="kt">double</span><span class="o">[]</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
     <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>                <span class="c1">// O(1) time.</span>
     <span class="kt">double</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>      <span class="c1">// O(1) time.</span>
     <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
     <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>      <span class="c1">// n</span>
         <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">x</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">/</span> <span class="o">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
     <span class="o">}</span>
     <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
 <span class="o">}</span>

 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">double</span><span class="o">[</span> <span class="o">]</span> <span class="n">prefixAverage2</span><span class="o">(</span><span class="kt">double</span><span class="o">[]</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
     <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>                <span class="c1">// O(1) time.</span>
     <span class="kt">double</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>      <span class="c1">// O(1) time.</span>
     <span class="kt">double</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
     <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>      <span class="c1">// n</span>
         <span class="n">total</span> <span class="o">+=</span> <span class="n">x</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
         <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">total</span><span class="o">/(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
     <span class="o">}</span>
     <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
 <span class="o">}</span>
</pre></table></code></div></div></ol></ul><hr /><h4 id="o1-constant-time-operations">O(1): Constant-Time Operations</h4><ul><li>code that executes in the same amount of time no matter how big the array is</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">sum</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
<span class="c1">// T(n)=1</span>
<span class="c1">// O(1): 表示算法的运行时间为常量</span>
<span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</pre></table></code></div></div><hr /><h4 id="on-二分查找算法">O(㏒N): 二分查找算法</h4><p>$2^t$ &lt; n</p><p>t &lt; log2(n)</p><ul><li>when data being used is decreased roughly by 50% each time through the algorithm<li>as ㏒N increases or N specifically increases<li>the different between N and logN will be dramatically different</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>                   <span class="c1">// 1</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">)</span> <span class="o">{</span>             <span class="c1">//2,3,....n</span>
    <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">;</span>                 <span class="c1">// 设语句2的频度是t</span>
<span class="o">}</span>
<span class="c1">// 2^t &lt;= n</span>
<span class="c1">// t &lt;= log2(n)</span>
<span class="c1">// 取最大值t = log2(n),</span>
<span class="c1">// T(n) = O(log2n)</span>


<span class="n">aFunc</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>  <span class="c1">//2,3,....n:  n-1</span>
        <span class="n">i</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">;</span>                    <span class="c1">//假设循环次数为 t，则循环条件满足 2^t &lt; n。</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 2^t &lt; n</span>
<span class="c1">// t &lt; log2(n)</span>
</pre></table></code></div></div><hr /><h4 id="on-线性算法-linear-time">O(n): 线性算法 linear time</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>               <span class="err">①</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span>
<span class="k">for</span> <span class="o">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="err">②</span> <span class="n">n</span>
<span class="o">{</span>
    <span class="n">s</span><span class="o">=</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">;</span><span class="err">　　　　③</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">b</span><span class="o">=</span><span class="n">a</span><span class="o">;</span><span class="err">　　　　　④</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">a</span><span class="o">=</span><span class="n">s</span><span class="o">;</span><span class="err">　　　　　⑤</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
<span class="o">}</span>
<span class="c1">// 解: T(n)=2+n+3(n-1)=4n-1= O(n).</span>


<span class="kt">int</span> <span class="nf">aFunc</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>         <span class="c1">// 需要执行 (n + 1) 次</span>
        <span class="n">printf</span><span class="o">(</span><span class="s">"Hello, World!\n"</span><span class="o">);</span>     <span class="c1">// 需要执行 n 次</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>       <span class="c1">// 需要执行 1 次</span>
<span class="o">}</span>
<span class="c1">// 解: T(n)= (n + 1 + n + 1) = 2n + 2 = O(n).</span>
</pre></table></code></div></div><hr /><h4 id="onn-二分查找算法">O(N㏒N: 二分查找算法</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>   <span class="c1">// n</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>                   <span class="c1">// 1</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">;</span>                 <span class="c1">// 设语句2的频度是t</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// T(n)=O(n * log2(N))</span>
</pre></table></code></div></div><hr /><h4 id="on2">O($n^2$)</h4><p><code class="language-plaintext highlighter-rouge">Big o n square</code></p><ul><li>对数组进行排序的简单算法，例如直接插入排序的算法。<li>The time to complete will be proportional to the square of the amount of data</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="o">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>            <span class="c1">// n</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="o">{</span>      <span class="c1">// n</span>
        <span class="n">x</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// T(n) = O(n^2)</span>
</pre></table></code></div></div><h4 id="on3-做两个n阶矩阵的乘法运算">O($n^3$) 做两个n阶矩阵的乘法运算</h4><p><code class="language-plaintext highlighter-rouge">n cube</code></p><ul><li>n^3 增长速度远超 n^2，n^2 增长速度远超 n</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>           <span class="c1">// i=m</span>
    <span class="k">for</span><span class="o">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>       <span class="c1">// j=(m-1)*m</span>
        <span class="k">for</span><span class="o">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">j</span><span class="o">;</span><span class="n">k</span><span class="o">++)</span>    <span class="c1">// k=(m-1)m-1</span>
            <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="o2n-求具有n个元素集合的所有子集的算法">O($2^n$): 求具有n个元素集合的所有子集的算法</h4><hr /><h4 id="on-求具有n个元素的全排列的算法">O(n!): 求具有N个元素的全排列的算法</h4><hr /><h2 id="simple-justification-techniques">Simple Justification Techniques</h2><ul><li>make claims about an algorithm, such as showing that it is correct or that it runs fast.<li>we must justify or prove our statements.</ul><h3 id="counterexample-by-example">counterexample: By Example</h3><ul><li>Some claims are of the generic form,<li>“There is an element x in a set S that has property P.”<ul><li>only need to produce a particular x in S that has property P.</ul><li>“Every element x in a set S has property P.”<ul><li>To justify that such a claim is false,<li>we only need to produce a particular x from S that does not have property P.</ul><li>Such an instance is called a counterexample.</ul><blockquote><p>Example 4.17: Professor Amongus claims that every number of the form 2i − 1 is a prime, when i is an integer greater than 1. Professor Amongus is wrong. Justification: To prove Professor Amongus is wrong, we find a counterexample. 24 −1 = 15 = 3·5.</p></blockquote><h3 id="contrapositive-and-the-contradiction-the-contra-attack">contrapositive and the contradiction: The “Contra” Attack</h3><ul><li>Another set of justification techniques involves the use of the negative. The two primary such methods are the use of the contrapositive and the contradiction.</ul><p><strong>contrapositive</strong></p><ul><li>“if p is true, then q is true,”<ul><li>we establish that “if q is not true, then p is not true” instead.<li>Logically, these two statements are the same, but the latter, which is called the contrapositive of the first, may be easier to think about.</ul></ul><blockquote><p>Example 4.18: Let a and b be integers. If ab is even, then a is even or b is even. Justification: To justify this claim, consider the contrapositive, “If a is odd and b is odd, then ab is odd.” a = 2 j + 1 and b = 2k + 1, for some integers j and k. Then ab = 4jk+2j+2k+1 = 2(2jk+ j+k)+1; hence, ab is odd.</p></blockquote><ul><li>de Morgan’s law<ul><li>the negation of a statement of the form “p or q” is “not p and not q.”<li>the negation of a statement of the form “p and q”is“not p or not q.”</ul></ul><p><strong>Contradiction</strong></p><ul><li>we establish that a statement q is true by first supposing that q is false and then showing that this assumption leads to a contradiction (such as 2 ̸= 2 or 1 &gt; 3).<li>By reaching such a contradiction, we show that no consistent situation exists with q being false, so q must be true. Of course, in order to reach this conclusion, we must be sure our situation is consistent before we assume q is false.</ul><blockquote><p>Example 4.19: Let a and b be integers. If ab is odd, then a is odd and b is odd. Justification: suppose a is even or b is even. In fact, without loss of generality, we can assume that a is even (since the case for b is symmetric). Then a = 2 j for some integer j. Hence, ab = (2 j)b = 2( jb), that is, ab is even. But this is a contradiction: ab cannot simultaneously be odd and even. Therefore, a is odd and b is odd.</p></blockquote><hr /><h3 id="induction-and-loop-invariants">Induction and Loop Invariants</h3><ul><li>Most of the claims we make about a running time or a space bound involve an integer parameter n (usually denoting an intuitive notion of the “size” of the problem).<li>Moreover, most of these claims are equivalent to saying some statement q(n) is true “for all n ≥ 1.”<li>Since this is making a claim about an infinite set of numbers, we cannot justify this exhaustively in a direct fashion.</ul><p><strong>Induction</strong></p><ul><li>justify claims as true by using <strong>induction</strong>.<li>This technique amounts to showing that, for any particular n ≥ 1, there is a finite sequence of implications that starts with something known to be true and ultimately leads to showing that q(n) is true.<li>begin a justification by induction by showing that q(n) is true for n = 1 (and possibly some other values n = 2, 3, . . . , k, for some constant k).<li>justify that the inductive “step” is true for n &gt; k<li>we show “if q(j) is true for all j &lt; n, then q(n) is true.”<li>The combination of these two pieces completes the justification by induction.</ul><blockquote><p>Consider the Fibonacci function F(n), which is defined such that F(1) = 1, F(2) = 2, and <code class="language-plaintext highlighter-rouge">F(n) = F(n−2)+F(n−1)</code> for n &gt; 2. F(n) &lt; 2^n. Justification: Basecases:(n≤2). F(1)=1&lt;2=2^1 F(2)=2&lt;4=2^2 Induction step: (n &gt; 2). Suppose our claim is true for all j &lt; n. Since both n − 2 and n − 1 are less than n, we can apply the inductive assumption (sometimes called the “inductive hypothesis”) to imply that Since F(n) = F(n−2)+F(n−1) &lt; 2^n−2 +2^n−1. 2^n−2 +2^n−1 &lt; 2^n−1 +2^n−1 = 2·2^n−1 = 2^n we have that F(n) &lt; 2n, thus showing the inductive hypothesis for n.</p></blockquote><p><strong>Loop Invariants</strong></p><ul><li>To prove some statement L about a loop is correct,<li>define L in terms of a series of smaller statements L0,L1,…,Lk, where:<ol><li>The initial claim, L0, is true before the loop begins.<li>If Lj−1 is true before iteration j, then Lj will be true after iteration j.<li>The final statement, Lk, implies the desired statement L to be true.</ol></ul><hr /><h1 id="35-performance-of-python-data-structures">3.5. Performance of Python Data Structures</h1><p><img data-proofer-ignore data-src="https://i.imgur.com/3Fma2jK.png" alt="Screen Shot 2020-05-26 at 00.32.28" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/1FedT9U.png" alt="Screen Shot 2020-05-26 at 00.43.30" /></p><hr /><h2 id="36-lists">3.6. Lists</h2><p>Common programming task is to grow a list.</p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">test1</span><span class="p">():</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test2</span><span class="p">():</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
        <span class="n">l</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test3</span><span class="p">():</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">test4</span><span class="p">():</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
</pre></table></code></div></div><p>use Python’s <code class="language-plaintext highlighter-rouge">timeit</code> module: make cross-platform timing measurements by running functions in a consistent environment and using timing mechanisms that are as similar as possible across operating systems.</p><ul><li>create a <code class="language-plaintext highlighter-rouge">Timer</code> object<li>parameters are two Python statements.<ul><li>The first parameter is a <code class="language-plaintext highlighter-rouge">Python statement that want to time</code>;<li>the second parameter is a <code class="language-plaintext highlighter-rouge">statement that will run once to set up the test</code>.</ul><li>The timeit module will then time how long it takes to execute the statement some number of times.<li>By default timeit will try to run the statement one million times.<li>When its done it returns the time as a floating point value representing the total number of seconds.<li>However, since it executes the statement a million times you can read the result as the number of microseconds to execute the test one time. You can also pass timeit a named parameter called number that allows you to specify how many times the test statement is executed.<li>The following session shows how long it takes to run each of our test functions 1000 times.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">timeit</span> <span class="kn">import</span> <span class="n">Timer</span>

<span class="n">t1</span> <span class="o">=</span> <span class="nc">Timer</span><span class="p">(</span><span class="s">"test1()"</span><span class="p">,</span> <span class="s">"from __main__ import test1"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"concatenation: </span><span class="si">{</span><span class="n">t1</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span><span class="si">:</span><span class="mf">15.2</span><span class="n">f</span><span class="si">}</span><span class="s"> milliseconds"</span><span class="p">)</span>

<span class="n">t2</span> <span class="o">=</span> <span class="nc">Timer</span><span class="p">(</span><span class="s">"test2()"</span><span class="p">,</span> <span class="s">"from __main__ import test2"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"appending: </span><span class="si">{</span><span class="n">t2</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span><span class="si">:</span><span class="mf">19.2</span><span class="n">f</span><span class="si">}</span><span class="s"> milliseconds"</span><span class="p">)</span>

<span class="n">t3</span> <span class="o">=</span> <span class="nc">Timer</span><span class="p">(</span><span class="s">"test3()"</span><span class="p">,</span> <span class="s">"from __main__ import test3"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"list comprehension: </span><span class="si">{</span><span class="n">t3</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span><span class="si">:</span><span class="mf">10.2</span><span class="n">f</span><span class="si">}</span><span class="s"> milliseconds"</span><span class="p">)</span>

<span class="n">t4</span> <span class="o">=</span> <span class="nc">Timer</span><span class="p">(</span><span class="s">"test4()"</span><span class="p">,</span> <span class="s">"from __main__ import test4"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"list range: </span><span class="si">{</span><span class="n">t4</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span><span class="si">:</span><span class="mf">18.2</span><span class="n">f</span><span class="si">}</span><span class="s"> milliseconds"</span><span class="p">)</span>

<span class="c1"># concatenation:           6.54 milliseconds
# appending:               0.31 milliseconds
# list comprehension:      0.15 milliseconds
# list range:              0.07 milliseconds
</span></pre></table></code></div></div><blockquote><p>In this case the statement from <strong>main</strong> import test1 imports the function test1 from the <strong>main</strong> namespace into the namespace that timeit sets up for the timing experiment. The timeit module does this because it wants to run the timing tests in an environment that is uncluttered by any stray variables you may have created, that may interfere with your function’s performance in some unforeseen way.</p></blockquote><p>all of the times include some overhead for actually calling the test function,</p><ul><li>but we can assume that the function call overhead is identical in all four cases so we still get a meaningful comparison of the operations.<li>So it would not be accurate to say that the concatenation operation takes 6.54 milliseconds but rather <code class="language-plaintext highlighter-rouge">the concatenation test function takes 6.54 milliseconds</code>.</ul><p>Big-O Efficiency of Python List Operators</p><div class="table-wrapper"><table><thead><tr><th>Operation<th>Big-O Efficiency<tbody><tr><td>index []<td><kbd>O(1)</kbd><tr><td>index assignment<td><kbd>O(1)</kbd><tr><td>append<td><kbd>O(1)</kbd><tr><td>pop()<td><kbd>O(1)</kbd><tr><td>pop(i)<td><kbd>O(n)</kbd><tr><td>insert(i,item)<td><kbd>O(n)</kbd><tr><td>del operator<td><kbd>O(n)</kbd><tr><td>iteration<td><kbd>O(n)</kbd><tr><td>contains (in)<td><kbd>O(n)</kbd><tr><td><code class="language-plaintext highlighter-rouge">get slice [x:y]</code><td><kbd>O(k)</kbd><tr><td>del slice<td><kbd>O(n)</kbd><tr><td>set slice<td><kbd>O(n+k)</kbd><tr><td>reverse<td><kbd>O(n)</kbd><tr><td>concatenate<td><kbd>O(k)</kbd><tr><td>sort<td><kbd>O(n log n)</kbd><tr><td>multiply<td><kbd>O(nk)</kbd></table></div><p>different times for pop.</p><ul><li>When pop is called on the end of the list it takes <kbd>𝑂(1)</kbd><li>when pop is called on the first element in the list or anywhere in the middle it is <kbd>𝑂(𝑛)</kbd><ul><li>The reason for this lies in how Python chooses to implement lists.<li>When an item is taken from the front of the list, in Python’s implementation, all the other elements in the list are shifted one position closer to the beginning.</ul></ul><p>As a way of demonstrating this difference in performance let’s do another experiment using the timeit module. Our goal is to be able to verify the performance of the pop operation on a list of a known size when the program pops from the end of the list, and again when the program pops from the beginning of the list. We will also want to measure this time for lists of different sizes. What we would expect to see is that the time required to pop from the end of the list will stay constant even as the list grows in size, while the time to pop from the beginning of the list will continue to increase as the list grows.</p><p>Listing 4 shows one attempt to measure the difference between the two uses of pop. As you can see from this first example, popping from the end takes 0.0003 milliseconds, whereas popping from the beginning takes 4.82 milliseconds. For a list of two million elements this is a factor of 16,000.</p><blockquote><p>the statement from <strong>main</strong> import x. Although we did not define a function we do want to be able to use the list object x in our test. This approach allows us to time just the single pop statement and get the most accurate measure of the time for that single operation. Because the timer repeats 1000 times it is also important to point out that the list is decreasing in size by 1 each time through the loop. But since the initial list is two million elements in size we only reduce the overall size by 0.05%</p></blockquote><p>to show that pop(0) is indeed slower than pop():</p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">pop_zero</span> <span class="o">=</span> <span class="nc">Timer</span><span class="p">(</span><span class="s">"x.pop(0)"</span><span class="p">,</span> <span class="s">"from __main__ import x"</span><span class="p">)</span>
<span class="n">pop_end</span> <span class="o">=</span> <span class="nc">Timer</span><span class="p">(</span><span class="s">"x.pop()"</span><span class="p">,</span> <span class="s">"from __main__ import x"</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">2000000</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"pop(0): </span><span class="si">{</span><span class="n">pop_zero</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span><span class="si">:</span><span class="mf">10.5</span><span class="n">f</span><span class="si">}</span><span class="s"> milliseconds"</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">2000000</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"pop(): </span><span class="si">{</span><span class="n">pop_end</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span><span class="si">:</span><span class="mf">11.5</span><span class="n">f</span><span class="si">}</span><span class="s"> milliseconds"</span><span class="p">)</span>

<span class="c1"># pop(0):    2.09779 milliseconds
# pop():     0.00014 milliseconds
</span></pre></table></code></div></div><p>to validate the claim that pop(0) is 𝑂(𝑛) while pop() is 𝑂(1)</p><ul><li>look at the performance of both calls over a range of list sizes.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">pop_zero</span> <span class="o">=</span> <span class="nc">Timer</span><span class="p">(</span><span class="s">"x.pop(0)"</span><span class="p">,</span> <span class="s">"from __main__ import x"</span><span class="p">)</span>
<span class="n">pop_end</span> <span class="o">=</span> <span class="nc">Timer</span><span class="p">(</span><span class="s">"x.pop()"</span><span class="p">,</span> <span class="s">"from __main__ import x"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="s">'n'</span><span class="si">:</span><span class="mi">10</span><span class="n">s</span><span class="si">}{</span><span class="s">'pop(0)'</span><span class="si">:</span><span class="o">&gt;</span><span class="mi">15</span><span class="n">s</span><span class="si">}{</span><span class="s">'pop()'</span><span class="si">:</span><span class="o">&gt;</span><span class="mi">15</span><span class="n">s</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1_000_000</span><span class="p">,</span> <span class="mi">100_000_001</span><span class="p">,</span> <span class="mi">1_000_000</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">pop_zero_t</span> <span class="o">=</span> <span class="n">pop_zero</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">pop_end_t</span> <span class="o">=</span> <span class="n">pop_end</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="o">&lt;</span><span class="mi">10</span><span class="n">d</span><span class="si">}{</span><span class="n">pop_zero_t</span><span class="si">:</span><span class="o">&gt;</span><span class="mf">15.5</span><span class="n">f</span><span class="si">}{</span><span class="n">pop_end_t</span><span class="si">:</span><span class="o">&gt;</span><span class="mf">15.5</span><span class="n">f</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="https://i.imgur.com/30bdfeg.png" alt="poptime" /></p><ul><li>the list gets longer and longer<li>the time it takes to pop(0) also increases<li>while the time for pop stays very flat.<li>This is exactly what we would expect to see for a 𝑂(𝑛) and 𝑂(1) algorithm.</ul><blockquote><p>Some sources of error in our little experiment include the fact that there are other processes running on the computer as we measure that may slow down our code, That is why the loop runs the test one thousand times in the first place to statistically gather enough information to make the measurement reliable.</p></blockquote><hr /><h2 id="37-dictionaries">3.7. Dictionaries</h2><ul><li>the <code class="language-plaintext highlighter-rouge">get item</code> and <code class="language-plaintext highlighter-rouge">set item</code> operations on a dictionary are 𝑂(1).<li>Checking to see <code class="language-plaintext highlighter-rouge">whether a key is in the dictionary</code> or not is also 𝑂(1).</ul><blockquote><p>the efficiencies we provide in the table are for average performance. In some rare cases the contains, get item, and set item operations can degenerate into 𝑂(𝑛) performance</p></blockquote><p>Big-O Efficiency of Python Dictionary Operations</p><div class="table-wrapper"><table><thead><tr><th>operation<th>Big-O Efficiency<tbody><tr><td>copy<td><kbd>O(n)</kbd><tr><td>get item<td><kbd>O(1)</kbd><tr><td>set item<td><kbd>O(1)</kbd><tr><td>delete item<td><kbd>O(1)</kbd><tr><td>contains (in)<td><kbd>O(1)</kbd><tr><td>iteration<td><kbd>O(n)</kbd></table></div><p>compare the performance of the <code class="language-plaintext highlighter-rouge">contains operation</code> between <strong>lists</strong> and <strong>dictionaries</strong>.</p><ul><li>make a list with a range of numbers in it.<li>pick numbers at random and check to see if the numbers are in the list.<li>If our performance tables are correct, the bigger the list the longer it should take to determine if any one number is contained in the list.</ul><p>We will repeat the same experiment for a dictionary that contains numbers as the keys.</p><ul><li>determining whether or not a number is in the dictionary is not only much faster,<li>but the time it takes to check should remain constant even as the dictionary grows larger.</ul><p>Listing 6 implements this comparison. Notice that we are performing exactly the same operation, number in container. The difference is that on line 8 x is a list, and on line 10 x is a dictionary.</p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">timeit</span>
<span class="kn">import</span> <span class="n">random</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="s">'n'</span><span class="si">:</span><span class="mi">10</span><span class="n">s</span><span class="si">}{</span><span class="s">'list'</span><span class="si">:</span><span class="o">&gt;</span><span class="mi">10</span><span class="n">s</span><span class="si">}{</span><span class="s">'dict'</span><span class="si">:</span><span class="o">&gt;</span><span class="mi">10</span><span class="n">s</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10_000</span><span class="p">,</span> <span class="mi">1_000_001</span><span class="p">,</span> <span class="mi">20_000</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">timeit</span><span class="p">.</span><span class="nc">Timer</span><span class="p">(</span><span class="sa">f</span><span class="s">"random.randrange(</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">) in x"</span><span class="p">,</span> <span class="s">"from __main__ import random, x"</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">lst_time</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="n">j</span><span class="p">:</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span><span class="p">)}</span>
    <span class="n">dict_time</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="n">number</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">,</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="n">lst_time</span><span class="si">:</span><span class="o">&gt;</span><span class="mf">10.3</span><span class="n">f</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="n">dict_time</span><span class="si">:</span><span class="o">&gt;</span><span class="mf">10.3</span><span class="n">f</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># n               list      dict
# 10,000          0.085      0.001
# 30,000          0.225      0.001
# 50,000          0.381      0.001
# 70,000          0.542      0.001
# 90,000          0.770      0.001
# 110,000         1.104      0.001
# 130,000         0.993      0.001
# 150,000         1.121      0.001
# 170,000         1.243      0.001
# 190,000         1.375      0.001
# 210,000         1.546      0.001
</span></pre></table></code></div></div><p><img data-proofer-ignore data-src="https://i.imgur.com/ziaxv2F.png" alt="listvdict" /></p><hr /><p>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/00codenote/'>00CodeNote</a>, <a href='/categories/ds/'>DS</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Data Structures - Basic 1 - Analysis - Grace&url=https://ocholuo.github.io//posts/DS-Basic1-Analysis/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Data Structures - Basic 1 - Analysis - Grace&u=https://ocholuo.github.io//posts/DS-Basic1-Analysis/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Data Structures - Basic 1 - Analysis - Grace&url=https://ocholuo.github.io//posts/DS-Basic1-Analysis/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Amazon-CloudFront/">AWS Lab - AWS CloudFront</a><li><a href="/posts/Alexa-1stSkill/">AWS Alex First Skill - RedVelvet Time</a><li><a href="/posts/NetworkProtocol-SSL-TLS-Handshake/">NetworkProtocol SSL/TLS Handshake</a><li><a href="/posts/pythonCrash/">Python Crash</a><li><a href="/posts/%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%A7%A3%E9%87%8AAWS/">AWS - 一句话解释AWS</a><li><a href="/posts/GKE/">GCP - Google Cloud Computing - Kubernetes and Kubernetes Engine</a><li><a href="/posts/Go-Note/">Go Note</a><li><a href="/posts/SCPs/">AWS - IdenAccessManage - SCPs (Service Control Policies)</a><li><a href="/posts/CompanyBenefit/">Company Benefit</a><li><a href="/posts/Encryption-SSL&TLS/">Cryptography - SSL/TLS Encryption</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/soc/">SOC</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/DS-Basic1-DS/"><div class="card-body"> <span class="timeago small" >Oct 10, 2021<i class="unloaded">2021-10-10T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Data Structures - Basic 1 - Data Structures</h3><div class="text-muted small"><p> Data Structures - Basic 1 - Data Structures overall pic Linear Structures String String class StringBuilder class ...</p></div></div></a></div><div class="card"> <a href="/posts/DS-Basic0-OOD/"><div class="card-body"> <span class="timeago small" >Oct 10, 2021<i class="unloaded">2021-10-10T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Data Structures - Basic 0 - Object Oriented Programming</h3><div class="text-muted small"><p> Object-oriented programming 面向对象编程 language different 面向过程和OOP在程序流程上的不同之处。 code different OOP inter Basic OOD Goals...</p></div></div></a></div><div class="card"> <a href="/posts/DS-Basic0/"><div class="card-body"> <span class="timeago small" >Oct 10, 2021<i class="unloaded">2021-10-10T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Data Structures - Basic 0</h3><div class="text-muted small"><p> DS Type Base Type Enum Types 枚举 Type Conversions Wrapper Classes and Objects Creating and Using O...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/8-Graphy/" class="btn btn-outline-primary" prompt="Older"><p>DS - pythonds3 - 8. Graphs and Graph Algorithms</p></a> <a href="/posts/DS-Basic1-Recursion/" class="btn btn-outline-primary" prompt="Newer"><p>Data Structures - Basic 1 - Recursion</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/ocholuo">Grace JyL</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/soc/">SOC</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://ocholuo.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script defer src="/assets/js/dist/pvreport.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-179830187-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-179830187-1'); }); </script>
