<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="pv-proxy-endpoint" content="https://myochosite-291718.appspot.com/query?id=ahNwfm15b2Nob3NpdGUtMjkxNzE4chULEghBcGlRdWVyeRiAgIDo14eBCgw"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="DS - pythonds3 - 8. Graphs and Graph Algorithms" /><meta property="og:locale" content="en" /><meta name="description" content="pythonds3 - 8. Graphs and Graph Algorithms Graphs Vocabulary and Definitions The Graph Abstract Data Type An Adjacency Matrix 邻接矩阵 An Adjacency List 邻接表 Implementation example The Word Ladder Problem implement Implement: Breadth First Search (BFS) Analysis The Knight’s Tour Problem Implement Implement: Depth first search (DFS) Analysis Improve: heuristic search: Warnsdorff’s algorithm Graph Algorithms Breadth First Search O(|V| + |E|) Depth First Search O(|V| + |E|) example Depth First Search Analysis Topological Sorting using Depth First Search (DFS) Topological 拓扑 Sorting O(|V| + |E|) stirring up a batch of pancakes: Strongly Connected Components strongly connected components algorithm (SCC) for web pages example Shortest Path Problems for host Dijkstra’s Algorithm O(|V|^2) Analysis of Dijkstra’s Algorithm broadcast host The simplest solution uncontrolled flooding spanning tree Prim’s algorithm O(|V|^2) Tarjan’s algorithm Greedy Algorithms Bitmasks other Algorithm Bellman-Ford Algorithm Floyd-Warshall Algorithm Kruskal’s Algorithm O(|E|log|V|)" /><meta property="og:description" content="pythonds3 - 8. Graphs and Graph Algorithms Graphs Vocabulary and Definitions The Graph Abstract Data Type An Adjacency Matrix 邻接矩阵 An Adjacency List 邻接表 Implementation example The Word Ladder Problem implement Implement: Breadth First Search (BFS) Analysis The Knight’s Tour Problem Implement Implement: Depth first search (DFS) Analysis Improve: heuristic search: Warnsdorff’s algorithm Graph Algorithms Breadth First Search O(|V| + |E|) Depth First Search O(|V| + |E|) example Depth First Search Analysis Topological Sorting using Depth First Search (DFS) Topological 拓扑 Sorting O(|V| + |E|) stirring up a batch of pancakes: Strongly Connected Components strongly connected components algorithm (SCC) for web pages example Shortest Path Problems for host Dijkstra’s Algorithm O(|V|^2) Analysis of Dijkstra’s Algorithm broadcast host The simplest solution uncontrolled flooding spanning tree Prim’s algorithm O(|V|^2) Tarjan’s algorithm Greedy Algorithms Bitmasks other Algorithm Bellman-Ford Algorithm Floyd-Warshall Algorithm Kruskal’s Algorithm O(|E|log|V|)" /><link rel="canonical" href="https://ocholuo.github.io//posts/8-Graphy/" /><meta property="og:url" content="https://ocholuo.github.io//posts/8-Graphy/" /><meta property="og:site_name" content="Grace" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-08-25T11:11:11-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="DS - pythonds3 - 8. Graphs and Graph Algorithms" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-10-30T21:02:21-04:00","datePublished":"2019-08-25T11:11:11-04:00","description":"pythonds3 - 8. Graphs and Graph Algorithms Graphs Vocabulary and Definitions The Graph Abstract Data Type An Adjacency Matrix 邻接矩阵 An Adjacency List 邻接表 Implementation example The Word Ladder Problem implement Implement: Breadth First Search (BFS) Analysis The Knight’s Tour Problem Implement Implement: Depth first search (DFS) Analysis Improve: heuristic search: Warnsdorff’s algorithm Graph Algorithms Breadth First Search O(|V| + |E|) Depth First Search O(|V| + |E|) example Depth First Search Analysis Topological Sorting using Depth First Search (DFS) Topological 拓扑 Sorting O(|V| + |E|) stirring up a batch of pancakes: Strongly Connected Components strongly connected components algorithm (SCC) for web pages example Shortest Path Problems for host Dijkstra’s Algorithm O(|V|^2) Analysis of Dijkstra’s Algorithm broadcast host The simplest solution uncontrolled flooding spanning tree Prim’s algorithm O(|V|^2) Tarjan’s algorithm Greedy Algorithms Bitmasks other Algorithm Bellman-Ford Algorithm Floyd-Warshall Algorithm Kruskal’s Algorithm O(|E|log|V|)","headline":"DS - pythonds3 - 8. Graphs and Graph Algorithms","mainEntityOfPage":{"@type":"WebPage","@id":"https://ocholuo.github.io//posts/8-Graphy/"},"url":"https://ocholuo.github.io//posts/8-Graphy/"}</script><title>DS - pythonds3 - 8. Graphs and Graph Algorithms | Grace</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Grace"><meta name="application-name" content="Grace"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://myochosite-291718.appspot.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://myochosite-291718.appspot.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/huoye.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Grace</a></div><div class="site-subtitle font-italic">2023 Mar 14 updated</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ocholuo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>DS - pythonds3 - 8. Graphs and Graph Algorithms</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>DS - pythonds3 - 8. Graphs and Graph Algorithms</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Grace JyL </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Aug 25, 2019, 11:11 AM -0400" >Aug 25, 2019<i class="unloaded">2019-08-25T11:11:11-04:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Oct 30, 2022, 6:02 PM -0700" >Oct 30, 2022<i class="unloaded">2022-10-30T21:02:21-04:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="9978 words">55 min read</span> <span id="pv" class="pageviews"> <i class="fas fa-spinner fa-spin fa-fw"></i> </span> views</div></div><div class="post-content"><ul><li><a href="#pythonds3---8-graphs-and-graph-algorithms">pythonds3 - 8. Graphs and Graph Algorithms</a><ul><li><a href="#graphs">Graphs</a><ul><li><a href="#vocabulary-and-definitions">Vocabulary and Definitions</a><li><a href="#the-graph-abstract-data-type">The Graph Abstract Data Type</a><ul><li><a href="#an-adjacency-matrix-邻接矩阵">An Adjacency Matrix 邻接矩阵</a><li><a href="#an-adjacency-list-邻接表">An Adjacency List 邻接表</a><li><a href="#implementation">Implementation</a></ul></ul><li><a href="#example">example</a><ul><li><a href="#the-word-ladder-problem">The Word Ladder Problem</a><ul><li><a href="#implement">implement</a><li><a href="#implement-breadth-first-search-bfs">Implement: Breadth First Search (BFS)</a><li><a href="#analysis">Analysis</a></ul><li><a href="#the-knights-tour-problem">The Knight’s Tour Problem</a><ul><li><a href="#implement-1">Implement</a><li><a href="#implement-depth-first-search-dfs">Implement: Depth first search (DFS)</a><li><a href="#analysis-1">Analysis</a><li><a href="#improve-heuristic-search-warnsdorffs-algorithm">Improve: heuristic search: Warnsdorff’s algorithm</a></ul></ul></ul><li><a href="#graph-algorithms">Graph Algorithms</a><ul><li><a href="#breadth-first-search-ov--e">Breadth First Search <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></a><li><a href="#depth-first-search-ov--e">Depth First Search <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></a><ul><li><a href="#example-1">example</a><li><a href="#depth-first-search-analysis">Depth First Search Analysis</a><li><a href="#topological-sorting-using-depth-first-search-dfs">Topological Sorting using Depth First Search (DFS)</a></ul><li><a href="#topological-拓扑-sorting-ov--e">Topological 拓扑 Sorting <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></a><ul><li><a href="#stirring-up-a-batch-of-pancakes">stirring up a batch of pancakes:</a></ul><li><a href="#strongly-connected-components">Strongly Connected Components</a><ul><li><a href="#strongly-connected-components-algorithm-scc">strongly connected components algorithm (SCC)</a><ul><li><a href="#for-web-pages">for web pages</a><li><a href="#example-2">example</a></ul><li><a href="#shortest-path-problems">Shortest Path Problems</a><ul><li><a href="#for-host">for host</a><li><a href="#dijkstras-algorithm-ov2"><strong>Dijkstra’s Algorithm</strong> <code class="language-plaintext highlighter-rouge">O(|V|^2)</code></a><ul><li><a href="#analysis-of-dijkstras-algorithm">Analysis of Dijkstra’s Algorithm</a></ul><li><a href="#broadcast-host">broadcast host</a><ul><li><a href="#the-simplest-solution">The simplest solution</a><li><a href="#uncontrolled-flooding">uncontrolled flooding</a><li><a href="#spanning-tree">spanning tree</a></ul><li><a href="#prims-algorithm-ov2"><strong>Prim’s algorithm</strong> <code class="language-plaintext highlighter-rouge">O(|V|^2)</code></a><li><a href="#tarjans-algorithm">Tarjan’s algorithm</a></ul></ul><li><a href="#greedy-algorithms">Greedy Algorithms</a><li><a href="#bitmasks">Bitmasks</a><li><a href="#other-algorithm">other Algorithm</a><ul><li><a href="#bellman-ford-algorithm">Bellman-Ford Algorithm</a><li><a href="#floyd-warshall-algorithm">Floyd-Warshall Algorithm</a><li><a href="#kruskals-algorithm-oelogv">Kruskal’s Algorithm <code class="language-plaintext highlighter-rouge">O(|E|log|V|)</code></a></ul></ul></ul><hr /><h1 id="pythonds3---8-graphs-and-graph-algorithms">pythonds3 - 8. Graphs and Graph Algorithms</h1><hr /><h2 id="graphs">Graphs</h2><p>4 basic ways to represent a graph in memory:</p><ul><li>objects and pointers<li>adjacency matrix<li>adjacency list<li>adjacency map</ul><hr /><h3 id="vocabulary-and-definitions">Vocabulary and Definitions</h3><p><strong>Vertex/node</strong></p><ul><li>a fundamental part of a graph.<li>It can have a name, “key.”<li>A vertex may also have additional information, “payload.”</ul><p><strong>Edge/“arc”</strong></p><ul><li>another fundamental part of a graph.<li>An edge connects two vertices to show that there is a relationship between them.<li>Edges may be one-way or two-way.<ul><li>If the edges in a graph are all one-way, the graph is a <strong>directed graph, digraph</strong>.<ul><li>you must take some step before others.</ul></ul></ul><p><strong>Weight</strong></p><ul><li>Edges may be weighted to show that there is a cost to go from one vertex to another.<li>For example<ul><li>graph of roads that connect one city to another,<li>the weight on the edge might represent the distance between the two cities.</ul></ul><p>With those definitions in hand we can formally define a graph.</p><ul><li>A graph can be represented by 𝐺<li><code class="language-plaintext highlighter-rouge">𝐺=(𝑉,𝐸)</code>.<li><code class="language-plaintext highlighter-rouge">𝑉</code> is a set of vertices<li><code class="language-plaintext highlighter-rouge">𝐸</code> is a set of edges.<ul><li>Each edge is a tuple <code class="language-plaintext highlighter-rouge">(𝑣,𝑤)</code>, <code class="language-plaintext highlighter-rouge">𝑤,𝑣 ∈𝑉</code>.<li>We can add a third component to the edge tuple to represent a weight.<li>A subgraph <code class="language-plaintext highlighter-rouge">𝑠</code> is a set of edges <code class="language-plaintext highlighter-rouge">𝑒</code> and vertices <code class="language-plaintext highlighter-rouge">𝑣</code> such that <code class="language-plaintext highlighter-rouge">𝑒⊂𝐸</code> and <code class="language-plaintext highlighter-rouge">𝑣⊂𝑉</code>.</ul></ul><p><strong>Path</strong></p><ul><li>A path in a graph is a <code class="language-plaintext highlighter-rouge">sequence of vertices</code> that are connected by edges.<li>Formally we would define a path as <code class="language-plaintext highlighter-rouge">𝑤1,𝑤2,...,𝑤𝑛</code> such that <code class="language-plaintext highlighter-rouge">(𝑤𝑖,𝑤𝑖+1)∈𝐸</code> for all ·.<li>The <strong>unweighted path length</strong> is the <code class="language-plaintext highlighter-rouge">number of edges in the path</code>, specifically <code class="language-plaintext highlighter-rouge">𝑛−1</code>.<li>The <strong>weighted path length</strong> is the <code class="language-plaintext highlighter-rouge">sum of the weights of all the edges in the path</code>.<ul><li>For example<li>the <code class="language-plaintext highlighter-rouge">path from 𝑉3 to 𝑉1 is</code> the sequence of vertices <code class="language-plaintext highlighter-rouge">(𝑉3,𝑉4,𝑉0,𝑉1)</code>.<li>The edges are <code class="language-plaintext highlighter-rouge">{(𝑣3,𝑣4,7),(𝑣4,𝑣0,1),(𝑣0,𝑣1,5)}</code>.</ul></ul><p><strong>Cycle</strong></p><ul><li>A cycle in a directed graph is a path that <code class="language-plaintext highlighter-rouge">starts and ends at the same vertex</code>.<ul><li>For example<li>the path <code class="language-plaintext highlighter-rouge">(𝑉5,𝑉2,𝑉3,𝑉5)</code> is a cycle.<li>A graph with no cycles is called an <strong>acyclic graph</strong>.<li>A directed graph with no cycles is called a <strong>directed acyclic graph / DAG</strong><li>We will see that we can solve several important problems if the problem can be represented as a DAG.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/CfiBhju.png" alt="digraph" /></p><ul><li>example of a simple weighted digraph.<li>represent this graph as the set of six vertices: <code class="language-plaintext highlighter-rouge">𝑉={𝑉0,𝑉1,𝑉2,𝑉3,𝑉4,𝑉5}</code><li>and the set of nine edges: <code class="language-plaintext highlighter-rouge">𝐸={(𝑣0,𝑣1,5),(𝑣1,𝑣2,4),(𝑣2,𝑣3,9),(𝑣3,𝑣4,7),(𝑣4,𝑣0,1),(𝑣0,𝑣5,2),(𝑣5,𝑣4,8),(𝑣3,𝑣5,3),(𝑣5,𝑣2,1)}</code></ul><hr /><h3 id="the-graph-abstract-data-type">The Graph Abstract Data Type</h3><p>The graph <strong>abstract data type (ADT)</strong> is defined as follows:</p><ul><li><code class="language-plaintext highlighter-rouge">Graph()</code><ul><li>creates a new, empty graph.</ul><li><code class="language-plaintext highlighter-rouge">addVertex(vert)</code><ul><li>adds an instance of Vertex to the graph.</ul><li><code class="language-plaintext highlighter-rouge">addEdge(fromVert, toVert)</code><ul><li>Adds a new, directed edge to the graph that connects two vertices.</ul><li><code class="language-plaintext highlighter-rouge">addEdge(fromVert, toVert, weight)</code><ul><li>Adds a new, weighted, directed edge to the graph that connects two vertices.</ul><li><code class="language-plaintext highlighter-rouge">getVertex(vertKey)</code><ul><li>finds the vertex in the graph named vertKey.</ul><li><code class="language-plaintext highlighter-rouge">getVertices()</code><ul><li>returns the list of all vertices in the graph.</ul><li><code class="language-plaintext highlighter-rouge">in</code><ul><li>returns <code class="language-plaintext highlighter-rouge">True</code> for a statement of the form <code class="language-plaintext highlighter-rouge">vertex in graph</code>, if the given vertex is in the graph,<li><code class="language-plaintext highlighter-rouge">False</code> otherwise.</ul></ul><p>there are several ways we can implement the graph ADT in Python.</p><ul><li>there are trade-offs in using different representations to implement the ADT described above.<li>There are two well-known implementations of a graph,<ul><li>the <strong>adjacency matrix</strong><li>the <strong>adjacency list</strong>.</ul></ul><hr /><h4 id="an-adjacency-matrix-邻接矩阵">An Adjacency Matrix 邻接矩阵</h4><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">GraphyAM</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">vertList</span> <span class="o">=</span> <span class="p">{</span><span class="s">"id"</span><span class="p">:</span><span class="n">vertex</span><span class="p">}</span>
        <span class="n">self</span><span class="p">.</span><span class="n">numVertices</span> <span class="o">=</span> <span class="mi">0</span>
</pre></table></code></div></div><p>One of the easiest ways to implement a graph is to use a two-dimensional matrix.</p><ul><li>each of the rows and columns represent a <code class="language-plaintext highlighter-rouge">vertex</code> in the graph.<li>The value that is stored in the cell at the <code class="language-plaintext highlighter-rouge">intersection of row 𝑣 and column 𝑤</code> indicates if there is an edge from <code class="language-plaintext highlighter-rouge">vertex 𝑣 to vertex 𝑤</code>.<li>When two vertices are connected by an edge, we say that they are <strong>adjacent</strong>.<li>A value in a cell represents the weight of the edge from vertex 𝑣 to vertex 𝑤.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/5fGmi6O.png" alt="adjMat" /></p><p><strong>advantage</strong></p><ul><li>simple, for small graphs it is easy to see which nodes are connected to other nodes.<li><p>good implementation for a graph when <code class="language-plaintext highlighter-rouge">the number of edges is large</code>.</p><li>However not a very efficient way to store sparse data.<ul><li><code class="language-plaintext highlighter-rouge">most of the cells in the matrix are empty</code> -&gt; this matrix is <strong>“sparse</strong>.” 稀少贫乏</ul></ul><p>How many edges would be needed to fill the matrix?</p><ul><li>Since there is one row and one column for every vertex in the graph, the number of edges required to fill the matrix is <code class="language-plaintext highlighter-rouge">|𝑉|^2</code>.<li>A matrix is full when every vertex is connected to every other vertex.<li>There are few real problems that approach this sort of connectivity.</ul><hr /><h4 id="an-adjacency-list-邻接表">An Adjacency List 邻接表</h4><ul><li>more space-efficient way to implement a sparsely connected graph is to use an adjacency list.<li>keep a master list of all the vertices in the Graph object<li>and then each vertex object in the graph maintains a list of the other vertices that it is connected to.<li>In our implementation of the Vertex class we will use a dictionary rather than a list where the dictionary keys are the vertices, and the values are the weights.</ul><p>advantage</p><ul><li>it allows compactly 紧凑地 represent a sparse graph.<li>easily find all the links that are directly connected to a particular vertex.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/2TJvhir.png" alt="adjlist" /></p><hr /><h4 id="implementation">Implementation</h4><p>Using dictionaries, it is easy to implement the adjacency list in Python.</p><p>create two classes,</p><ul><li><code class="language-plaintext highlighter-rouge">Graph</code>, which holds the master list of vertices,<li><code class="language-plaintext highlighter-rouge">Vertex</code>, which will represent each vertex in the graph.<ul><li>Each Vertex uses a dictionary to keep track of the vertices to which it is connected, and the weight of each edge.<li>This dictionary is called <code class="language-plaintext highlighter-rouge">connectedTo</code>.</ul></ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Vertex</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">id</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">self</span><span class="p">.</span><span class="n">connectedTo</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">addNeighbor</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">nbr</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
      <span class="c1"># add a connection from this vertex to another
</span>      <span class="n">self</span><span class="p">.</span><span class="n">connectedTo</span><span class="p">[</span><span class="n">nbr</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">str</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nb">id</span><span class="p">)</span> <span class="o">+</span> <span class="s">' connectedTo: '</span> <span class="o">+</span> <span class="nf">str</span><span class="p">([</span><span class="n">x</span><span class="p">.</span><span class="nb">id</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">connectedTo</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">getConnections</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
      <span class="c1"># returns all of the vertices in the adjacency list, as represented by the connectedTo instance variable.
</span>      <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">connectedTo</span><span class="p">.</span><span class="nf">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">getId</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nb">id</span>

    <span class="k">def</span> <span class="nf">getWeight</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">nbr</span><span class="p">):</span>
      <span class="c1"># returns the weight of the edge from this vertex to the vertex passed as a parameter.
</span>      <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">connectedTo</span><span class="p">[</span><span class="n">nbr</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">vertList</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">self</span><span class="p">.</span><span class="n">numVertices</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">addVertex</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
      <span class="c1"># adding vertices to a graph
</span>      <span class="n">self</span><span class="p">.</span><span class="n">numVertices</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">numVertices</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">newVertex</span> <span class="o">=</span> <span class="nc">Vertex</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
      <span class="n">self</span><span class="p">.</span><span class="n">vertList</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">newVertex</span>
      <span class="k">return</span> <span class="n">newVertex</span>

    <span class="k">def</span> <span class="nf">getVertex</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertList</span><span class="p">:</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">vertList</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">getVertices</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
      <span class="c1"># returns the names of all of the vertices in the graph
</span>        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">vertList</span><span class="p">.</span><span class="nf">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertList</span>

    <span class="k">def</span> <span class="nf">addEdge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertList</span><span class="p">:</span> <span class="n">nv</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">addVertex</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertList</span><span class="p">:</span> <span class="n">nv</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">addVertex</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">vertList</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="nf">addNeighbor</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">vertList</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">weight</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">iter</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">vertList</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>


<span class="n">g</span> <span class="o">=</span> <span class="nc">Graph</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
  <span class="n">g</span><span class="p">.</span><span class="nf">addVertex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="c1"># display the vertex dictionary.
</span><span class="n">g</span><span class="p">.</span><span class="n">vertList</span>
<span class="c1"># {0: &lt;adjGraph.Vertex instance at 0x41e18&gt;,
#  1: &lt;adjGraph.Vertex instance at 0x7f2b0&gt;,
#  2: &lt;adjGraph.Vertex instance at 0x7f288&gt;,
#  3: &lt;adjGraph.Vertex instance at 0x7f350&gt;,
#  4: &lt;adjGraph.Vertex instance at 0x7f328&gt;,
#  5: &lt;adjGraph.Vertex instance at 0x7f300&gt;}
</span>
<span class="c1"># add the edges that connect the vertices together.
</span><span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># a nested loop
# verifies that each edge in the graph is properly stored.
</span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
<span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">v</span><span class="p">.</span><span class="nf">getConnections</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"( %s , %s )"</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="nf">getId</span><span class="p">(),</span> <span class="n">w</span><span class="p">.</span><span class="nf">getId</span><span class="p">()))</span>
<span class="c1"># ( 0 , 5 )
# ( 0 , 1 )
# ( 1 , 2 )
# ( 2 , 3 )
# ( 3 , 4 )
# ( 3 , 5 )
# ( 4 , 0 )
# ( 5 , 4 )
# ( 5 , 2 )
</span></pre></table></code></div></div><hr /><h2 id="example">example</h2><h3 id="the-word-ladder-problem">The Word Ladder Problem</h3><p>Transform the word “FOOL” into the word “SAGE”.</p><ul><li>must make the change occur gradually by changing one letter at a time.<li>At each step you must transform one word into another word,<li>not allowed to transform a word into a non-word.<li>The word ladder puzzle was invented in 1878 by Lewis Carroll, the author of Alice in Wonderland.<li>The following sequence of words shows one possible solution to the problem posed above.</ul><div class="language-plaintext highlighter-rouge"><div class="code-header" text-data="plaintext"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>FOOL
POOL
POLL
POLE
PALE
SALE
SAGE
</pre></table></code></div></div><p>we can solve this problem using a graph algorithm.</p><ul><li>Represent the relationships between the words as a graph.<li>Use the graph algorithm known as breadth first search to find an efficient path from the starting word to the ending word.</ul><h4 id="implement">implement</h4><p><img data-proofer-ignore data-src="https://i.imgur.com/RP4hnkM.png" alt="wordgraph" /></p><ul><li>have an edge from one word to another if the two words are only different by a single letter.<li>If we can create such a graph, then any path from one word to another is a solution to the word ladder puzzle.</ul><p>could use several different approaches to create the graph</p><ul><li>start with the assumption that we have a list of words that are all the same length.<li>create a vertex in the graph for every word in the list.<li>to connect the words,<ul><li>compare each word in the list with every other.<ul><li>see how many letters are different.<li>If different by only one letter, create an edge between them</ul><li>For a small set of words that approach would work fine;<ul><li>however let’s suppose we have a list of 5,110 words.<li>Roughly speaking, comparing one word to every other word on the list is an <code class="language-plaintext highlighter-rouge">𝑂(𝑛^2)</code> algorithm.<li>For 5,110 words, <code class="language-plaintext highlighter-rouge">𝑛^2</code> is more than 26 million comparisons.</ul><li>We can do much better by using the following approach.<ul><li>Suppose that we have a huge number of buckets, each of them with a four-letter word on the outside, except that one of the letters in the label has been replaced by an underscore.<li>For example<li>have a bucket labeled “pop_.”<li>As we process each word in our list we compare the word with each bucket, using the ‘<em>’ as a wildcard, so both “pope” and “pops” would match “pop</em>.”<li>Every time we find a matching bucket, we put our word in that bucket.<li><p>Once we have all the words in the appropriate buckets we know that all the words in the bucket must be connected.</p><li>implement the scheme by dictionary.<ul><li>The labels on the buckets are the keys in dictionary.<li>The value stored for that key is a list of words.<li>Once we have the dictionary built we can create the graph.<li>We start our graph by<ul><li>creating a vertex for each word in the graph.<li>create edges between all the vertices under the same key in the dictionary.</ul></ul></ul></ul></ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">pythonds.graphs</span> <span class="kn">import</span> <span class="n">Graph</span>

<span class="k">def</span> <span class="nf">buildGraph</span><span class="p">(</span><span class="n">wordFile</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="nc">Graph</span><span class="p">()</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># create buckets of words that differ by one letter
</span>    <span class="n">wfile</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">wordFile</span><span class="p">,</span><span class="s">'r'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">wfile</span><span class="p">:</span>
        <span class="n">word</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="n">word</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s">'_'</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">bucket</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">bucket</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span><span class="p">]</span>

    <span class="c1"># add vertices and edges for words in the same bucket
</span>    <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="n">d</span><span class="p">.</span><span class="nf">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">word1</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">bucket</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">word2</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">bucket</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">word1</span> <span class="o">!=</span> <span class="n">word2</span><span class="p">:</span>
                    <span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="n">word1</span><span class="p">,</span><span class="n">word2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span>
</pre></table></code></div></div><p>how sparse is the graph?</p><ul><li>The list of four-letter words we have for this problem is 5,110 words long.<li><strong>adjacency matrix</strong>,<ul><li>the matrix would have <code class="language-plaintext highlighter-rouge">5,110 * 5,110 = 26,112,100 cells</code>.</ul><li><strong>adjacency list</strong>,<ul><li>The graph constructed by the buildGraph function has exactly <code class="language-plaintext highlighter-rouge">53,286 edges</code>,<li>only 0.20% of the cells filled!<li>That is a very sparse matrix indeed.</ul></ul><hr /><h4 id="implement-breadth-first-search-bfs">Implement: Breadth First Search (BFS)</h4><p>find the shortest solution to the word ladder problem.</p><ul><li>use the graph algorithm “breadth first search” algorithm.</ul><p><strong>Breadth first search (BFS)</strong></p><ul><li>one of the easiest algorithms for searching a graph.<li>It also serves as a prototype for several other important graph algorithms that we will study later.</ul><p>Algorithm using Depth First Search</p><ul><li>Step 1: Create a temporary stack.<li>Step 2: Recursively call topological sorting for all its adjacent vertices, then push it to the stack (when all adjacent vertices are on stack). Note this step is same as Depth First Search in a recursive way.<li>Step 3: Atlast, print contents of stack.<li>Note: A vertex is pushed to stack only when all of its adjacent vertices (and their adjacent vertices and so on) are already in stack.</ul><p>Given a graph <code class="language-plaintext highlighter-rouge">𝐺</code> and a starting vertex <code class="language-plaintext highlighter-rouge">𝑠</code>,</p><ul><li>a breadth first search proceeds by <code class="language-plaintext highlighter-rouge">exploring edges in the graph</code> to <code class="language-plaintext highlighter-rouge">find all the vertices in 𝐺 for which there is a path from 𝑠</code>.<li>The remarkable thing about a breadth first search is that it finds all the vertices that are a <code class="language-plaintext highlighter-rouge">distance 𝑘</code> from 𝑠 before it finds any vertices that are a <code class="language-plaintext highlighter-rouge">distance 𝑘+1</code>.<li>One good way to visualize what the breadth first search algorithm does is to imagine that it is building a tree, one level of the tree at a time. A breadth first search adds all children of the starting vertex before it begins to discover any of the grandchildren.</ul><p>The breadth first search algorithm</p><ul><li>uses the adjacency list graph representation<li>uses a Queue to decide which vertex to explore next.</ul><p>In addition the <code class="language-plaintext highlighter-rouge">BFS</code> algorithm uses an extended version of the <code class="language-plaintext highlighter-rouge">Vertex</code> class.</p><ul><li>This new vertex class adds three new instance variables: distance, predecessor, and color.<li>Each of these instance variables also has the appropriate getter and setter methods.<li>The code for this expanded Vertex class is included in the pythonds package</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">pythonds.graphs</span> <span class="kn">import</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">Vertex</span>
<span class="kn">from</span> <span class="n">pythonds.basic</span> <span class="kn">import</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
  <span class="n">start</span><span class="p">.</span><span class="nf">setDistance</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">start</span><span class="p">.</span><span class="nf">setPred</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
  <span class="n">vertQueue</span> <span class="o">=</span> <span class="nc">Queue</span><span class="p">()</span>
  <span class="n">vertQueue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
  <span class="nf">while </span><span class="p">(</span><span class="n">vertQueue</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">currentVert</span> <span class="o">=</span> <span class="n">vertQueue</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">currentVert</span><span class="p">.</span><span class="nf">getConnections</span><span class="p">():</span>
      <span class="nf">if </span><span class="p">(</span><span class="n">nbr</span><span class="p">.</span><span class="nf">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">'white'</span><span class="p">):</span>
        <span class="n">nbr</span><span class="p">.</span><span class="nf">setColor</span><span class="p">(</span><span class="s">'gray'</span><span class="p">)</span>
        <span class="n">nbr</span><span class="p">.</span><span class="nf">setDistance</span><span class="p">(</span><span class="n">currentVert</span><span class="p">.</span><span class="nf">getDistance</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">nbr</span><span class="p">.</span><span class="nf">setPred</span><span class="p">(</span><span class="n">currentVert</span><span class="p">)</span>
        <span class="n">vertQueue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">nbr</span><span class="p">)</span>
    <span class="n">currentVert</span><span class="p">.</span><span class="nf">setColor</span><span class="p">(</span><span class="s">'black'</span><span class="p">)</span>
</pre></table></code></div></div><p>BFS begins at the <code class="language-plaintext highlighter-rouge">starting vertex s</code> and colors start gray to show that it is currently being explored.</p><ul><li>Two other values, the distance and the predecessor, are initialized to 0 and None respectively for the starting vertex.<li>Finally, start is placed on a Queue.<li>The next step is to begin to systematically explore vertices at the front of the queue.<li>We explore each new node at the front of the queue by iterating over its adjacency list.<li>As each node on the adjacency list is examined its color is checked.<li>If it is white, the vertex is unexplored, and four things happen:<ul><li>The new, unexplored vertex <code class="language-plaintext highlighter-rouge">nbr</code>, is colored gray.<li>The predecessor of <code class="language-plaintext highlighter-rouge">nbr</code> is set to the current node <code class="language-plaintext highlighter-rouge">currentVert</code><li>The distance to <code class="language-plaintext highlighter-rouge">nbr</code> is set to the distance to currentVert + 1<li><code class="language-plaintext highlighter-rouge">nbr</code> is added to the end of a queue.<ul><li>Adding nbr to the end of the queue effectively schedules this node for further exploration, but not until all the other vertices on the adjacency list of currentVert have been explored.</ul></ul></ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>
<span class="kn">from</span> <span class="n">pythonds.graphs</span> <span class="kn">import</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">Vertex</span>
<span class="kn">from</span> <span class="n">pythonds.basic</span> <span class="kn">import</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">start</span><span class="p">):</span>
  <span class="n">start</span><span class="p">.</span><span class="nf">setDistance</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">start</span><span class="p">.</span><span class="nf">setPred</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
  <span class="n">vertQueue</span> <span class="o">=</span> <span class="nc">Queue</span><span class="p">()</span>
  <span class="n">vertQueue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

  <span class="nf">while </span><span class="p">(</span><span class="n">vertQueue</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
    <span class="c1"># if not empty
</span>    <span class="n">currentVert</span> <span class="o">=</span> <span class="n">vertQueue</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
    <span class="c1"># for every child
</span>    <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">currentVert</span><span class="p">.</span><span class="nf">getConnections</span><span class="p">():</span>
      <span class="c1"># if its not been seen
</span>      <span class="nf">if </span><span class="p">(</span><span class="n">nbr</span><span class="p">.</span><span class="nf">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">'white'</span><span class="p">):</span>
        <span class="c1"># action
</span>        <span class="n">nbr</span><span class="p">.</span><span class="nf">setColor</span><span class="p">(</span><span class="s">'gray'</span><span class="p">)</span>
        <span class="n">nbr</span><span class="p">.</span><span class="nf">setDistance</span><span class="p">(</span><span class="n">currentVert</span><span class="p">.</span><span class="nf">getDistance</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">nbr</span><span class="p">.</span><span class="nf">setPred</span><span class="p">(</span><span class="n">currentVert</span><span class="p">)</span>
        <span class="n">vertQueue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">nbr</span><span class="p">)</span>
    <span class="n">currentVert</span><span class="p">.</span><span class="nf">setColor</span><span class="p">(</span><span class="s">'black'</span><span class="p">)</span>
</pre></table></code></div></div><p>Step:</p><ol><li>Starting from fool we take all nodes that are adjacent to <code class="language-plaintext highlighter-rouge">fool</code> and add them to the tree.<ol><li>The adjacent nodes include <code class="language-plaintext highlighter-rouge">pool, foil, foul, and cool</code>.<li>Each of these nodes are <code class="language-plaintext highlighter-rouge">added to the queue</code> of new nodes to expand.</ol></ol><p><img data-proofer-ignore data-src="https://i.imgur.com/ng1c9hz.png" alt="bfs1" /></p><ol><li>bfs removes the next node (<code class="language-plaintext highlighter-rouge">pool</code>) from the front of the queue and repeats the process for all of its adjacent nodes.<ol><li>when bfs examines the node <code class="language-plaintext highlighter-rouge">cool</code>, it finds that the color is gray.<li>This indicates that there is a shorter path to <code class="language-plaintext highlighter-rouge">cool</code> and that <code class="language-plaintext highlighter-rouge">cool</code> is already on the queue for further expansion.<li>The only new node added to the queue while examining pool is <code class="language-plaintext highlighter-rouge">poll</code>.</ol></ol><p><img data-proofer-ignore data-src="https://i.imgur.com/WNyKkmn.png" alt="bfs2" /></p><ol><li>The next vertex on the queue is <code class="language-plaintext highlighter-rouge">foil</code>.<ol><li>The only new node that foil can add to the tree is fail.<li>As bfs continues to process the queue, neither of the next two nodes add anything new to the queue or the tree.</ol></ol><p><img data-proofer-ignore data-src="https://i.imgur.com/F3o8pjA.png" alt="bfs3" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/3uB8B6K.png" alt="bfsDone" /></p><p>You should continue to work through the algorithm on your own so that you are comfortable with how it works. Figure 6 shows the final breadth first search tree after all the vertices in Figure 3 have been expanded.</p><p>The amazing thing about the breadth first search solution is</p><ul><li>not only solved the <code class="language-plaintext highlighter-rouge">FOOL–SAGE</code> problem, but we have solved many other problems along the way.<li>We can start at any vertex in the breadth first search tree and follow the <code class="language-plaintext highlighter-rouge">predecessor</code> arrows back to the root to find the shortest word ladder from any word back to fool.</ul><p>To follow the predecessor links to print out the word ladder.</p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
    <span class="nf">while </span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nf">getPred</span><span class="p">()):</span>
      <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nf">getId</span><span class="p">())</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">getPred</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nf">getId</span><span class="p">())</span>

<span class="nf">traverse</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="nf">getVertex</span><span class="p">(</span><span class="s">'sage'</span><span class="p">))</span>
</pre></table></code></div></div><hr /><h4 id="analysis">Analysis</h4><ul><li>the <strong>while</strong> loop is executed, at most one time for each vertex in the graph <code class="language-plaintext highlighter-rouge">|𝑉|</code>.<ul><li>a vertex must be white before it can be examined and added to the queue.<li>This gives us <code class="language-plaintext highlighter-rouge">𝑂(𝑉)</code> for the while loop.</ul><li>The <strong>for</strong> loop is executed at most once for each edge in the graph, <code class="language-plaintext highlighter-rouge">|𝐸|</code>.<ul><li>every vertex is dequeued at most once and we examine an edge from <code class="language-plaintext highlighter-rouge">node 𝑢 to node 𝑣</code> only when <code class="language-plaintext highlighter-rouge">node 𝑢</code> is dequeued.<li>This gives us <code class="language-plaintext highlighter-rouge">𝑂(𝐸)</code> for the for loop.</ul><li>combining the two loops gives us <code class="language-plaintext highlighter-rouge">𝑂(𝑉+𝐸)</code>.</ul><p>Of course doing the breadth first search is only part of the task. Following the links from the starting node to the goal node is the other part of the task. \</p><ul><li>The worst case for this would be if the graph was a single long chain. In this case traversing through all of the vertices would be <code class="language-plaintext highlighter-rouge">𝑂(𝑉)</code>. The normal case is going to be some fraction of <code class="language-plaintext highlighter-rouge">|𝑉|</code> but we would still write <code class="language-plaintext highlighter-rouge">𝑂(𝑉)</code>.</ul><hr /><h3 id="the-knights-tour-problem">The Knight’s Tour Problem</h3><p>The knight’s tour puzzle is played on a chess board with a single chess piece, the knight.</p><ul><li>find a sequence of moves that allow the knight to visit every square on the board exactly once.<li>One such sequence is called a “tour.”<ul><li>The knight’s tour puzzle has fascinated chess players, mathematicians and computer scientists alike for many years.</ul><li>The upper bound on the number of possible legal tours for an eight-by-eight chessboard is known to be <code class="language-plaintext highlighter-rouge">1.305×1035</code>;<li>however, there are even more possible dead ends.<li>Clearly this is a problem that requires some real brains, some real computing power, or both.</ul><p>Although researchers have studied many different algorithms to solve the knight’s tour problem, a graph search is one of the easiest to understand and program.</p><h4 id="implement-1">Implement</h4><p>solve the problem using two main steps:</p><ol><li>Represent the legal moves of a knight on a chessboard as a graph.<li>Use a graph algorithm to find a path of length <code class="language-plaintext highlighter-rouge">𝑟𝑜𝑤𝑠×𝑐𝑜𝑙𝑢𝑚𝑛𝑠 −1</code> where every vertex on the graph is visited exactly once.</ol><p>following two ideas:</p><ul><li>Each square on the chessboard can be represented as a node in the graph.<li>Each legal move by the knight can be represented as an edge in the graph.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/o2FDXPW.png" alt="knightmoves" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/W3Jsj81.png" alt="bigknight" /></p><ul><li>the complete graph of possible moves on an eight-by-eight board.<li>There are exactly 336 edges in the graph.<li>the vertices corresponding to the edges of the board have fewer connections (legal moves) than the vertices in the middle of the board.<li>Once again we can see how sparse the graph is.<ul><li>If the graph was fully connected there would be 4,096 edges.<li>Since there are only 336 edges,<li>the adjacency matrix would be only 8.2 percent full.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/CJOMY7B.png" alt="completeTour" /></p><ul><li>what a complete tour around an eight-by-eight board looks like.<li>There are many possible tours; some are symmetric.<li>With some modification you can make circular tours that start and end at the same square.</ul><p>Build the full graph for an n-by-n board</p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">pythonds.graphs</span> <span class="kn">import</span> <span class="n">Graph</span>


<span class="c1"># The knightGraph function makes one pass over the entire board.
</span><span class="k">def</span> <span class="nf">knightGraph</span><span class="p">(</span><span class="n">bdSize</span><span class="p">):</span>
    <span class="n">ktGraph</span> <span class="o">=</span> <span class="nc">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">bdSize</span><span class="p">):</span>
       <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">bdSize</span><span class="p">):</span>
          <span class="c1"># At each square on the board the knightGraph function calls a helper, genLegalMoves,
</span>          <span class="c1"># to create a list of legal moves for that position on the board.
</span>          <span class="c1"># # All legal moves are then converted into edges in the graph.
</span>          <span class="n">newPositions</span> <span class="o">=</span> <span class="nf">genLegalMoves</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">,</span><span class="n">bdSize</span><span class="p">)</span>
          <span class="n">nodeId</span> <span class="o">=</span> <span class="nf">posToNodeId</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">,</span><span class="n">bdSize</span><span class="p">)</span>
          <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">newPositions</span><span class="p">:</span>
            <span class="n">nid</span> <span class="o">=</span> <span class="nf">posToNodeId</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">bdSize</span><span class="p">)</span>
            <span class="n">ktGraph</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="n">nodeId</span><span class="p">,</span><span class="n">nid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ktGraph</span>

<span class="c1"># Another helper function posToNodeId converts a location on the board in terms of a row and a column into a linear vertex number similar to the vertex numbers
</span><span class="k">def</span> <span class="nf">posToNodeId</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">board_size</span><span class="p">):</span>
    <span class="nf">return </span><span class="p">(</span><span class="n">row</span> <span class="o">*</span> <span class="n">board_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">column</span>


<span class="c1"># The genLegalMoves takes the position of the knight on the board and generates each of the eight possible moves.
</span><span class="k">def</span> <span class="nf">genLegalMoves</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">bdSize</span><span class="p">):</span>
    <span class="n">newMoves</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">moveOffsets</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
                   <span class="p">(</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span> <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span> <span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">moveOffsets</span><span class="p">:</span>
        <span class="n">newX</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">newY</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nf">legalCoord</span><span class="p">(</span><span class="n">newX</span><span class="p">,</span><span class="n">bdSize</span><span class="p">)</span> <span class="ow">and</span> <span class="nf">legalCoord</span><span class="p">(</span><span class="n">newY</span><span class="p">,</span><span class="n">bdSize</span><span class="p">):</span>
            <span class="n">newMoves</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">newX</span><span class="p">,</span><span class="n">newY</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">newMoves</span>

<span class="c1"># The legalCoord helper function makes sure that a particular move that is generated is still on the board.
</span><span class="k">def</span> <span class="nf">legalCoord</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">bdSize</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">bdSize</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
</pre></table></code></div></div><hr /><h4 id="implement-depth-first-search-dfs">Implement: Depth first search (DFS)</h4><ul><li>breadth first search algorithm on builds a search tree <code class="language-plaintext highlighter-rouge">one level at a time</code>,<li>depth first search creates a search tree by <code class="language-plaintext highlighter-rouge">exploring one branch of the tree as deeply as possible</code>.</ul><p>The depth first exploration of the graph is exactly what we need in order to find <code class="language-plaintext highlighter-rouge">a path that has exactly 63 edges</code>.</p><ul><li>We will see that when the depth first search algorithm finds a dead end (a place in the graph where there are no more moves possible) it backs up the tree to the next deepest vertex that allows it to make a legal move.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">pythonds.graphs</span> <span class="kn">import</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">Vertex</span>

<span class="k">def</span> <span class="nf">knightTour</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">limit</span><span class="p">):</span>
  <span class="c1"># n, the current depth in the search tree; the path goal
</span>  <span class="c1"># path, a list of vertices visited up to this point;
</span>  <span class="c1"># u, the vertex in the graph we wish to explore;
</span>  <span class="c1"># limit the number of nodes in the path.
</span>  <span class="n">u</span><span class="p">.</span><span class="nf">setColor</span><span class="p">(</span><span class="s">'gray'</span><span class="p">)</span>
  <span class="n">path</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

  <span class="c1"># checks the base case condition.
</span>  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>

   <span class="c1"># If the path is not long enough
</span>   <span class="c1"># continue to explore one level deeper by choosing a new vertex to explore
</span>   <span class="c1"># and calling knightTour recursively for that vertex.
</span>    <span class="n">nbrList</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="nf">getConnections</span><span class="p">())</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">done</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">nbrList</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
      <span class="c1"># DFS also uses colors to keep track of which vertices in the graph have been visited.
</span>      <span class="c1"># Unvisited vertices are colored white,
</span>      <span class="c1"># visited vertices are colored gray.
</span>      <span class="k">if</span> <span class="n">nbrList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">'white'</span><span class="p">:</span>
        <span class="n">done</span> <span class="o">=</span> <span class="nf">knightTour</span><span class="p">(</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">nbrList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">limit</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># backtrack
</span>    <span class="c1"># If all neighbors of a particular vertex have been explored and we have not yet reached our goal length of 64 vertices, we have reached a dead end.
</span>    <span class="c1"># When we reach a dead end we must backtrack.
</span>    <span class="c1"># Backtracking happens when we return from knightTour with a status of False.
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
      <span class="n">path</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
      <span class="n">u</span><span class="p">.</span><span class="nf">setColor</span><span class="p">(</span><span class="s">'white'</span><span class="p">)</span>

  <span class="c1"># If we have a path that contains 64 vertices
</span>  <span class="c1"># return from knightTour with a status of True,
</span>  <span class="c1"># indicating that we have found a successful tour.
</span>  <span class="k">else</span><span class="p">:</span>
      <span class="n">done</span> <span class="o">=</span> <span class="bp">True</span>
  <span class="k">return</span> <span class="n">done</span>
</pre></table></code></div></div><p>simple example of knightTour in action.</p><ul><li>assume that the call to the <code class="language-plaintext highlighter-rouge">getConnections</code> method on line 6 orders the nodes in alphabetical order.<li>We begin by calling <code class="language-plaintext highlighter-rouge">knightTour(0,path,A,6)</code></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/0Ui4D1e.png" alt="ktdfsa" /></p><p>knightTour starts with node A</p><ul><li>The nodes adjacent to A are B and D.<li>Since B is before D alphabetically, DFS selects B to expand next</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/3lhawAO.png" alt="ktdfsb" /></p><p>Exploring B happens when knightTour is called recursively.</p><ul><li>B is adjacent to C and D, so knightTour elects to explore C next.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/uDojFrz.png" alt="ktdfsc" /></p><ul><li>However, node C is a dead end with no adjacent white nodes.<li>At this point we change the color of node C back to white.<li>The call to knightTour returns a value of False.<li>The return from the recursive call effectively backtracks the search to vertex B</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/aI21qur.png" alt="ktdfsd" /></p><p>The next vertex on the list to explore is vertex D</p><ul><li>knightTour makes a recursive call moving to node D<li>From vertex D on, knightTour can continue to make recursive calls until we get to node C again</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/NKnr5mg.png" alt="ktdfse" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/H1Mr2dm.png" alt="ktdfsf" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/y28CdIE.png" alt="ktdfsg" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/KdGSCjm.png" alt="ktdfsh" /></p><p>However, this time when we get to node C the test <code class="language-plaintext highlighter-rouge">n &lt; limit</code> fails</p><ul><li>so we know that we have exhausted all the nodes in the graph.<li>At this point we can return True to indicate that we have made a successful tour of the graph.<li>When we return the list, path has the values [A,B,D,E,F,C], which is the order we need to traverse the graph to visit each node exactly once.</ul><hr /><h4 id="analysis-1">Analysis</h4><p>knightTour is very sensitive to the method used to select the next vertex to visit.</p><ul><li>For example<ul><li>a five-by-five board you can produce a path in about 1.5 seconds on a reasonably fast computer.<li>But for an eight-by-eight board<ul><li>depending on the speed of your computer, you may have to wait up to a half hour to get the results!</ul></ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/RJbTVIq.png" alt="8arrayTree" /></p><p>The reason for this is that the knight’s tour problem as we have implemented is an exponential algorithm of size <code class="language-plaintext highlighter-rouge">𝑂(𝑘^𝑁)</code>,</p><ul><li>where <code class="language-plaintext highlighter-rouge">N</code> is the number of squares on the chess board, and <code class="language-plaintext highlighter-rouge">k</code> is a small constant.<li>The root of the tree represents the starting point of the search.<li>From there the algorithm generates and checks each of the possible moves the knight can make.<li>the number of moves possible depends on the position of the knight on the board.<li>In the corners there are only two legal moves, on the squares adjacent to the corners there are three and in the middle of the board there are eight.<li>the number of moves possible for each position on a board.<li><img data-proofer-ignore data-src="https://i.imgur.com/MgzeHbB.png" alt="moveCount" /><li>At the next level of the tree there are once again between 2 and 8 possible next moves from the position we are currently exploring.<li><code class="language-plaintext highlighter-rouge">The number of possible positions to examine</code> corresponds to <code class="language-plaintext highlighter-rouge">the number of nodes in the search tree</code>.</ul><p>the number of nodes</p><ul><li>the number of nodes in a binary tree of height <code class="language-plaintext highlighter-rouge">N</code> is <code class="language-plaintext highlighter-rouge">2^(𝑁+1)−1</code>.<li>For a tree with nodes that may have up to eight children instead of two the number of nodes is much larger.<ul><li>Because the branching factor of each node is variable,<li>estimate the number of nodes using an average branching factor.</ul><li>this algorithm is exponential: <code class="language-plaintext highlighter-rouge">𝑘^(𝑁+1)−1</code>,<ul><li>where 𝑘 is the average branching factor for the board.<li>how rapidly this grows!<li>For a board that is 5x5<ul><li>the tree will be 25 levels deep,<li>or N = 24 counting the first level as level 0.<li>The average branching factor is <code class="language-plaintext highlighter-rouge">𝑘=3.8</code> So the <code class="language-plaintext highlighter-rouge">number of nodes</code> in the search tree is <code class="language-plaintext highlighter-rouge">3.8^25−1</code> or <code class="language-plaintext highlighter-rouge">3.12×10^14</code>.</ul><li>For a 6x6 board, 𝑘=4.4, there are <code class="language-plaintext highlighter-rouge">1.5×10^23</code> nodes,<li>for a 8x8 chess board, 𝑘=5.25, there are <code class="language-plaintext highlighter-rouge">1.3×10^46</code>.</ul><li>Of course, since there are multiple solutions to the problem we won’t have to explore every single node, but the fractional part of the nodes we do have to explore is just a constant multiplier which does not change the exponential nature of the problem.</ul><hr /><h4 id="improve-heuristic-search-warnsdorffs-algorithm">Improve: heuristic search: Warnsdorff’s algorithm</h4><p>Luckily there is a way to speed up the eight-by-eight case so that it runs in under one second.</p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1"># In the listing below we show the code that speeds up the knightTour. This function will be used in place of the call to u.getConnections in the code previously shown above.
</span><span class="k">def</span> <span class="nf">orderByAvail</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">resList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">n</span><span class="p">.</span><span class="nf">getConnections</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="nf">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">'white'</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">v</span><span class="p">.</span><span class="nf">getConnections</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">w</span><span class="p">.</span><span class="nf">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">'white'</span><span class="p">:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">resList</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
    <span class="n">resList</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">resList</span><span class="p">]</span>
</pre></table></code></div></div><p>The critical line ensures that we select the vertex to go next that has the fewest available moves.</p><ul><li>why not select the node that has the most available moves? You can try that approach easily by running the program yourself and inserting the line <code class="language-plaintext highlighter-rouge">resList.reverse()</code> right after the sort.</ul><p>The problem with using the vertex with the most available moves as your next vertex on the path is that</p><ul><li>it tends to have the knight visit the middle squares early on in the tour.<li><p>When this happens it is easy for the knight to get stranded on one side of the board where it cannot reach unvisited squares on the other side of the board.</p><li>On the other hand, visiting the squares with the fewest available moves <code class="language-plaintext highlighter-rouge">first pushes the knight to visit the squares around the edges of the board first</code>. This ensures that the knight will visit the hard-to-reach corners early and can use the middle squares to hop across the board only when necessary.<li>Utilizing this kind of knowledge to speed up an algorithm is called a <strong>heuristic</strong> 启发式</ul><p><strong>heuristic</strong> 启发式</p><ul><li>Humans use heuristics every day to help make decisions,<li><strong>heuristic searches</strong> are often used in the field of artificial intelligence.<li>This particular heuristic is called <strong>Warnsdorff’s algorithm</strong>, named after H. C. Warnsdorff who published his idea in 1823.</ul><hr /><h1 id="graph-algorithms">Graph Algorithms</h1><p><img data-proofer-ignore data-src="https://i.imgur.com/MyxxXeS.gif" alt="dfsbfs" /></p><p>BFS notes:</p><ul><li>level order (BFS, using queue)<li>time complexity: O(n)<li>space complexity:<ul><li>best: O(1),<li>worst: O(n/2)=O(n)</ul></ul><p>DFS notes:</p><ul><li>time complexity: O(n)<li>space complexity:<ul><li>best: O(log n) - avg. height of tree<li>worst: O(n)</ul><li>inorder (DFS: left, self, right)<li>postorder (DFS: left, right, self)<li>preorder (DFS: self, left, right)</ul><hr /><h2 id="breadth-first-search-ov--e">Breadth First Search <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></h2><p>Breadth First Search</p><ul><li>a graph traversal algorithm which explores the neighbor nodes first, before moving to the next level neighbors</ul><p>Time Complexity: <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></p><hr /><h2 id="depth-first-search-ov--e">Depth First Search <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></h2><blockquote><p>The knight’s tour is a special case of a depth first search where the goal is to create the deepest depth first tree, without any branches.</p></blockquote><p>The more general depth first search is actually easier.</p><ul><li>Its goal is to search as deeply as possible, connecting as many nodes in the graph as possible and branching where necessary.</ul><p>Depth First Search</p><ul><li>a graph traversal algorithm<li>which explores as far as possible along each branch before backtracking</ul><p>Time Complexity: <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></p><p><strong>depth first forest</strong></p><ul><li>It is even possible that a depth first search will create more than one tree.<li>When the depth first search algorithm creates a group of trees we call this a <strong>depth first forest</strong></ul><p><strong>depth first search</strong></p><ul><li>As with the breadth first search, depth first search makes use of predecessor 前任 links to construct the tree.<li>In addition, the depth first search will make use of two additional instance variables in the Vertex class.<li>The new instance variables are the <code class="language-plaintext highlighter-rouge">discovery and finish times</code>.<ul><li>The <code class="language-plaintext highlighter-rouge">discovery time</code> tracks the number of steps in the algorithm before a vertex is first encountered.<li>The <code class="language-plaintext highlighter-rouge">finish time</code> is the number of steps in the algorithm before a vertex is colored black.<li>As we will see after looking at the algorithm, the discovery and finish times of the nodes provide some interesting properties we can use in later algorithms.</ul></ul><p>The code for our depth first search is shown in Listing 5. Since the two functions dfs and its helper dfsvisit use a variable to keep track of the time across calls to dfsvisit we chose to implement the code as methods of a class that inherits from the Graph class.</p><ul><li>This implementation extends the graph class by adding a time instance variable and the two methods <code class="language-plaintext highlighter-rouge">dfs</code> and <code class="language-plaintext highlighter-rouge">dfsvisit</code>.<li>Looking at line 11 you will notice that the dfs method iterates over all of the vertices in the graph calling dfsvisit on the nodes that are white.<li>The reason we iterate over all the nodes, rather than simply searching from a chosen starting node, is to make sure that all nodes in the graph are considered and that no vertices are left out of the depth first forest.<li>It may look unusual to see the statement for aVertex in self, but remember that in this case self is an instance of the DFSGraph class, and iterating over all the vertices in an instance of a graph is a natural thing to do.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">pythonds.graphs</span> <span class="kn">import</span> <span class="n">Graph</span>
<span class="k">class</span> <span class="nc">DFSGraph</span><span class="p">(</span><span class="n">Graph</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># iterates over all of the vertices in the graph
</span>        <span class="c1"># calling dfsvisit on the nodes that are white.
</span>        <span class="k">for</span> <span class="n">aVertex</span> <span class="ow">in</span> <span class="n">self</span><span class="p">:</span>
            <span class="n">aVertex</span><span class="p">.</span><span class="nf">setColor</span><span class="p">(</span><span class="s">'white'</span><span class="p">)</span>
            <span class="n">aVertex</span><span class="p">.</span><span class="nf">setPred</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">aVertex</span> <span class="ow">in</span> <span class="n">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">aVertex</span><span class="p">.</span><span class="nf">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">'white'</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="nf">dfsvisit</span><span class="p">(</span><span class="n">aVertex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dfsvisit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">startVertex</span><span class="p">):</span>
        <span class="n">startVertex</span><span class="p">.</span><span class="nf">setColor</span><span class="p">(</span><span class="s">'gray'</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">time</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">startVertex</span><span class="p">.</span><span class="nf">setDiscovery</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">time</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nextVertex</span> <span class="ow">in</span> <span class="n">startVertex</span><span class="p">.</span><span class="nf">getConnections</span><span class="p">():</span>
          <span class="c1"># explores all of the neighboring white vertices as deeply as possible.
</span>          <span class="k">if</span> <span class="n">nextVertex</span><span class="p">.</span><span class="nf">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">'white'</span><span class="p">:</span>
            <span class="n">nextVertex</span><span class="p">.</span><span class="nf">setPred</span><span class="p">(</span><span class="n">startVertex</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">dfsvisit</span><span class="p">(</span><span class="n">nextVertex</span><span class="p">)</span>
        <span class="n">startVertex</span><span class="p">.</span><span class="nf">setColor</span><span class="p">(</span><span class="s">'black'</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">time</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">startVertex</span><span class="p">.</span><span class="nf">setFinish</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">time</span><span class="p">)</span>
</pre></table></code></div></div><p>compare it to breadth first search</p><ul><li>the <code class="language-plaintext highlighter-rouge">dfsvisit</code> algorithm is almost identical to <code class="language-plaintext highlighter-rouge">bfs</code><li>except that on the last line of the <code class="language-plaintext highlighter-rouge">inner for loop</code>,<ul><li><code class="language-plaintext highlighter-rouge">dfsvisit</code> calls itself recursively to continue the search at a deeper level,<li>whereas <code class="language-plaintext highlighter-rouge">bfs</code> adds the node to a queue for later exploration.</ul><li><code class="language-plaintext highlighter-rouge">bfs</code> uses a queue, <code class="language-plaintext highlighter-rouge">dfsvisit</code> uses a stack.</ul><hr /><h3 id="example-1">example</h3><p>The following sequence of figures illustrates the <code class="language-plaintext highlighter-rouge">depth first search algorithm</code> in action for a small graph.</p><ul><li>In these figures, the dotted lines indicate edges that are checked, but the node at the other end of the edge has already been added to the depth first tree. In the code this test is done by checking that the color of the other node is non-white.</ul><ol><li>The search begins at vertex A of the graph<ul><li>Since all of the vertices are white at the beginning of the search the algorithm visits vertex A.<li>The first step in visiting a vertex is to set the color to gray, which indicates that the vertex is being explored and the discovery time is set to 1.<li>Since vertex A has two adjacent vertices (B, D) each of those need to be visited as well.<li>We’ll make the arbitrary decision that we will visit the adjacent vertices in alphabetical order.</ul></ol><p><img data-proofer-ignore data-src="https://i.imgur.com/Q4uH1Wt.png" alt="gendfsa" /></p><ol><li>Vertex B is visited next<ul><li>so its color is set to gray and its discovery time is set to 2.<li>Vertex B is also adjacent to two other nodes (C, D)<li>so we will follow the alphabetical order and visit node C next.</ul></ol><p><img data-proofer-ignore data-src="https://i.imgur.com/Qk8OVWl.png" alt="gendfsb" /></p><ol><li>Visiting vertex C<ul><li>brings us to the end of one branch of the tree.<li>After coloring the node gray and setting its discovery time to 3,<li>the algorithm also determines that there are no adjacent vertices to C.<li>This means that we are done exploring node C and so we can color the vertex black, and set the finish time to 4.</ul></ol><p><img data-proofer-ignore data-src="https://i.imgur.com/M3abmXa.png" alt="gendfsc" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/p85WPUs.png" alt="gendfsd" /></p><ol><li>Since vertex C was the end of one branch we now return to vertex B and continue exploring the nodes adjacent to B.<ul><li>The only additional vertex to explore from B is D, so we can now visit D<li>and continue our search from vertex D.</ul></ol><p><img data-proofer-ignore data-src="https://i.imgur.com/aCAtbwd.png" alt="gendfse" /></p><ol><li>Vertex D quickly leads us to vertex E</ol><p><img data-proofer-ignore data-src="https://i.imgur.com/IJjQeqV.png" alt="gendfsf" /></p><ol><li>Vertex E has two adjacent vertices, B and F.<ul><li>explore these adjacent vertices alphabetically,<li>but since B is already colored gray<ul><li>the algorithm recognizes that it should not visit B since doing so would put the algorithm in a loop!</ul><li>So exploration continues with the next vertex in the list, namely F</ul></ol><p><img data-proofer-ignore data-src="https://i.imgur.com/zLVY4YV.png" alt="gendfsg" /></p><ol><li>Vertex F has only one adjacent vertex, C,<ul><li>but since C is colored black there is nothing else to explore, and the algorithm has reached the end of another branch.<li>From here on, the algorithm works its way back to the first node, setting finish times and coloring vertices black.</ul></ol><p><img data-proofer-ignore data-src="https://i.imgur.com/lwlOR2I.png" alt="gendfsh" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/FOPGjGL.png" alt="gendfsi" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/fpQYS1z.png" alt="gendfsj" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/Qvu9YNG.png" alt="gendfsk" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/UskzfBt.png" alt="gendfsl" /></p><p>The starting and finishing times for each node display a property called the <strong>parenthesis property</strong>.</p><ul><li>This property means that all the children of a particular node in the depth first tree have a <code class="language-plaintext highlighter-rouge">later discovery time</code> and an <code class="language-plaintext highlighter-rouge">earlier finish time</code> than their parent.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/YGNm2lb.png" alt="dfstree" /></p><hr /><h3 id="depth-first-search-analysis">Depth First Search Analysis</h3><p>The general running time for depth first search is as follows.</p><ul><li>The loops in <code class="language-plaintext highlighter-rouge">dfs</code> both run in <code class="language-plaintext highlighter-rouge">𝑂(𝑉)</code>, not counting what happens in dfsvisit, since they are executed once for each vertex in the graph.<li>In <code class="language-plaintext highlighter-rouge">dfsvisit</code> the loop is executed once for each edge in the adjacency list of the current vertex.<ul><li>Since <code class="language-plaintext highlighter-rouge">dfsvisit</code> is only called recursively if the vertex is white, the loop will execute a maximum of once for every edge in the graph or <code class="language-plaintext highlighter-rouge">𝑂(𝐸)</code>.<li>So, the total time for depth first search is <code class="language-plaintext highlighter-rouge">𝑂(𝑉+𝐸)</code>.</ul></ul><hr /><h3 id="topological-sorting-using-depth-first-search-dfs">Topological Sorting using Depth First Search (DFS)</h3><p>To keep track of its progress,</p><ul><li>BFS colors each of the vertices white, gray, or black.<li>All the vertices are initialized to white when they are constructed. A white vertex is an undiscovered vertex.<li>When a vertex is initially discovered it is colored gray,<li>and when BFS has completely explored a vertex it is colored black.<li>This means that once a vertex is colored black, it has no white vertices adjacent to it.<li>A gray node may have some white vertices adjacent to it, indicating that there are still additional vertices to explore.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">pythonds.basic</span> <span class="kn">import</span> <span class="n">Stack</span>

<span class="k">def</span> <span class="nf">dfs_topo</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vertextargetid</span><span class="p">):</span>
    <span class="n">vertex_list</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">vertList</span>
    <span class="n">vertextarget</span> <span class="o">=</span> <span class="n">vertex_list</span><span class="p">[</span><span class="n">vertextargetid</span><span class="p">]</span>

    <span class="n">stack_list</span> <span class="o">=</span> <span class="nc">Stack</span><span class="p">()</span>
    <span class="n">stack_list</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">vertextarget</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="nc">Stack</span><span class="p">()</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">stack_list</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">():</span>
        <span class="n">currentVert</span> <span class="o">=</span> <span class="n">stack_list</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">currentVert</span><span class="p">.</span><span class="nf">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">'white'</span><span class="p">:</span>
            <span class="n">currentVert</span><span class="p">.</span><span class="nf">setColor</span><span class="p">(</span><span class="s">'grey'</span><span class="p">)</span>
            <span class="n">childVert</span> <span class="o">=</span> <span class="n">currentVert</span><span class="p">.</span><span class="nf">getConnections</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">vertexs</span> <span class="ow">in</span> <span class="n">childVert</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">vertexs</span><span class="p">.</span><span class="nf">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">'white'</span><span class="p">:</span>
                    <span class="n">stack_list</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">vertexs</span><span class="p">)</span>
        <span class="n">currentVert</span><span class="p">.</span><span class="nf">setColor</span><span class="p">(</span><span class="s">'black'</span><span class="p">)</span>
        <span class="n">output</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">currentVert</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="nf">size</span><span class="p">()):</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="nf">pop</span><span class="p">())</span>


<span class="n">g</span> <span class="o">=</span> <span class="nc">GraphyAL</span><span class="p">()</span>
<span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="s">'1'</span><span class="p">,</span> <span class="s">'2'</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="s">'2'</span><span class="p">,</span> <span class="s">'3'</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="s">'3'</span><span class="p">,</span> <span class="s">'4'</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="s">'4'</span><span class="p">,</span> <span class="s">'5'</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">addEdge</span><span class="p">(</span><span class="s">'5'</span><span class="p">,</span> <span class="s">'6'</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">print_list</span><span class="p">()</span>

<span class="nf">dfs_topo</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s">'1'</span><span class="p">)</span>
</pre></table></code></div></div><hr /><h2 id="topological-拓扑-sorting-ov--e">Topological 拓扑 Sorting <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></h2><blockquote><p>simple but useful adaptation of a depth first search.</p></blockquote><p><strong>Topological Sort</strong></p><ul><li>the <code class="language-plaintext highlighter-rouge">linear ordering</code> of a <strong>directed graph’s nodes</strong><ul><li>takes a <code class="language-plaintext highlighter-rouge">directed acyclic 无环的 graph</code><li>produces a <code class="language-plaintext highlighter-rouge">linear ordering</code> of all its vertices<li>直观地说就是，让你把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的<li>很显然，如果一幅有向图中存在环，是无法进行拓扑排序的，因为肯定做不到所有箭头方向一致；<li>反过来，如果一幅图是「有向无环图」，那么一定可以进行拓扑排序。</ul><li>such that for <code class="language-plaintext highlighter-rouge">every edge from node u to node v</code>, u comes before v in the ordering<ul><li>if the graph <code class="language-plaintext highlighter-rouge">𝐺</code> contains an edge <code class="language-plaintext highlighter-rouge">(𝑣,𝑤)</code><li>then the vertex <code class="language-plaintext highlighter-rouge">𝑣</code> comes before the vertex <code class="language-plaintext highlighter-rouge">𝑤</code> in the ordering.</ul><li><p>Time Complexity: <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code></p><li>Directed acyclic graphs are used in many applications to indicate the precedence of events.<ul><li>examples:<li>Making pancakes<li>software project schedules,<li>precedence charts for optimizing database queries,<li>and multiplying matrices.</ul></ul><h3 id="stirring-up-a-batch-of-pancakes">stirring up a batch of pancakes:</h3><p>stirring up a batch of pancakes.</p><ul><li>The recipe is really quite simple: 1 egg, 1 cup of pancake mix, 1 tablespoon oil, and 34 cup of milk.<li>To make pancakes you must heat the griddle, mix all the ingredients together and spoon the mix onto a hot griddle.<li>When the pancakes start to bubble you turn them over and let them cook until they are golden brown on the bottom.<li>Before you eat your pancakes you are going to want to heat up some syrup.<li>illustrates this process as a graph.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/giM1w90.png" alt="pancakes" /></p><p>To know what to do first.</p><ul><li>To help us decide the <code class="language-plaintext highlighter-rouge">precise order</code> in which we should do each of the steps required to make our pancakes<li>turn to a graph algorithm called the <strong>topological sort</strong> 拓扑</ul><p>The algorithm for the topological sort is as follows:</p><ul><li>Call <code class="language-plaintext highlighter-rouge">dfs(g)</code> for some graph <code class="language-plaintext highlighter-rouge">g</code>. The main reason we want to call depth first search is to <code class="language-plaintext highlighter-rouge">compute the finish times for each of the vertices</code>.<li>Store the vertices in a list in decreasing order of finish time.<li>Return the ordered list as the result of the topological sort.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/BeJBGp9.png" alt="pancakesDFS" /></p><p>the results of applying the topological sort algorithm to our graph.</p><ul><li>Now all the ambiguity has been removed and we know exactly the order in which to perform the pancake making steps.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/HrjaeMt.png" alt="pancakesTS" /></p><hr /><h2 id="strongly-connected-components">Strongly Connected Components</h2><p>the graphs produced by the connections between hosts on the Internet and the links between web pages.</p><h3 id="strongly-connected-components-algorithm-scc">strongly connected components algorithm (SCC)</h3><h4 id="for-web-pages">for web pages</h4><p>Search engines like Google and Bing exploit the fact that the pages on the web form a very large directed graph.</p><ul><li>To transform the World Wide Web into a graph, we will treat a page as a vertex, and the hyperlinks on the page as edges connecting one vertex to another.<li>very small part of the graph produced by following the links from one page to the next, beginning at Luther College’s Computer Science home page. Of course, this graph could be huge, so we have limited it to web sites that are no more than 10 links away from the CS home page.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/Xyf443q.png" alt="cshome" /></p><p><strong>strongly connected components algorithm (SCC)</strong></p><ul><li>help find clusters of highly interconnected vertices in a graph is called the <strong>strongly connected components algorithm (SCC)</strong>.<li>define a strongly connected component, <code class="language-plaintext highlighter-rouge">𝐶</code>, of a <code class="language-plaintext highlighter-rouge">graph 𝐺</code>,<ul><li>as the largest subset of vertices <code class="language-plaintext highlighter-rouge">𝐶⊂𝑉</code><li>such that for every pair of vertices <code class="language-plaintext highlighter-rouge">𝑣,𝑤∈𝐶</code> we have a path <code class="language-plaintext highlighter-rouge">from 𝑣 to 𝑤</code> and a <code class="language-plaintext highlighter-rouge">path from 𝑤 to 𝑣</code>.</ul><li>Figure 27 shows a simple graph with three strongly connected components. The strongly connected components are identified by the different shaded areas.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/DaOZ0lE.png" alt="scc1" /></p><p>Once the strongly connected components have been identified we can show a simplified view of the graph by combining all the vertices in one strongly connected component into a single larger vertex.</p><p>The simplified version of the graph:</p><p><img data-proofer-ignore data-src="https://i.imgur.com/BBcLtnj.png" alt="scc2" /></p><p>we can create a very powerful and efficient algorithm by making use of a <code class="language-plaintext highlighter-rouge">depth first search</code>.</p><ul><li>Before we tackle the main SCC algorithm we must look at one other definition.<ul><li>The transposition of a <code class="language-plaintext highlighter-rouge">graph 𝐺</code> is defined as the <code class="language-plaintext highlighter-rouge">graph 𝐺^𝑇</code> where all the edges in the graph have been <strong>reversed</strong>.</ul><li>That is, if there is a <code class="language-plaintext highlighter-rouge">directed edge from node A to node B</code> in the original graph then <code class="language-plaintext highlighter-rouge">𝐺^𝑇</code> will contain and <code class="language-plaintext highlighter-rouge">edge from node B to node A</code>.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/BOF6osb.png" alt="transpose1" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/sGxPJqh.png" alt="transpose2" /></p><ul><li>the <code class="language-plaintext highlighter-rouge">graph G</code> has two strongly connected components.<li>the <code class="language-plaintext highlighter-rouge">graph 𝐺^𝑇</code> has the same two strongly connected components.</ul><p>describe the algorithm to compute the strongly connected components for a graph.</p><ol><li>Call <code class="language-plaintext highlighter-rouge">dfs</code> for the graph <code class="language-plaintext highlighter-rouge">𝐺</code> to compute the finish times for each vertex.<li>Compute <code class="language-plaintext highlighter-rouge">𝐺^𝑇</code>.<li>Call dfs for the graph <code class="language-plaintext highlighter-rouge">𝐺^𝑇</code> but in the main loop of DFS explore each vertex in decreasing order of finish time.<li>Each tree in the forest computed in step 3 is a strongly connected component.<ul><li>Output the vertex ids for each vertex in each tree in the forest to identify the component.</ul></ol><hr /><h4 id="example-2">example</h4><p>Let’s trace the operation of the steps described above on the example graph</p><p>the starting and finishing times computed for the original graph by the DFS algorithm.</p><p><img data-proofer-ignore data-src="https://i.imgur.com/ygXzj3L.png" alt="scc1a" /></p><p>the starting and finishing times computed by running DFS on the transposed graph.</p><p><img data-proofer-ignore data-src="https://i.imgur.com/Najkbav.png" alt="scc1b" /></p><p>Finally, got the forest of three trees produced in step 3 of the strongly connected component algorithm.</p><p><img data-proofer-ignore data-src="https://i.imgur.com/tRzswuK.png" alt="sccforest" /></p><hr /><h3 id="shortest-path-problems">Shortest Path Problems</h3><h4 id="for-host">for host</h4><p>Each router on the Internet is connected to one or more other routers. So if you run the traceroute command at different times of the day, you are likely to see that your information flows through different routers at different times. This is because there is a cost associated with each connection between a pair of routers that depends on the volume of traffic, the time of day, and many other factors.</p><p>represent the network of routers as a graph with weighted edges.</p><p><img data-proofer-ignore data-src="https://i.imgur.com/7nviEFl.png" alt="routeGraph" /></p><hr /><h4 id="dijkstras-algorithm-ov2"><strong>Dijkstra’s Algorithm</strong> <code class="language-plaintext highlighter-rouge">O(|V|^2)</code></h4><p><img data-proofer-ignore data-src="https://i.imgur.com/JjWcLBD.gif" alt="dijkstra" /></p><p><strong>Dijkstra’s Algorithm</strong></p><ul><li>to determine the shortest path<li>an iterative algorithm that provides the shortest path from one particular starting node to all other nodes in the graph.<li>similar to the results of a breadth first search.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">pythonds.graphs</span> <span class="kn">import</span> <span class="n">PriorityQueue</span><span class="p">,</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">Vertex</span>

<span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">aGraph</span><span class="p">,</span><span class="n">start</span><span class="p">):</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="nc">PriorityQueue</span><span class="p">()</span>
    <span class="n">start</span><span class="p">.</span><span class="nf">setDistance</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pq</span><span class="p">.</span><span class="nf">buildHeap</span><span class="p">([(</span><span class="n">v</span><span class="p">.</span><span class="nf">getDistance</span><span class="p">(),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">aGraph</span><span class="p">])</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">pq</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">():</span>
        <span class="n">currentVert</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="nf">delMin</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">nextVert</span> <span class="ow">in</span> <span class="n">currentVert</span><span class="p">.</span><span class="nf">getConnections</span><span class="p">():</span>
            <span class="n">newDist</span> <span class="o">=</span> <span class="n">currentVert</span><span class="p">.</span><span class="nf">getDistance</span><span class="p">()</span> <span class="o">+</span> <span class="n">currentVert</span><span class="p">.</span><span class="nf">getWeight</span><span class="p">(</span><span class="n">nextVert</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">newDist</span> <span class="o">&lt;</span> <span class="n">nextVert</span><span class="p">.</span><span class="nf">getDistance</span><span class="p">():</span>
                <span class="n">nextVert</span><span class="p">.</span><span class="nf">setDistance</span><span class="p">(</span><span class="n">newDist</span><span class="p">)</span>
                <span class="n">nextVert</span><span class="p">.</span><span class="nf">setPred</span><span class="p">(</span><span class="n">currentVert</span><span class="p">)</span>
                <span class="n">pq</span><span class="p">.</span><span class="nf">decreaseKey</span><span class="p">(</span><span class="n">nextVert</span><span class="p">,</span><span class="n">newDist</span><span class="p">)</span>
</pre></table></code></div></div><p>To keep track of the total cost from the start node to each destination we will make use of the <code class="language-plaintext highlighter-rouge">dist instance variable</code> in the Vertex class.</p><ul><li>The <code class="language-plaintext highlighter-rouge">dist instance variable</code>: contain the <code class="language-plaintext highlighter-rouge">current total weight of the smallest weight path</code> from the start to the vertex in question.<li>The algorithm iterates once for every vertex in the graph; however, the order iterate over the vertices is controlled by a priority queue.<li>The value that is used to determine the order of the objects in the priority queue is <code class="language-plaintext highlighter-rouge">dist</code>.<ul><li>When a vertex is first created <code class="language-plaintext highlighter-rouge">dist</code> is set to a very large number. infinity</ul></ul><p>Dijkstra’s algorithm uses a priority queue.</p><ul><li>priority queue is based on the heap<li>There are a couple of differences between that simple implementation and the implementation we use for Dijkstra’s algorithm.</ul><p>step</p><ul><li>First, the PriorityQueue class stores tuples of <code class="language-plaintext highlighter-rouge">key, value</code> pairs.<ul><li>the <code class="language-plaintext highlighter-rouge">key</code> in the priority queue must match the key of the vertex in the graph.</ul><li>Secondly the <code class="language-plaintext highlighter-rouge">value</code> is used for deciding the priority, and thus the position of the key in the priority queue.<ul><li>In this implementation we <code class="language-plaintext highlighter-rouge">use the distance to the vertex</code> as the priority because as we will see when we are exploring the next vertex, we always want to explore the vertex that has the smallest distance.<li>The second difference is the addition of the decreaseKey method.<ul><li>used when the distance to a vertex that is already in the queue is reduced, and thus moves that vertex toward the front of the queue.</ul></ul></ul><ol><li>We begin with the vertex <code class="language-plaintext highlighter-rouge">𝑢</code>.<ul><li>The three vertices adjacent to 𝑢 are 𝑣, 𝑤, 𝑥.<li>the initial distances to 𝑣,𝑤,𝑥 are all initialized to <code class="language-plaintext highlighter-rouge">sys.maxint</code>,<li>the new <code class="language-plaintext highlighter-rouge">costs</code> to get to them through the start node are all their direct costs.<li>update the costs to each of these three nodes.<li>set the <code class="language-plaintext highlighter-rouge">predecessor</code> for each node to 𝑢 and we add each node to the priority queue.<li>We use the distance as the <code class="language-plaintext highlighter-rouge">key</code> for the priority queue.</ul></ol><p><img data-proofer-ignore data-src="https://i.imgur.com/gqmhXBs.png" alt="dijkstraa" /></p><ol><li>In the next iteration of the while loop, examine the vertices that are adjacent to 𝑥.<ul><li>The vertex 𝑥 is next because it <code class="language-plaintext highlighter-rouge">has the lowest overall cost and therefore bubbled its way</code> to the beginning of the priority queue.<li>its neighbors 𝑢,𝑣,𝑤 and 𝑦.<ul><li>For each neighboring vertex,<li>check if the distance to that vertex through 𝑥 is smaller than the previously known distance.</ul><li>this is the case for 𝑦 since its distance was <code class="language-plaintext highlighter-rouge">sys.maxint</code>.<li>It is not the case for 𝑢 or 𝑣 since their distances are 0 and 2 respectively.<li>However, we now learn that the distance to 𝑤 is smaller if we go through 𝑥 than from 𝑢 directly to 𝑤.<li>update 𝑤 with a new distance and change the predecessor for 𝑤 from 𝑢 to 𝑥.</ul></ol><p><img data-proofer-ignore data-src="https://i.imgur.com/OJldOzs.png" alt="dijkstrab" /></p><ol><li>The next step is to look at the vertices neighboring 𝑣<ul><li>This step results in no changes to the graph,</ul></ol><p><img data-proofer-ignore data-src="https://i.imgur.com/IjryDoY.png" alt="dijkstrac" /></p><ol><li>so we move on to node 𝑦.<ul><li>At node 𝑦 we discover that it is cheaper to get to both 𝑤 and 𝑧,<li>so we adjust the distances and predecessor links accordingly.</ul></ol><p><img data-proofer-ignore data-src="https://i.imgur.com/TUmB2KI.png" alt="dijkstrad" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/9XF6xxB.png" alt="dijkstrae" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/VHEu9MT.png" alt="dijkstraf" /></p><ol><li>Finally we check nodes 𝑤 and 𝑧<ul><li>However, no additional changes are found<li>so the priority queue is empty<li>and Dijkstra’s algorithm exits.</ul></ol><p>note that Dijkstra’s algorithm works only <code class="language-plaintext highlighter-rouge">when the weights are all positive</code>.</p><ul><li>You should convince yourself that if you introduced a negative weight on one of the edges to the graph that the algorithm would never exit.</ul><p>We will note that to route messages through the Internet, other algorithms are used for finding the shortest path.</p><p>One of the problems with using Dijkstra’s algorithm on the Internet is that you must have a complete representation of the graph in order for the algorithm to run.</p><p>The implication of this is that every router has a complete map of all the routers in the Internet.</p><p>In practice this is not the case and other variations of the algorithm allow each router to discover the graph as they go.</p><p>One such algorithm that you may want to read about is called the “distance vector” routing algorithm.</p><hr /><h5 id="analysis-of-dijkstras-algorithm">Analysis of Dijkstra’s Algorithm</h5><ul><li><p>building the priority queue takes <code class="language-plaintext highlighter-rouge">𝑂(𝑉)</code> time since we initially add every vertex in the graph to the priority queue.</p><li><p>Once the queue is constructed the while loop is executed once for every vertex, since vertices are all added at the beginning and only removed after that. Within that loop each call to delMin, takes <code class="language-plaintext highlighter-rouge">𝑂(log𝑉)</code> time.</p><li><p>Taken together that part of the loop and the calls to delMin take <code class="language-plaintext highlighter-rouge">𝑂(𝑉log(𝑉))</code>.</p><li><p>The for loop is executed once for each edge in the graph, and within the for loop the call to decreaseKey takes time <code class="language-plaintext highlighter-rouge">𝑂(𝐸log(𝑉))</code>.</p><li><p>So the combined running time is <code class="language-plaintext highlighter-rouge">𝑂((𝑉+𝐸)log(𝑉))</code>.</p></ul><hr /><h4 id="broadcast-host">broadcast host</h4><p><img data-proofer-ignore data-src="https://i.imgur.com/sMsmwKu.png" alt="bcast1" /></p><p>the broadcast host has some information that the listeners all need to receive.</p><h5 id="the-simplest-solution">The simplest solution</h5><ul><li>broadcasting host to keep a list of all of the listeners and send individual messages to each.<li>four copies of every message would be sent.<li>Assuming that the least cost path is used<ul><li>All messages from the broadcaster go through router A, A sees all four copies of every message.<li>Router C sees only one copy of each message for its listener.<li>routers B and D would see three copies of every message since routers B and D are on the cheapest path for listeners 1, 2, and 3.<li>When you consider that the broadcast host must send hundreds of messages each second for a radio broadcast, a lot of extra traffic.</ul></ul><h5 id="uncontrolled-flooding">uncontrolled flooding</h5><ul><li>A brute force solution<li>for the broadcast host to send a single copy of the broadcast message and let the routers sort things out.<li><p>In this case, the easiest solution is a strategy called <strong>uncontrolled flooding</strong>.</p><li>The flooding strategy works as follows.<ul><li>Each message starts with a <code class="language-plaintext highlighter-rouge">time to live (ttl) value</code> set to some number greater than or equal to the number of edges between the broadcast host and its most distant listener.<li>Each router gets a copy of the message and passes the message on to all of its neighboring routers.<li>When the message is passed on the <code class="language-plaintext highlighter-rouge">ttl</code> is decreased.<li>Each router continues to send copies of the message to all its neighbors until the <code class="language-plaintext highlighter-rouge">ttl</code> value reaches <code class="language-plaintext highlighter-rouge">0</code>.</ul><li>uncontrolled flooding generates many more unnecessary messages than our first strategy.</ul><hr /><h5 id="spanning-tree">spanning tree</h5><p>The solution to this problem lies in the construction of a <code class="language-plaintext highlighter-rouge">minimum weight spanning tree</code>.</p><ul><li><code class="language-plaintext highlighter-rouge">minimum spanning tree 𝑇 for a graph 𝐺=(𝑉,𝐸)</code>:<ul><li><code class="language-plaintext highlighter-rouge">𝑇</code> is an <code class="language-plaintext highlighter-rouge">acyclic 非循环 subset of 𝐸</code> that connects <code class="language-plaintext highlighter-rouge">all the vertices in 𝑉</code>.<li><code class="language-plaintext highlighter-rouge">The sum of the weights of the edges in T</code> is minimized.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/sMsmwKu.png" alt="bcast1" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/zbf3F37.png" alt="mst1" /></p><ul><li><p>simplified version of the broadcast graph</p><li><p>highlights the edges that form a <code class="language-plaintext highlighter-rouge">minimum spanning tree</code> for the graph.</p></ul><p>broadcast problem:</p><ul><li>the broadcast host simply sends a single copy of the broadcast message into the network.<li>Each router forwards the message to any neighbor that is part of the spanning tree, excluding the neighbor that just sent it the message.<li>In this example<ul><li>A forwards the message to B.<li>B forwards the message to D and C.<li>D forwards the message to E, which forwards it to F, which forwards it to G.</ul><li>No router sees more than one copy of any message, and all the listeners that are interested see a copy of the message.</ul><h4 id="prims-algorithm-ov2"><strong>Prim’s algorithm</strong> <code class="language-plaintext highlighter-rouge">O(|V|^2)</code></h4><blockquote><p>greedy algorithms: at each step we will choose the cheapest next step.</p></blockquote><ul><li>a greedy algorithm that <code class="language-plaintext highlighter-rouge">finds a minimum spanning tree</code> for a weighted undirected graph.<ul><li>follow the edge with the lowest weight.</ul><li>Prim’s find a subset of edges that forms a tree that includes every node in the graph</ul><p>The basic idea in constructing a spanning tree is as follows:</p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">While</span> <span class="n">T</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">yet</span> <span class="n">a</span> <span class="n">spanning</span> <span class="n">tree</span>
   <span class="n">Find</span> <span class="n">an</span> <span class="n">edge</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">safe</span> <span class="n">to</span> <span class="n">add</span> <span class="n">to</span> <span class="n">the</span> <span class="n">tree</span>
   <span class="n">Add</span> <span class="n">the</span> <span class="n">new</span> <span class="n">edge</span> <span class="n">to</span> <span class="n">T</span>
</pre></table></code></div></div><p><strong>safe edge</strong></p><ul><li>any edge that connects a vertex that is in the spanning tree to a vertex that is not in the spanning tree.<li>This ensures that the tree will always remain a tree and therefore have no cycles.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">pythonds.graphs</span> <span class="kn">import</span> <span class="n">PriorityQueue</span><span class="p">,</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">Vertex</span>

<span class="k">def</span> <span class="nf">prim</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">start</span><span class="p">):</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="nc">PriorityQueue</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="n">v</span><span class="p">.</span><span class="nf">setDistance</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">maxsize</span><span class="p">)</span>
        <span class="n">v</span><span class="p">.</span><span class="nf">setPred</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">start</span><span class="p">.</span><span class="nf">setDistance</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pq</span><span class="p">.</span><span class="nf">buildHeap</span><span class="p">([(</span><span class="n">v</span><span class="p">.</span><span class="nf">getDistance</span><span class="p">(),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">])</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">pq</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">():</span>
        <span class="n">currentVert</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="nf">delMin</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">nextVert</span> <span class="ow">in</span> <span class="n">currentVert</span><span class="p">.</span><span class="nf">getConnections</span><span class="p">():</span>
          <span class="n">newCost</span> <span class="o">=</span> <span class="n">currentVert</span><span class="p">.</span><span class="nf">getWeight</span><span class="p">(</span><span class="n">nextVert</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">nextVert</span> <span class="ow">in</span> <span class="n">pq</span> <span class="ow">and</span> <span class="n">newCost</span><span class="o">&lt;</span><span class="n">nextVert</span><span class="p">.</span><span class="nf">getDistance</span><span class="p">():</span>
              <span class="n">nextVert</span><span class="p">.</span><span class="nf">setPred</span><span class="p">(</span><span class="n">currentVert</span><span class="p">)</span>
              <span class="n">nextVert</span><span class="p">.</span><span class="nf">setDistance</span><span class="p">(</span><span class="n">newCost</span><span class="p">)</span>
              <span class="n">pq</span><span class="p">.</span><span class="nf">decreaseKey</span><span class="p">(</span><span class="n">nextVert</span><span class="p">,</span><span class="n">newCost</span><span class="p">)</span>
</pre></table></code></div></div><p>The following sequence of figures (Figure 11 through Figure 17) shows the algorithm in operation on our sample tree.</p><ol><li>We begin with the <strong>starting vertex as A</strong>.<ul><li>The distances to all the other vertices are initialized to infinity.<li>Looking at the neighbors of A we can update <code class="language-plaintext highlighter-rouge">distances</code> to two of the additional vertices B and C<ul><li>because the distances to B and C through A are less than infinite.</ul><li>This moves B and C to the front of the priority queue.<li>Update the <code class="language-plaintext highlighter-rouge">predecessor links</code> for B and C by setting them to point to A.<li>It is important to note that we have not formally added B or C to the spanning tree yet.<li>A node is not considered to be part of the spanning tree until it is removed from the priority queue.</ul><li>Since B has the smallest distance we <strong>look at B</strong> next.<ul><li>Examining B’s neighbors we see that D and E can be updated.<li>Both D and E get new distance values and their predecessor links are updated.<li><code class="language-plaintext highlighter-rouge">Moving on to the next node in the priority queue we find C</code>.</ul><li>The only node C is adjacent to that is still in the priority queue is F,<ul><li>thus we can update the distance to F<li>and adjust F’s position in the priority queue.</ul><li>Now we examine the vertices adjacent to node D.<ul><li>We find that we can update E and reduce the distance to E from 6 to 4.<li>When we do this we change the predecessor link on E to point back to D, thus preparing it to be grafted into the spanning tree but in a different location.<li>The rest of the algorithm proceeds as you would expect, adding each new node to the tree.</ul></ol><hr /><h4 id="tarjans-algorithm">Tarjan’s algorithm</h4><p>Articulation point: vertex in connected undirected graph such that removing the vertex will disconnect the graph.</p><p><img data-proofer-ignore data-src="https://i.imgur.com/B9d4Iyd.png" alt="Screen Shot 2021-10-10 at 4.27.59 PM" /></p><p>Step:</p><ul><li>check child<li>visited += 1<li>if coming from?<ul><li>yes<li>no<ul><li>is seen<ul><li>is seen<li>is not seen<ul><li>visited time &lt;= low time of comimg point<ul><li>yes<li>no: update visted to low time</ul></ul></ul></ul></ul></ul><hr /><h2 id="greedy-algorithms">Greedy Algorithms</h2><ul><li>algorithms that make <code class="language-plaintext highlighter-rouge">locally optimal choices at each step</code> in the hope of <code class="language-plaintext highlighter-rouge">eventually reaching the globally optimal solution</code><li>Problems must exhibit two properties in order to implement a Greedy solution:<ul><li>Optimal Substructure 最优子结构<ul><li>An optimal solution to the problem contains optimal solutions to the given problem’s subproblems.</ul><li>The Greedy Property<ul><li>An optimal solution is reached by “greedily” choosing the locally optimal choice without ever reconsidering previous choices.</ul></ul><li>Example: Coin Change<li>Given a target amount V cents and a list of denominations of n coins, i.e. we have coinValue[i] (in cents) for coin types i from [0…n - 1], what is the minimum number of coins that we must use to represent amount V?<li>Assume that we have an unlimited supply of coins of any type Coins - <code class="language-plaintext highlighter-rouge">Penny (1 cent), Nickel (5 cents), Dime (10 cents), Quarter (25 cents)</code><li>Assume V = 41. We can use the Greedy algorithm of continuously selecting the largest coin denomination less than or equal to V, subtract that coin’s value from V, and repeat.</ul><div class="language-plaintext highlighter-rouge"><div class="code-header" text-data="plaintext"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>V = 41 | 0 coins used
V = 16 | 1 coin used (41 - 25 = 16)
V = 6 | 2 coins used (16 - 10 = 6)
V = 1 | 3 coins used (6 - 5 = 1)
V = 0 | 4 coins used (1 - 1 = 0)

Using this algorithm, we arrive at a total of 4 coins which is optimal
</pre></table></code></div></div><hr /><h2 id="bitmasks">Bitmasks</h2><ul><li>Bitmasking is a technique used to perform operations at the bit level.<li>Leveraging bitmasks often leads to faster runtime complexity and helps limit memory usage<li>Test kth bit: <code class="language-plaintext highlighter-rouge">s &amp; (1 &lt;&lt; k);</code><li>Set kth bit: <code class="language-plaintext highlighter-rouge">s |= (1 &lt;&lt; k);</code><li>Turn off kth bit: <code class="language-plaintext highlighter-rouge">s &amp;= ~(1 &lt;&lt; k);</code><li>Toggle kth bit: <code class="language-plaintext highlighter-rouge">s ^= (1 &lt;&lt; k);</code><li>Multiple by 2<sup>n</sup>: <code class="language-plaintext highlighter-rouge">s &lt;&lt; n;</code><li>Divide by 2<sup>n</sup>: <code class="language-plaintext highlighter-rouge">s &gt;&gt; n;</code><li>Intersection: <code class="language-plaintext highlighter-rouge">s &amp; t;</code><li>Union: <code class="language-plaintext highlighter-rouge">s | t;</code><li>Set Subtraction: <code class="language-plaintext highlighter-rouge">s &amp; ~t;</code><li>Extract lowest set bit: <code class="language-plaintext highlighter-rouge">s &amp; (-s);</code><li>Extract lowest unset bit: <code class="language-plaintext highlighter-rouge">~s &amp; (s + 1);</code><li>Swap Values: * <code class="language-plaintext highlighter-rouge"> x ^= y; y ^= x; x ^= y; </code></ul><hr /><h2 id="other-algorithm">other Algorithm</h2><h3 id="bellman-ford-algorithm">Bellman-Ford Algorithm</h3><p><img data-proofer-ignore data-src="https://i.imgur.com/8B0EFth.gif" alt="bellman-ford" /></p><p>Bellman-Ford Algorithm</p><ul><li><p>an algorithm that computes the shortest paths from a single source node to all other nodes in a weighted graph</p><li>slower than Dijkstra’s<li>but more versatile, as it is capable of handling graphs in which some of the edge weights are negative numbers</ul><p>Time Complexity:</p><ul><li><div class="table-wrapper"><table><tbody><tr><td>Best Case: O(<td>E<td>)</table></div><li><div class="table-wrapper"><table><tbody><tr><td>Worst Case: O(<td>V<td> <td>E<td>)</table></div></ul><hr /><h3 id="floyd-warshall-algorithm">Floyd-Warshall Algorithm</h3><p>Floyd-Warshall Algorithm</p><ul><li>an algorithm for finding the shortest paths in a weighted graph with <code class="language-plaintext highlighter-rouge">positive or negative edge weights</code>,<li>but no negative cycles<li>A single execution of the algorithm will find the lengths (summed weights) of the shortest paths between all pairs of nodes</ul><p>Time Complexity:</p><ul><li><div class="table-wrapper"><table><tbody><tr><td>Best Case: O(<td>V<td>^3)</table></div><li><div class="table-wrapper"><table><tbody><tr><td>Worst Case: O(<td>V<td>^3)</table></div><li><div class="table-wrapper"><table><tbody><tr><td>Average Case: O(<td>V<td>^3)</table></div></ul><hr /><h3 id="kruskals-algorithm-oelogv">Kruskal’s Algorithm <code class="language-plaintext highlighter-rouge">O(|E|log|V|)</code></h3><p>Kruskal’s Algorithm</p><ul><li>a greedy algorithm that <code class="language-plaintext highlighter-rouge">finds a minimum spanning tree in a graph</code>.<li>However, in Kruskal’s, the graph does not have to be connected</ul><div class="table-wrapper"><table><tbody><tr><td>Time Complexity: O(<td>E<td>log<td>V<td>)</table></div><p>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/00codenote/'>00CodeNote</a>, <a href='/categories/pythonnote/'>PythonNote</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=DS - pythonds3 - 8. Graphs and Graph Algorithms - Grace&url=https://ocholuo.github.io//posts/8-Graphy/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=DS - pythonds3 - 8. Graphs and Graph Algorithms - Grace&u=https://ocholuo.github.io//posts/8-Graphy/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=DS - pythonds3 - 8. Graphs and Graph Algorithms - Grace&url=https://ocholuo.github.io//posts/8-Graphy/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Amazon-CloudFront/">AWS Lab - AWS CloudFront</a><li><a href="/posts/Alexa-1stSkill/">AWS Alex First Skill - RedVelvet Time</a><li><a href="/posts/NetworkProtocol-SSL-TLS-Handshake/">NetworkProtocol SSL/TLS Handshake</a><li><a href="/posts/pythonCrash/">Python Crash</a><li><a href="/posts/%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%A7%A3%E9%87%8AAWS/">AWS - 一句话解释AWS</a><li><a href="/posts/GKE/">GCP - Google Cloud Computing - Kubernetes and Kubernetes Engine</a><li><a href="/posts/Go-Note/">Go Note</a><li><a href="/posts/SCPs/">AWS - IdenAccessManage - SCPs (Service Control Policies)</a><li><a href="/posts/CompanyBenefit/">Company Benefit</a><li><a href="/posts/Encryption-SSL&TLS/">Cryptography - SSL/TLS Encryption</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/soc/">SOC</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/5-Recursion-Exercises/"><div class="card-body"> <span class="timeago small" >Aug 25, 2019<i class="unloaded">2019-08-25T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DS - pythonds3 - 5. Recursion - Exercises</h3><div class="text-muted small"><p> DS - pythonds3 - 5. Recursion - Exercises check the reverse words check the mirror words exchange the coins factorial of a number recursive tree Fibonacc...</p></div></div></a></div><div class="card"> <a href="/posts/6-Sorting-and-Searching/"><div class="card-body"> <span class="timeago small" >Aug 25, 2019<i class="unloaded">2019-08-25T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DS - pythonds3 - 6. Algorithms Sorting and Searching</h3><div class="text-muted small"><p> DS - pythonds3 - 6. Algorithms Sorting and Searching summary Searching The Sequential Search 一个个找 Sequential Search of an Unordered...</p></div></div></a></div><div class="card"> <a href="/posts/pythonCrash/"><div class="card-body"> <span class="timeago small" >Oct 11, 2019<i class="unloaded">2019-10-11T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Python Crash</h3><div class="text-muted small"><p> Python Crash String List dictionary Tuple Sorted Functions lambda zip, map filter test except RegularExpression Data ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/7-Tree/" class="btn btn-outline-primary" prompt="Older"><p>Data Structures - Basic 1 - Tree</p></a> <a href="/posts/DS-Basic1-Analysis/" class="btn btn-outline-primary" prompt="Newer"><p>Data Structures - Basic 1 - Analysis</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/ocholuo">Grace JyL</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/soc/">SOC</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://ocholuo.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script defer src="/assets/js/dist/pvreport.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-179830187-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-179830187-1'); }); </script>
