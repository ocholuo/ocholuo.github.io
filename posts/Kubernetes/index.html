<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="pv-proxy-endpoint" content="https://myochosite-291718.appspot.com/query?id=ahNwfm15b2Nob3NpdGUtMjkxNzE4chULEghBcGlRdWVyeRiAgIDo14eBCgw"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Virtulization - Google Kubernetes" /><meta property="og:locale" content="en" /><meta name="description" content="Virtulization - Google Kubernetes basic need of container orchestration tool 快速上手 基本概念 容器组 Pod Pod 管理 Pod 的使用 替代方案 Pod 的生命周期 services ConfigMap + secret Data storgae - volume 架构设计考虑 kubernetes architecture 节点 Node 容器状态 主机IP Node 周期 Node 状态 Node 管理 Node 控制 Productiom cluster setup minikube kubectl 使用 deploy Deployment StatefulSet" /><meta property="og:description" content="Virtulization - Google Kubernetes basic need of container orchestration tool 快速上手 基本概念 容器组 Pod Pod 管理 Pod 的使用 替代方案 Pod 的生命周期 services ConfigMap + secret Data storgae - volume 架构设计考虑 kubernetes architecture 节点 Node 容器状态 主机IP Node 周期 Node 状态 Node 管理 Node 控制 Productiom cluster setup minikube kubectl 使用 deploy Deployment StatefulSet" /><link rel="canonical" href="https://ocholuo.github.io//posts/Kubernetes/" /><meta property="og:url" content="https://ocholuo.github.io//posts/Kubernetes/" /><meta property="og:site_name" content="Grace" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-11-26T10:11:11-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Virtulization - Google Kubernetes" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-01-02T18:48:40-05:00","datePublished":"2020-11-26T10:11:11-05:00","description":"Virtulization - Google Kubernetes basic need of container orchestration tool 快速上手 基本概念 容器组 Pod Pod 管理 Pod 的使用 替代方案 Pod 的生命周期 services ConfigMap + secret Data storgae - volume 架构设计考虑 kubernetes architecture 节点 Node 容器状态 主机IP Node 周期 Node 状态 Node 管理 Node 控制 Productiom cluster setup minikube kubectl 使用 deploy Deployment StatefulSet","headline":"Virtulization - Google Kubernetes","mainEntityOfPage":{"@type":"WebPage","@id":"https://ocholuo.github.io//posts/Kubernetes/"},"url":"https://ocholuo.github.io//posts/Kubernetes/"}</script><title>Virtulization - Google Kubernetes | Grace</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Grace"><meta name="application-name" content="Grace"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://myochosite-291718.appspot.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://myochosite-291718.appspot.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/huoye.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Grace</a></div><div class="site-subtitle font-italic">2023 Mar 14 updated</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ocholuo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Virtulization - Google Kubernetes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Virtulization - Google Kubernetes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Grace JyL </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Nov 26, 2020, 10:11 AM -0500" >Nov 26, 2020<i class="unloaded">2020-11-26T10:11:11-05:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Jan 2, 2023, 3:48 PM -0800" >Jan 2<i class="unloaded">2023-01-02T18:48:40-05:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5118 words">28 min read</span> <span id="pv" class="pageviews"> <i class="fas fa-spinner fa-spin fa-fw"></i> </span> views</div></div><div class="post-content"><ul><li><a href="#virtulization---google-kubernetes">Virtulization - Google Kubernetes</a><ul><li><a href="#basic">basic</a><li><a href="#need-of-container-orchestration-tool">need of container orchestration tool</a></ul><li><a href="#快速上手">快速上手</a><ul><li><a href="#基本概念">基本概念</a><ul><li><a href="#容器组-pod">容器组 Pod</a><ul><li><a href="#pod-管理">Pod 管理</a><li><a href="#pod-的使用">Pod 的使用</a><li><a href="#替代方案">替代方案</a><li><a href="#pod-的生命周期">Pod 的生命周期</a></ul><li><a href="#services">services</a><li><a href="#configmap--secret">ConfigMap + secret</a><li><a href="#data-storgae---volume">Data storgae - volume</a></ul><li><a href="#架构设计考虑">架构设计考虑</a><li><a href="#kubernetes-architecture">kubernetes architecture</a><ul><li><a href="#节点-node">节点 Node</a><ul><li><a href="#容器状态">容器状态</a><li><a href="#主机ip">主机IP</a><li><a href="#node-周期">Node 周期</a><li><a href="#node-状态">Node 状态</a><li><a href="#node-管理">Node 管理</a><li><a href="#node-控制">Node 控制</a></ul></ul><li><a href="#productiom-cluster-setup">Productiom cluster setup</a><ul><li><a href="#minikube">minikube</a><li><a href="#kubectl-使用">kubectl 使用</a></ul><li><a href="#deploy">deploy</a><ul><li><a href="#deployment">Deployment</a><li><a href="#statefulset">StatefulSet</a></ul></ul></ul><hr /><h1 id="virtulization---google-kubernetes">Virtulization - Google Kubernetes</h1><p><img data-proofer-ignore data-src="https://i.imgur.com/ibs26v8.png" alt="k8s_architecture" /></p><h2 id="basic">basic</h2><ul><li>open source container orchestration tool<ul><li>help to manage containerized application in different deployment environment (physical, virtual, cloud)</ul><li><p>Google 团队发起并维护的基于 Docker 的开源容器集群管理系统，</p><li><p>目标是管理跨多个主机的容器，提供基本的部署，维护以及运用伸缩，主要实现语言为 Go 语言</p><li>它不仅支持常见的云平台，而且支持内部数据中心。<ul><li>易学：轻量级，简单，容易理解<li>便携：支持公有云，私有云，混合云，以及多种云平台<li>可拓展：模块化，可插拔，支持钩子，可任意组合<li>自修复：自动重调度，自动重启，自动复制</ul><li>建于 Docker 之上的 Kubernetes 可以构建一个容器的调度服务，其目的是让用户透过 Kubernetes 集群来进行云端容器集群的管理，而无需用户进行复杂的设置工作。<li>系统会自动选取合适的工作Node 来执行具体的容器集群调度处理工作。<li>其核心概念是 Container Pod。<ul><li>一个 Pod 由一组工作于同一物理工作Node 的容器构成。<li>这些组容器拥有相同的网络命名空间、IP以及存储配额，也可以根据实际情况对每一个 Pod 进行端口映射。<li>此外，Kubernetes 工作Node 会由主系统进行管理，Node 包含了能够运行 Docker 容器所用到的服务。</ul></ul><hr /><h2 id="need-of-container-orchestration-tool">need of container orchestration tool</h2><ul><li><p>trend from Monolith to Microservices</p><li><p>increased usage of microservices</p><li><p>proper way to manage it</p><ul><li>High Availability - no down time<li>scalability or high performance - high response rate<li>Disaster recovery - backup and restore</ul></ul><hr /><h1 id="快速上手">快速上手</h1><p>Kubernetes 支持在多种环境下的安装，包括本地主机(Fedora)、云服务(Google GAE、AWS 等)。</p><ul><li>然而最快速体验 Kubernetes 的方式显然是本地通过 Docker 的方式来启动相关进程。</ul><p>在单 Node 使用 Docker 快速部署一套 Kubernetes 的拓扑。</p><p><img data-proofer-ignore data-src="https://i.imgur.com/MoGH8ac.png" alt="k8s-singlenode-docker" /></p><blockquote><p>Kubernetes 依赖 Etcd 服务来维护所有主Node 的状态。</p></blockquote><div class="language-bash highlighter-rouge"><div class="code-header" text-data="bash"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre><td class="rouge-code"><pre><span class="c"># 启动 Etcd 服务。</span>
<span class="nv">$ </span>docker run <span class="nt">--net</span><span class="o">=</span>host <span class="nt">-d</span> <span class="se">\</span>
         gcr.io/google_containers/etcd:2.0.9 /usr/local/bin/etcd <span class="se">\</span>
         <span class="nt">--addr</span><span class="o">=</span>127.0.0.1:4001 <span class="se">\</span>
         <span class="nt">--bind-addr</span><span class="o">=</span>0.0.0.0:4001 <span class="se">\</span>
         <span class="nt">--data-dir</span><span class="o">=</span>/var/etcd/data


<span class="c"># 启动主Node</span>
<span class="c"># 启动 kubelet。</span>
<span class="nv">$ </span>docker run <span class="nt">--net</span><span class="o">=</span>host <span class="nt">-d</span> <span class="nt">-v</span> /var/run/docker.sock:/var/run/docker.sock <span class="se">\</span>
         gcr.io/google_containers/hyperkube:v0.17.0 /hyperkube kubelet <span class="nt">--api_servers</span><span class="o">=</span>http://localhost:8080 <span class="nt">--v</span><span class="o">=</span>2 <span class="nt">--address</span><span class="o">=</span>0.0.0.0 <span class="se">\</span>
         <span class="nt">--enable_server</span> <span class="se">\</span>
         <span class="nt">--hostname_override</span><span class="o">=</span>127.0.0.1 <span class="se">\</span>
         <span class="nt">--config</span><span class="o">=</span>/etc/kubernetes/manifests


<span class="c"># 启动服务代理</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">--net</span><span class="o">=</span>host <span class="nt">--privileged</span>
         gcr.io/google_containers/hyperkube:v0.17.0 /hyperkube proxy <span class="nt">--master</span><span class="o">=</span>http://127.0.0.1:8080 <span class="nt">--v</span><span class="o">=</span>2


<span class="c"># 测试状态</span>
<span class="c"># 在本地访问 8080 端口，可以获取到如下的结果：</span>

<span class="nv">$ </span>curl 127.0.0.1:8080
<span class="o">{</span>
  <span class="s2">"paths"</span>: <span class="o">[</span>
    <span class="s2">"/api"</span>,
    <span class="s2">"/api/v1beta1"</span>,
    <span class="s2">"/api/v1beta2"</span>,
    <span class="s2">"/api/v1beta3"</span>,
    <span class="s2">"/healthz"</span>,
    <span class="s2">"/healthz/ping"</span>,
    <span class="s2">"/logs/"</span>,
    <span class="s2">"/metrics"</span>,
    <span class="s2">"/static/"</span>,
    <span class="s2">"/swagger-ui/"</span>,
    <span class="s2">"/swaggerapi/"</span>,
    <span class="s2">"/validate"</span>,
    <span class="s2">"/version"</span>
  <span class="o">]</span>
<span class="o">}</span>


<span class="c"># 查看服务</span>
<span class="c"># 所有服务启动后，查看本地实际运行的 Docker 容器，有如下几个。</span>
CONTAINER ID        IMAGE                                        COMMAND                CREATED             STATUS              PORTS               NAMES
ee054db2516c        gcr.io/google_containers/hyperkube:v0.17.0   <span class="s2">"/hyperkube schedule   2 days ago          Up 1 days                               k8s_scheduler.509f29c9_k8s-master-127.0.0.1_default_9941e5170b4365bd4aa91f122ba0c061_e97037f5
3b0f28de07a2        gcr.io/google_containers/hyperkube:v0.17.0   "</span>/hyperkube apiserve   2 days ago          Up 1 days                               k8s_apiserver.245e44fa_k8s-master-127.0.0.1_default_9941e5170b4365bd4aa91f122ba0c061_6ab5c23d
2eaa44ecdd8e        gcr.io/google_containers/hyperkube:v0.17.0   <span class="s2">"/hyperkube control   2 days ago          Up 1 days                               k8s_controller-manager.33f83d43_k8s-master-127.0.0.1_default_9941e5170b4365bd4aa91f122ba0c061_1a60106f
30aa7163cbef        gcr.io/google_containers/hyperkube:v0.17.0   "</span>/hyperkube proxy <span class="nt">--</span>   2 days ago          Up 1 days                               jolly_davinci
a2f282976d91        gcr.io/google_containers/pause:0.8.0         <span class="s2">"/pause"</span>               2 days ago          Up 2 days                               k8s_POD.e4cc795_k8s-master-127.0.0.1_default_9941e5170b4365bd4aa91f122ba0c061_e8085b1f
c060c52acc36        gcr.io/google_containers/hyperkube:v0.17.0   <span class="s2">"/hyperkube kubelet    2 days ago          Up 1 days                               serene_nobel
cc3cd263c581        gcr.io/google_containers/etcd:2.0.9          "</span>/usr/local/bin/etcd   2 days ago          Up 1 days                               happy_turing

<span class="c"># 这些服务大概分为三类：主Node 服务、工作Node 服务和其它服务。</span>

<span class="c"># 主Node 服务</span>
<span class="c"># apiserver 是整个系统的对外接口，提供 RESTful 方式供客户端和其它组件调用；</span>

<span class="c"># scheduler 负责对资源进行调度，分配某个 pod 到某个Node 上；</span>

<span class="c"># controller-manager 负责管理控制器，包括 endpoint-controller(刷新服务和 pod 的关联信息)和 replication-controller(维护某个 pod 的复制为配置的数值)。</span>

<span class="c"># 工作Node 服务</span>
<span class="c"># kubelet 是工作Node 执行操作的 agent，负责具体的容器生命周期管理，根据从数据库中获取的信息来管理容器，并上报 pod 运行状态等；</span>

<span class="c"># proxy 为 pod 上的服务提供访问的代理。</span>

<span class="c"># 其它服务</span>
<span class="c"># Etcd 是所有状态的存储数据库；</span>

<span class="c"># gcr.io/google_containers/pause:0.8.0 是 Kubernetes 启动后自动 pull 下来的测试镜像。</span>
</pre></table></code></div></div><p>这些服务大概分为三类：<code class="language-plaintext highlighter-rouge">主Node 服务</code>、<code class="language-plaintext highlighter-rouge">工作Node 服务</code>和<code class="language-plaintext highlighter-rouge">其它服务</code></p><ul><li>主Node 服务<ul><li>apiserver 是整个系统的对外接口，提供 RESTful 方式供客户端和其它组件调用；<li>scheduler 负责对资源进行调度，分配某个 pod 到某个Node 上；<li>controller-manager 负责管理控制器，包括 endpoint-controller(刷新服务和 pod 的关联信息)和 replication-controller(维护某个 pod 的复制为配置的数值)。</ul><li>工作Node 服务<ul><li>kubelet 是工作Node 执行操作的 agent，负责具体的容器生命周期管理，根据从数据库中获取的信息来管理容器，并上报 pod 运行状态等；<li>proxy 为 pod 上的服务提供访问的代理。</ul><li>其它服务<ul><li>Etcd 是所有状态的存储数据库；<li><code class="language-plaintext highlighter-rouge">gcr.io/google_containers/pause:0.8.0</code> 是 Kubernetes 启动后自动 pull 下来的测试镜像。</ul></ul><hr /><h2 id="基本概念">基本概念</h2><p><img data-proofer-ignore data-src="https://i.imgur.com/ibs26v8.png" alt="k8s_architecture" /></p><ul><li>节点(<code class="language-plaintext highlighter-rouge">Node</code>)：一个Node 是一个运行 Kubernetes 中的主机。<li>容器组 (<code class="language-plaintext highlighter-rouge">Pod</code>)：一个 Pod 对应于由若干Pod 成的一个Pod ，同个 Pod 内的容器共享一个存储卷(volume)。<li>容器组生命周期(<code class="language-plaintext highlighter-rouge">pos-states</code>)：包含所有容器状态集合，包括Pod 状态类型，Pod 生命周期，事件，重启策略，以及 replication controllers。<li><code class="language-plaintext highlighter-rouge">Replication Controllers</code>：主要负责指定数量的 pod 在同一时间一起运行。<li>服务(<code class="language-plaintext highlighter-rouge">services</code>)：一个 Kubernetes 服务是Pod 逻辑的高级抽象，同时也对外提供访问Pod 的策略。<li>卷(<code class="language-plaintext highlighter-rouge">volumes</code>)：一个卷就是一个目录，容器对其有访问权限。<li>标签(<code class="language-plaintext highlighter-rouge">labels</code>)：标签是用来连接一组对象的，比如Pod 。标签可以被用来组织和选择子对象。<li>接口权限(<code class="language-plaintext highlighter-rouge">accessing_the_api</code>)：端口，IP 地址和代理的防火墙规则。<li>web 界面(<code class="language-plaintext highlighter-rouge">ux</code>)：用户可以通过 web 界面操作 Kubernetes。<li>命令行操作(<code class="language-plaintext highlighter-rouge">cli</code>)：<code class="language-plaintext highlighter-rouge">kubecfg</code>命令。</ul><hr /><h3 id="容器组-pod">容器组 Pod</h3><p><img data-proofer-ignore data-src="https://i.imgur.com/m2i7iBm.png" alt="Screen Shot 2022-04-05 at 12.14.12" /></p><p>在 Kubernetes 中，使用的最小单位是Pod</p><ul><li>Pod 是创建，调度，管理的最小单位。<li>一个Pod 使用相同的 Docker 容器并共享卷(挂载点)。<li>一个Pod 是一个特定应用的打包集合，包含一个或多个容器。<li><p>smallest unit</p><li><p>abstraction over container</p><li>create a layer of container<ul><li>Pod : one application<li>Pod &gt; container + container + container</ul><li>each Pod has one IP<ul><li>pod communicate by using IP<li>new IP on re-creatyion</ul><li>Pod 被认为只有很短的运行周期。<ul><li>Pod 被调度到一组Node 运行，直到容器的生命周期结束或者其被删除。<li>如果Node 死掉，运行在其上的Pod 将会被删除而不是重新调度。(也许在将来的版本中会添加Pod 的移动)。</ul></ul><p>Pod 设计的初衷：资源共享和通信</p><ul><li>Pod 主要是为了数据共享和它们之间的通信。<li>在一个Pod 中，容器都使用相同的网络地址和端口，可以通过本地网络来相互通信。<li>每个Pod 都有独立的 IP，可用通过网络来和其他物理主机或者容器通信。<li>Pod 有一组存储卷(挂载点)，主要是为了让容器在重启之后可以不丢失数据。</ul><h4 id="pod-管理">Pod 管理</h4><p>Pod 是一个运用管理和部署的高层次抽象，同时也是一组容器的接口。Pod 是部署、水平放缩的最小单位。</p><h4 id="pod-的使用">Pod 的使用</h4><p>Pod 可以通过组合来构建复杂的运用，其本来的意义包含：</p><ul><li>内容管理，文件和数据加载以及本地缓存管理等。<li>日志和检查点备份，压缩，快照等。<li>监听数据变化，跟踪日志，日志和监控代理，消息发布等。<li>代理，网桥<li>控制器，管理，配置以及更新</ul><hr /><h4 id="替代方案">替代方案</h4><p>为什么不在一个单一的容器里运行多个程序？</p><ol><li>透明化。为了使Pod 中的容器保持一致的基础设施和服务，比如进程管理和资源监控。这样设计是为了用户的便利性。<li>解偶软件之间的依赖。每个容器都可能重新构建和发布，Kubernetes 必须支持热发布和热更新(将来)。<li>方便使用。用户不必运行独立的程序管理，也不用担心每个运用程序的退出状态。<li>高效。考虑到基础设施有更多的职责，容器必须要轻量化。</ol><hr /><h4 id="pod-的生命周期">Pod 的生命周期</h4><p>包括若干状态值：<code class="language-plaintext highlighter-rouge">pending</code>、<code class="language-plaintext highlighter-rouge">running</code>、<code class="language-plaintext highlighter-rouge">succeeded</code>、<code class="language-plaintext highlighter-rouge">failed</code>。</p><ol><li>pending<ul><li>Pod 已经被 Node 接受，但有一个或多个容器还没有运行起来。<li>这将包含某些 Node 正在下载镜像的时间，这种情形会依赖于网络情况。</ul><li>running<ul><li>Pod 已经被调度到 Node ，并且所有的容器都已经启动。<li>至少有一个容器处于运行状态(或者处于重启状态)。</ul><li>succeeded<ul><li>所有的容器都正常退出。</ul><li>failed<ul><li>Pod 中所有容器都意外中断了。</ul></ol><p>通常来说，如果Pod 被创建了就不会自动销毁</p><ul><li>除非被某种行为触发，而触发此种情况可能是人为，或者复制控制器所为。<li>唯一例外的是 Pod 由 succeeded 状态成功退出，或者在一定时间内重试多次依然失败。<li>如果某个 Node 死掉或者不能连接，那么Node 控制器将会标记其上的Pod 的状态为 <code class="language-plaintext highlighter-rouge">failed</code>。</ul><p>举例如下。</p><ul><li>Pod 状态 <code class="language-plaintext highlighter-rouge">running</code>，有 1 容器，容器正常退出<ul><li>记录完成事件<li>如果重启策略为：<ul><li>始终：重启容器，Pod 保持 <code class="language-plaintext highlighter-rouge">running</code><li>失败时：Pod 变为 <code class="language-plaintext highlighter-rouge">succeeded</code><li>从不：Pod 变为 <code class="language-plaintext highlighter-rouge">succeeded</code></ul></ul><li>Pod 状态 <code class="language-plaintext highlighter-rouge">running</code>，有1容器，容器异常退出<ul><li>记录失败事件<li>如果重启策略为：<ul><li>始终：重启容器，Pod 保持 <code class="language-plaintext highlighter-rouge">running</code><li>失败时：重启容器，Pod 保持 <code class="language-plaintext highlighter-rouge">running</code><li>从不：Pod 变为 <code class="language-plaintext highlighter-rouge">failed</code></ul></ul><li>Pod 状态 <code class="language-plaintext highlighter-rouge">running</code>，有2容器，有1容器异常退出<ul><li>记录失败事件<li>如果重启策略为：<ul><li>始终：重启容器，Pod 保持 <code class="language-plaintext highlighter-rouge">running</code><li>失败时：重启容器，Pod 保持 <code class="language-plaintext highlighter-rouge">running</code><li>从不：Pod 保持 <code class="language-plaintext highlighter-rouge">running</code><ul><li>当有2容器退出</ul><li>记录失败事件<li>如果重启策略为：<ul><li>始终：重启容器，Pod 保持 <code class="language-plaintext highlighter-rouge">running</code><li>失败时：重启容器，Pod 保持 <code class="language-plaintext highlighter-rouge">running</code><li>从不：Pod 变为 <code class="language-plaintext highlighter-rouge">failed</code></ul></ul></ul><li>Pod 状态 <code class="language-plaintext highlighter-rouge">running</code>，容器内存不足<ul><li>标记容器错误中断<li>记录内存不足事件<li>如果重启策略为：<ul><li>始终：重启容器，Pod 保持 <code class="language-plaintext highlighter-rouge">running</code><li>失败时：重启容器，Pod 保持 <code class="language-plaintext highlighter-rouge">running</code><li>从不：记录错误事件，Pod 变为 <code class="language-plaintext highlighter-rouge">failed</code></ul></ul><li>Pod 状态 <code class="language-plaintext highlighter-rouge">running</code>，一块磁盘死掉<ul><li>杀死所有容器<li>记录事件<li>Pod 变为 <code class="language-plaintext highlighter-rouge">failed</code><li>如果Pod 运行在一个控制器下，Pod 将会在其他地方重新创建</ul><li>Pod 状态 <code class="language-plaintext highlighter-rouge">running</code>，对应的Node 段溢出<ul><li>Node 控制器等到超时<li>Node 控制器标记Pod <code class="language-plaintext highlighter-rouge">failed</code><li>如果Pod 运行在一个控制器下，Pod 将会在其他地方重新创建</ul></ul><hr /><h3 id="services">services</h3><p><img data-proofer-ignore data-src="https://i.imgur.com/MDG9Llr.png" alt="Screen Shot 2022-04-05 at 12.14.48" /></p><ul><li>permanent IP attach to each pod<li><p>lifecycle of Pof and service not connected</p><li>App should be accessible through browser<ul><li>external service:<ul><li>http://a.b.c.d:port<li>http://myapp.com &lt;- Ingree</ul><li>internal service:<ul><li>http:myDB</ul></ul></ul><hr /><h3 id="configmap--secret">ConfigMap + secret</h3><ul><li>external configuration to application<ul><li>URL_DB = mongo-db-service1<li>URL_DB = mongo-db-service2</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/GLqFm3i.png" alt="Screen Shot 2022-04-05 at 12.17.37" /></p><p>secret</p><ul><li>to store credential<li>base64 encoded</ul><hr /><h3 id="data-storgae---volume">Data storgae - volume</h3><ul><li><p>data storage for Pod</p><li><p>volumes attach to Pod (local/remote)</p><li><p>keep storage permanent</p><ul><li>k8s cluster do not manage data persistence</ul></ul><hr /><h2 id="架构设计考虑">架构设计考虑</h2><ul><li>分布式架构，保证扩展性；<li>逻辑集中式的控制平面 + 物理分布式的运行平面；<li>一套资源调度系统，管理哪个容器该分配到哪个节点上；<li>一套对容器内服务进行抽象和 HA 的系统。</ul><p>运行原理</p><p><img data-proofer-ignore data-src="https://i.imgur.com/ibs26v8.png" alt="k8s_architecture" /></p><p>Kubernetes 是一套分布式系统</p><ul><li>由多个节点组成，节点分为两类：<ul><li>一类是属于管理平面的 <code class="language-plaintext highlighter-rouge">主节点/控制节点(Master Node)</code>: 复杂的工作<li>一类是属于运行平面的 <code class="language-plaintext highlighter-rouge">工作节点(Worker Node)</code>: 负责提供稳定的操作接口和能力抽象即可。</ul></ul><p>从这张图上，我们没有能发现 Kubernetes 中对于控制平面的分布式实现，但是由于数据后端自身就是一套分布式的数据库 Etcd，因此可以很容易扩展到分布式实现。</p><p>这些服务大概分为三类：<code class="language-plaintext highlighter-rouge">主Node 服务</code>、<code class="language-plaintext highlighter-rouge">工作Node 服务</code>和<code class="language-plaintext highlighter-rouge">其它服务</code></p><p><img data-proofer-ignore data-src="https://i.imgur.com/KqhiUE6.png" alt="kube-proxy" /></p><ul><li><strong>主Node 服务</strong><ul><li><code class="language-plaintext highlighter-rouge">apiserver</code> 是整个系统的对外接口，提供 RESTful 方式供客户端和其它组件调用；<li><code class="language-plaintext highlighter-rouge">scheduler</code> 负责对资源进行调度，分配某个 pod 到某个Node 上；<li><code class="language-plaintext highlighter-rouge">controller-manager</code><ul><li>负责管理控制器，<li>包括 endpoint-controller(刷新服务和 pod 的关联信息)<li>和 replication-controller(维护某个 pod 的复制为配置的数值)。</ul></ul><li><strong>工作Node 服务</strong><ul><li>kubelet 是工作 Node 执行操作的 agent<li>负责具体的容器生命周期管理，根据从数据库中获取的信息来管理容器，并上报 pod 运行状态等；<li>proxy 为 pod 上的服务提供访问的代理。<li>kube-proxy 是一个简单的网络访问代理，同时也是一个 Load Balancer。<li>它负责将访问到某个服务的请求具体分配给工作节点上的 Pod（同一类标签）。</ul><li><strong>其它服务</strong><ul><li>Etcd 是所有状态的存储数据库；<li><code class="language-plaintext highlighter-rouge">gcr.io/google_containers/pause:0.8.0</code> 是 Kubernetes 启动后自动 pull 下来的测试镜像。</ul></ul><hr /><h2 id="kubernetes-architecture">kubernetes architecture</h2><p><img data-proofer-ignore data-src="https://i.imgur.com/hgtitTh.png" alt="Screen Shot 2022-04-05 at 12.28.56" /></p><hr /><h3 id="节点-node">节点 Node</h3><p><strong>Node</strong></p><ul><li>在 <code class="language-plaintext highlighter-rouge">Kubernetes</code> 中，Node 是实际工作的点<ul><li>Worker Nodes do the work</ul><li><p>Node &gt; Pod + Pod + Pod</p><li><p>Node 可以是虚拟机或者物理机器，依赖于一个集群环境。</p><li><p>每个 Node 都有一些必要的服务以运行Pod ，并且它们都可以通过主 Node 来管理。</p><li><p>必要服务包括 Docker，kubelet 和代理服务。</p><li>3 processes mush be installed on every Node<ul><li>必要服务包括 Docker，kubelet 和代理服务。<ol><li> <font color="red"> Container runtime </font></ol><ol><li>Container runtime: container …<li>Container runtime need to be installed on each pod 2. <font color="red"> Kubelet </font><li>get request from <strong>scheduler</strong><li>schedule those container<li>interface with both the container and node<li>kubelet starts the pod with a container inside 3. <font color="red"> Kube proxy </font><li>forward request from service to pod</ol></ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/AtgjCvQ.png" alt="Screen Shot 2022-04-05 at 12.32.53" /></p><p><strong>Master</strong></p><ul><li>to interact with cluster<li><p>need less resource than worker node</p><li>4 processes mush be installed on every Node<ul><li> <font color="red"> Api Server </font><ul><li>cluster gateway<li>get request and query<li>gatekeepper for Authentication :<ul><li>validate the request<li>health request</ul></ul><li> <font color="red"> scheduler </font><ul><li>decide<li>to schedule a new pod<li>decide the resource need<li>decide which worker node (check the <strong>etcd</strong>: A 30% used, B 60% used)</ul><li> <font color="red"> Controller manager </font><ul><li>detect cluster state change<ul><li>pod dead -&gt; recover cluster state<li>request to scheduler -&gt; kubelet</ul></ul><li> <font color="red"> etcd </font><ul><li>cluster brain<li>store actual application data<li>cluster state information<li>key value store<li>changes get stored in the key value store</ul></ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/ZIu6XhR.jpg" alt="Screen Shot 2022-04-05 at 12.41.24" /></p><hr /><h4 id="容器状态">容器状态</h4><p>容器状态用来描述Node 的当前状态。现在，其中包含三个信息：</p><hr /><h4 id="主机ip">主机IP</h4><p>主机 IP 需要云平台来查询，<code class="language-plaintext highlighter-rouge">Kubernetes</code> 把它作为状态的一部分来保存。</p><ul><li>如果 <code class="language-plaintext highlighter-rouge">Kubernetes</code> 没有运行在云平台上，Node ID 就是必需的。<li>IP 地址可以变化，并且可以包含多种类型的 IP 地址，如公共 IP，私有 IP，动态 IP，ipv6 等等。</ul><h4 id="node-周期">Node 周期</h4><p>通常来说Node 有 <code class="language-plaintext highlighter-rouge">Pending</code>，<code class="language-plaintext highlighter-rouge">Running</code>，<code class="language-plaintext highlighter-rouge">Terminated</code> 三个周期</p><ul><li>如果 Kubernetes 发现了一个Node 并且其可用，那么 Kubernetes 就把它标记为 <code class="language-plaintext highlighter-rouge">Pending</code>。<li>然后在某个时刻，Kubernetes 将会标记其为 <code class="language-plaintext highlighter-rouge">Running</code>。<li>Node 的结束周期称为 <code class="language-plaintext highlighter-rouge">Terminated</code>。<li>一个已经 <code class="language-plaintext highlighter-rouge">Terminated</code> 的Node 不会接受和调度任何请求，并且已经在其上运行的Pod 也会删除。</ul><h4 id="node-状态">Node 状态</h4><p>Node 的状态主要是用来描述处于 <code class="language-plaintext highlighter-rouge">Running</code> 的Node 。</p><ul><li>可用的有 <code class="language-plaintext highlighter-rouge">NodeReachable</code> 和 <code class="language-plaintext highlighter-rouge">NodeReady</code>。以后可能会增加其他状态。<li><code class="language-plaintext highlighter-rouge">NodeReachable</code> 表示集群可达。<li><code class="language-plaintext highlighter-rouge">NodeReady</code> 表示 kubelet 返回 Status Ok 并且 HTTP 状态检查健康。</ul><h4 id="node-管理">Node 管理</h4><p>Node 并非 Kubernetes 创建，而是由云平台创建，或者就是物理机器、虚拟机。</p><ul><li>在 Kubernetes 中，Node 仅仅是一条记录，<li>Node 创建之后，Kubernetes 会检查其是否可用。<li>在 Kubernetes 中，Node 用如下结构保存：</ul><div class="language-json highlighter-rouge"><div class="code-header" text-data="json"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="w">    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"10.1.2.3"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Minion"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"apiVersion"</span><span class="p">:</span><span class="w"> </span><span class="s2">"v1beta1"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"resources"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"capacity"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="nl">"cpu"</span><span class="p">:</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w">
          </span><span class="nl">"memory"</span><span class="p">:</span><span class="w"> </span><span class="mi">1073741824</span><span class="w">
        </span><span class="p">},</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"labels"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"my-first-k8s-node"</span><span class="p">,</span><span class="w">
      </span><span class="p">},</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span></pre></table></code></div></div><p>Kubernetes 校验Node 可用依赖于 ID。</p><ul><li>在当前的版本中，有两个接口可以用来管理Node ：<code class="language-plaintext highlighter-rouge">Node 控制</code> 和 <code class="language-plaintext highlighter-rouge">Kube 管理</code>。</ul><hr /><h4 id="node-控制">Node 控制</h4><p>在 Kubernetes 主 Node 中，<code class="language-plaintext highlighter-rouge">Node 控制器</code> 是用来管理 Node 的组件。主要包含：</p><ul><li>集群范围内 Node 同步<li>单 Node 生命周期管理</ul><p>Node 控制有一个同步轮寻，主要监听所有云平台的虚拟实例，会根据Node 状态创建和删除。</p><ul><li>可以通过 <code class="language-plaintext highlighter-rouge">--node_sync_period</code>标志来控制该轮寻。<li>如果一个实例已经创建，Node 控制将会为其创建一个结构。<li>同样的，如果一个Node 被删除，Node 控制也会删除该结构。<li>在 Kubernetes 启动时可用通过 <code class="language-plaintext highlighter-rouge">--machines</code>标记来显示指定Node 。<li>同样可以使用 <code class="language-plaintext highlighter-rouge">kubectl</code> 来一条一条的添加Node ，两者是相同的。<li>通过设置 <code class="language-plaintext highlighter-rouge">--sync_nodes=false</code>标记来禁止集群之间的Node 同步，你也可以使用 api/kubectl 命令行来增删Node 。</ul><hr /><hr /><h2 id="productiom-cluster-setup">Productiom cluster setup</h2><ul><li>multiple master and worker nodes(VM or local)</ul><hr /><h3 id="minikube">minikube</h3><blockquote><p>Virtulization / Hypervisor is needed</p></blockquote><p>to Test/local cluster setup</p><p>minikube</p><ul><li>create VM box on laptop<li>nodes runs in CM<li>master and node on one node<li>1 node K8s cluster<li>for testing</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/OCzNoKX.png" alt="Screen Shot 2022-04-05 at 12.46.15" /></p><div class="language-bash highlighter-rouge"><div class="code-header" text-data="bash"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nv">$ </span>brew <span class="nb">install </span>minikube


<span class="nv">$ </span>minikube start <span class="nt">--driver</span><span class="o">=</span>docker <span class="nt">--alsologtostderr</span>

<span class="nv">$ </span>minikube status
<span class="c"># minikube</span>
<span class="c"># type: Control Plane</span>
<span class="c"># host: Running</span>
<span class="c"># kubelet: Running</span>
<span class="c"># apiserver: Running</span>
<span class="c"># kubeconfig: Configured</span>
</pre></table></code></div></div><hr /><h3 id="kubectl-使用">kubectl 使用</h3><ul><li>wat to interact to kubernet cluster<li>API server:<ul><li>enable interaction with cluster<li>way: UI, API, CLI (<strong>kubectl</strong>)<li>worker processes do the kebectl action</ul><li><p>for both minikube and cloud cluster</p><li>kubectl 是 Kubernetes 自带的客户端，可以用它来直接操作 Kubernetes。</ul><div class="language-bash highlighter-rouge"><div class="code-header" text-data="bash"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c"># 使用格式有两种：</span>
kubectl <span class="o">[</span>flags]
kubectl <span class="o">[</span><span class="nb">command</span><span class="o">]</span>


<span class="nv">$ </span>kubectl get nodes
<span class="c"># NAME       STATUS   ROLES                  AGE   VERSION</span>
<span class="c"># minikube   Ready    control-plane,master   53s   v1.23.3</span>
<span class="nv">$ </span>kubectl get pod
<span class="nv">$ </span>kubectl get services



<span class="nv">$ </span>kubectl version
<span class="c"># Client Version: version.Info{Major:"1", Minor:"23", GitVersion:"v1.23.5", GitCommit:"c285e781331a3785a7f436042c65c5641ce8a9e9", GitTreeState:"clean", BuildDate:"2022-03-16T15:51:05Z", GoVersion:"go1.17.8", Compiler:"gc", Platform:"darwin/arm64"}</span>
<span class="c"># Server Version: version.Info{Major:"1", Minor:"23", GitVersion:"v1.23.3", GitCommit:"816c97ab8cff8a1c72eccca1026f7820e93e0d25", GitTreeState:"clean", BuildDate:"2022-01-25T21:19:12Z", GoVersion:"go1.17.6", Compiler:"gc", Platform:"linux/arm64"}</span>



</pre></table></code></div></div><hr /><h2 id="deploy">deploy</h2><p>distributed system and containers</p><ul><li>cluster is good for Stateless app</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/eBRuULA.png" alt="Screen Shot 2022-04-05 at 12.25.27" /></p><ul><li>Pod:<ul><li>not rely on one pod<li>replicate every in another node<li> <font color="red"> Deployment </font><p>:</p><ul><li>you create deployments<li>define blueprints for pod: duplicate=3</ul></ul><li><p>service is also load balancer</p><li>DB cannot be replicate<ul><li>read and write on same share data storage<li>avoid data inconsistency<li> <font color="red"> StatefulSet </font><p>for SateFul app</p><li>DB are oftern hosted outside of K8s cluster<ul><li>use external database</ul></ul></ul><h3 id="deployment">Deployment</h3><ul><li>bluepring for creating pos<li>most basic configuratiyon for deployment<li><p>rest default</p><li>Deployment<ul><li>ReplicaSet manages Pods<li>Pod is an abstraction of container<li>container</ul></ul><div class="language-bash highlighter-rouge"><div class="code-header" text-data="bash"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
</pre><td class="rouge-code"><pre><span class="nv">$ </span>kubectl create deployment NAME <span class="nt">--image</span><span class="o">=</span>image <span class="o">[</span><span class="nt">-dry-run</span><span class="o">]</span>

<span class="nv">$ </span>kubectl create deployment nginx-depl <span class="nt">--image</span><span class="o">=</span>nginx


<span class="nv">$ </span>kubectl get deployment
<span class="c"># NAME         READY   UP-TO-DATE   AVAILABLE   AGE</span>
<span class="c"># nginx-depl   1/1     1            1           36s</span>


<span class="nv">$ </span>kubectl get replicaset
<span class="c"># NAME                    DESIRED   CURRENT   READY   AGE</span>
<span class="c"># nginx-depl-5ddc44dd46   1         1         1       10m</span>


<span class="nv">$ </span>kubectl get pod
<span class="c"># NAME                          READY   STATUS    RESTARTS   AGE</span>
<span class="c"># nginx-depl-5ddc44dd46-q5cmj   1/1     Running   0          44s</span>




<span class="nv">$ </span>kubectl edit deployment nginx-depl
<span class="c"># Please edit the object below. Lines beginning with a '#' will be ignored,</span>
<span class="c"># and an empty file will abort the edit. If an error occurs while saving this file will be</span>
<span class="c"># reopened with the relevant failures.</span>
<span class="c">#</span>
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    deployment.kubernetes.io/revision: <span class="s2">"1"</span>
  creationTimestamp: <span class="s2">"2022-04-05T22:01:23Z"</span>
  generation: 1
  labels:
    app: nginx-depl
  name: nginx-depl
  namespace: default
  resourceVersion: <span class="s2">"5536"</span>
  uid: d1d87196-a2e4-44f8-b294-d27e112b37ee
spec:
  progressDeadlineSeconds: 600
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app: nginx-depl
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    <span class="nb">type</span>: RollingUpdate
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: nginx-depl
    spec:
      containers:
      - image: nginx:1.16
        imagePullPolicy: Always
        name: nginx
        resources: <span class="o">{}</span>
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: <span class="o">{}</span>
      terminationGracePeriodSeconds: 30
status:
  availableReplicas: 1
  conditions:
  - lastTransitionTime: <span class="s2">"2022-04-05T22:01:33Z"</span>
    lastUpdateTime: <span class="s2">"2022-04-05T22:01:33Z"</span>
    message: Deployment has minimum availability.
    reason: MinimumReplicasAvailable
    status: <span class="s2">"True"</span>
    <span class="nb">type</span>: Available
  - lastTransitionTime: <span class="s2">"2022-04-05T22:01:23Z"</span>
    lastUpdateTime: <span class="s2">"2022-04-05T22:01:33Z"</span>
    message: ReplicaSet <span class="s2">"nginx-depl-5ddc44dd46"</span> has successfully progressed.
    reason: NewReplicaSetAvailable
    status: <span class="s2">"True"</span>
    <span class="nb">type</span>: Progressing
  observedGeneration: 1
  readyReplicas: 1
  replicas: 1
  updatedReplicas: 1


<span class="c"># HorizontalPodAutoscalers</span>
kubectl get hpa


<span class="c"># view on workers in a cold state without any traffic.</span>
kubectl get nodes <span class="nt">-L</span> role
</pre></table></code></div></div><h3 id="statefulset">StatefulSet</h3><p>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/00basic/'>00Basic</a>, <a href='/categories/vmycontainer/'>VMyContainer</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/linux/" class="post-tag no-text-decoration" >Linux</a> <a href="/tags/vms/" class="post-tag no-text-decoration" >VMs</a> <a href="/tags/kubernetes/" class="post-tag no-text-decoration" >Kubernetes</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Virtulization - Google Kubernetes - Grace&url=https://ocholuo.github.io//posts/Kubernetes/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Virtulization - Google Kubernetes - Grace&u=https://ocholuo.github.io//posts/Kubernetes/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Virtulization - Google Kubernetes - Grace&url=https://ocholuo.github.io//posts/Kubernetes/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Amazon-CloudFront/">AWS Lab - AWS CloudFront</a><li><a href="/posts/Alexa-1stSkill/">AWS Alex First Skill - RedVelvet Time</a><li><a href="/posts/NetworkProtocol-SSL-TLS-Handshake/">NetworkProtocol SSL/TLS Handshake</a><li><a href="/posts/pythonCrash/">Python Crash</a><li><a href="/posts/%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%A7%A3%E9%87%8AAWS/">AWS - 一句话解释AWS</a><li><a href="/posts/GKE/">GCP - Google Cloud Computing - Kubernetes and Kubernetes Engine</a><li><a href="/posts/Go-Note/">Go Note</a><li><a href="/posts/SCPs/">AWS - IdenAccessManage - SCPs (Service Control Policies)</a><li><a href="/posts/CompanyBenefit/">Company Benefit</a><li><a href="/posts/Encryption-SSL&TLS/">Cryptography - SSL/TLS Encryption</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/soc/">SOC</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Container/"><div class="card-body"> <span class="timeago small" >Nov 26, 2020<i class="unloaded">2020-11-26T10:11:11-05:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Virtualization - Container</h3><div class="text-muted small"><p> Virtualization - Container basic traditional virtualization containers virtualmachine (VM)-based vs container-based deployment. ...</p></div></div></a></div><div class="card"> <a href="/posts/Docker-dev/"><div class="card-body"> <span class="timeago small" >Nov 26, 2020<i class="unloaded">2020-11-26T10:11:11-05:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Virtulization - DockerFile Develop</h3><div class="text-muted small"><p> DockerFile Develop Best practices for writing Dockerfiles General guidelines and recommendations Create ephemeral containers Understand build contex...</p></div></div></a></div><div class="card"> <a href="/posts/Docker-security/"><div class="card-body"> <span class="timeago small" >Nov 26, 2020<i class="unloaded">2020-11-26T10:11:11-05:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Virtulization - Docker security</h3><div class="text-muted small"><p> [toc] Docker security basic 评估 Docker 的安全性时，主要考虑三个方面: 由内核的命名空间和控制组机制提供的 容器内在安全 Docker 程序（特别是服务端）本身的抗攻击性 内核安全性的加强机制 对 容器安全性的影响 namespace Docker 容器和 LXC 容器很相似，所提供的安全特性也差不多。 当用 do...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Docker-security/" class="btn btn-outline-primary" prompt="Older"><p>Virtulization - Docker security</p></a> <a href="/posts/Virtualization/" class="btn btn-outline-primary" prompt="Newer"><p>Virtualization</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/ocholuo">Grace JyL</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/soc/">SOC</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://ocholuo.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script defer src="/assets/js/dist/pvreport.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-179830187-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-179830187-1'); }); </script>
