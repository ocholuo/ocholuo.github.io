<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="pv-proxy-endpoint" content="https://myochosite-291718.appspot.com/query?id=ahNwfm15b2Nob3NpdGUtMjkxNzE4chULEghBcGlRdWVyeRiAgIDo14eBCgw"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Data Structures - Basic 1 - Tree" /><meta property="og:locale" content="en" /><meta name="description" content="ref https://www.geeksforgeeks.org/binary-tree-data-structure/ DS - pythonds3 - 7. Binary Tree Data Structures and Algorithms in Java, 6th Edition.pdf" /><meta property="og:description" content="ref https://www.geeksforgeeks.org/binary-tree-data-structure/ DS - pythonds3 - 7. Binary Tree Data Structures and Algorithms in Java, 6th Edition.pdf" /><link rel="canonical" href="https://ocholuo.github.io//posts/7-Tree/" /><meta property="og:url" content="https://ocholuo.github.io//posts/7-Tree/" /><meta property="og:site_name" content="Grace" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-08-25T11:11:11-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Data Structures - Basic 1 - Tree" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-10-30T21:02:21-04:00","datePublished":"2019-08-25T11:11:11-04:00","description":"ref https://www.geeksforgeeks.org/binary-tree-data-structure/ DS - pythonds3 - 7. Binary Tree Data Structures and Algorithms in Java, 6th Edition.pdf","headline":"Data Structures - Basic 1 - Tree","mainEntityOfPage":{"@type":"WebPage","@id":"https://ocholuo.github.io//posts/7-Tree/"},"url":"https://ocholuo.github.io//posts/7-Tree/"}</script><title>Data Structures - Basic 1 - Tree | Grace</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Grace"><meta name="application-name" content="Grace"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://myochosite-291718.appspot.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://myochosite-291718.appspot.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/huoye.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Grace</a></div><div class="site-subtitle font-italic">2023 Mar 14 updated</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ocholuo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Data Structures - Basic 1 - Tree</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Data Structures - Basic 1 - Tree</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Grace JyL </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Aug 25, 2019, 11:11 AM -0400" >Aug 25, 2019<i class="unloaded">2019-08-25T11:11:11-04:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Oct 30, 2022, 6:02 PM -0700" >Oct 30, 2022<i class="unloaded">2022-10-30T21:02:21-04:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="18125 words">100 min read</span> <span id="pv" class="pageviews"> <i class="fas fa-spinner fa-spin fa-fw"></i> </span> views</div></div><div class="post-content"><ul><li>ref<ul><li>https://www.geeksforgeeks.org/binary-tree-data-structure/<li>DS - pythonds3 - 7. Binary Tree<li>Data Structures and Algorithms in Java, 6th Edition.pdf</ul></ul><hr /><h1 id="data-structures---basic-1---data-structures-tree">Data Structures - Basic 1 - Data Structures Tree</h1><h2 id="type">Type</h2><ul><li><code class="language-plaintext highlighter-rouge">Binary Search Tree(BST)</code>：<ul><li>在某些資料經常要增加、刪除的應用中，BST常用來做搜尋，<li>例如許多程式語言的Library中的map和set。</ul><li><code class="language-plaintext highlighter-rouge">Binary Space Partition</code>：<ul><li>應用於幾乎所有的3D電玩遊戲以決定哪些物件需要rendered。</ul><li><code class="language-plaintext highlighter-rouge">Binary Tries</code>：<ul><li>應用於大多數high-bandwidth router(高頻寬路由器)以儲存router-tables。</ul><li><code class="language-plaintext highlighter-rouge">Heaps</code>：<ul><li>用以實現高效率的<code class="language-plaintext highlighter-rouge">priority queues</code>(優先權佇列)<li>許多作業系統用來安排工作程序。</ul><li><code class="language-plaintext highlighter-rouge">Huffman Coding Tree</code>：<ul><li>例如.jpeg、.mp3等壓縮技術皆使用Huffman編碼。<li>(在一顆20MB的硬碟要價新台幣一萬元的時代，壓縮技術就是救世主。)</ul></ul><hr /><h3 id="prefix-tree-trie">Prefix tree, Trie</h3><ul><li>sometimes called a <code class="language-plaintext highlighter-rouge">radix</code> or <code class="language-plaintext highlighter-rouge">prefix tree</code><li>a kind of search tree that is used to store a <strong>dynamic set or associative array where the keys are usually Strings</strong><li>No node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated.<li>All the descendants of a node have a common prefix of the String associated with that node, and the root is associated with the empty String.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/6kgTJu4.png" alt="radix-tree" /></p><hr /><h3 id="binary-indexed-tree-fenwick-tree">Binary indexed tree, Fenwick Tree</h3><ul><li>sometimes called a <code class="language-plaintext highlighter-rouge">binary indexed tree</code>,<li><p>is a tree in concept, but in practice is implemented as an implicit data structure using an array.</p><li>Given an index in the array representing a vertex<ul><li>the <code class="language-plaintext highlighter-rouge">index of a vertex's parent or child</code> is calculated through bitwise operations 按位运算 on the binary representation of its index.<li>Each element of the array contains the <code class="language-plaintext highlighter-rouge">pre-calculated sum of a range of values</code>,<li>and by combining that sum with additional ranges encountered during an <code class="language-plaintext highlighter-rouge">upward traversal to the root</code>, the prefix sum is calculated</ul><li><p>a data structure that can efficiently update elements and calculate prefix sums in a table of numbers.</p><li>Time Complexity:<ul><li>Range Sum: <code class="language-plaintext highlighter-rouge">O(log(n))</code><li>Update: <code class="language-plaintext highlighter-rouge">O(log(n))</code></ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/LSXqclh.png" alt="Screen Shot 2021-10-25 at 5.34.40 PM" /></p><hr /><h3 id="segment-tree">Segment Tree</h3><ul><li>a tree data structure for <code class="language-plaintext highlighter-rouge">storing intervals/segments</code>.<li>It allows querying which of the stored segments contain a given point.</ul><p><strong>Time Complexity</strong></p><ul><li>Range Query: O(log(n))<li>Update: O(log(n))</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/e3RxsAq.png" alt="segmentTree" /></p><hr /><h3 id="heap">Heap</h3><ul><li>a specialized tree based structure data structure that satisfies the heap property:<ul><li>if A is a parent node of B,<li>then the key (the value) of node A is ordered with respect to the key of node B with the <code class="language-plaintext highlighter-rouge">same ordering applying across the entire heap</code>.</ul><li>A heap can be classified further as either a “max heap” or a “min heap”.<ul><li>In a max heap,<ul><li>the keys of parent nodes are always greater than or equal to those of the children and the highest key is in the root node.</ul><li>In a min heap,<ul><li>the keys of parent nodes are less than or equal to those of the children and the lowest key is in the root node</ul></ul></ul><p><strong>Time Complexity</strong>:</p><ul><li>Access Max / Min: O(1)<li>Insert: O(log(n))<li>Remove Max / Min: O(log(n))</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/IdkxQbi.png" alt="heap" /></p><hr /><h2 id="basic">basic</h2><blockquote><p>The difference between a tree in nature and a tree in computer science a tree data structure has its root at the top and its leaves on the bottom.</p></blockquote><p>若熟悉<code class="language-plaintext highlighter-rouge">Linked List</code>(連結串列)將會更容易理解樹：</p><ul><li><code class="language-plaintext highlighter-rouge">Linked list</code>是 <strong>一維的線性結構(不是往前、就是往後)</strong><li>樹(與Graph)則推廣成<strong>多維的結構</strong>。</ul><p>linkedlist</p><p><img data-proofer-ignore data-src="https://i.imgur.com/mLBAp4m.png" alt="f1" /></p><ul><li>A、B、C、D稱為node(節點)，用以代表資料(data)、狀態(state)。<li>連結各個node之間的連結(link)稱為edge，可能是單方向，或者雙向。</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/smmCuJG.png" alt="Screen Shot 2021-09-30 at 10.40.39 PM" /></p><p>A Tree is an <strong>undirected, connected, acyclic</strong> graph</p><ul><li><p>无向的、连通的、无环图</p><li>the most important <strong>nonlinear data structures</strong><li>an organizational relationship that is richer than the simple “before” and “after” relationships between objects in sequences.</ul><hr /><h2 id="properties">properties</h2><hr /><h3 id="properties-of-trees">properties of trees</h3><p><strong>Tree(樹)</strong></p><ul><li>由一個或多個節點所組成的有限集合，<li>並且滿足：<ul><li>存在且只有一個稱為root(樹根)的節點；<li>其餘的節點可以分割成任意正整數個(包含零個)互斥(disjoint)的集合：T1、…、Tn，其中每一個集合也都滿足樹的定義，這些集合又稱為這棵樹的subtree(子樹)。<li>Tree(樹)是由一個或多個nodes/vertices以及edge所組成，而且沒有cycle的集合(set)。</ul><li>在樹的結構裡，<code class="language-plaintext highlighter-rouge">只有一個root(樹根)</code>，<code class="language-plaintext highlighter-rouge">並且不存在cycle</code>。<li>此特徵將衍生出另外兩項等價的性質：<ul><li>在樹中若要從root尋找特定node，一定只存在一條路徑(path)。<li>每個node只會有一個parent。</ul></ul><p><strong>Forest(樹林)</strong></p><ul><li>由n≥0棵彼此互斥(disjoint)的Tree(樹)所形成的集合(Set)，即稱為Forest(樹林)。<li>Forest(樹林)由多個Tree(樹)所組成，可以用來表示互斥集合(disjoint set)。</ul><p>Trees provide a natural organization for data, and consequently have become ubiquitous structures in</p><ul><li>file systems,<li>graphical user interfaces,<li>databases, websites,<li>and many other computer systems.</ul><p>Main applications of trees include:</p><ol><li>Manipulate <code class="language-plaintext highlighter-rouge">hierarchical</code> data.<li>Make information easy to <code class="language-plaintext highlighter-rouge">search</code> (see tree traversal).<li>Manipulate <code class="language-plaintext highlighter-rouge">sorted lists</code> of data.<li>As a workflow for <code class="language-plaintext highlighter-rouge">compositing digital images for visual</code> effects.<li><code class="language-plaintext highlighter-rouge">Router</code> algorithms<li><p>Form of a <code class="language-plaintext highlighter-rouge">multi-stage decision-making</code> (see business chess).</p><li>A tree is an abstract data type that stores elements hierarchically. With the exception of the top element, each element in a tree has a <code class="language-plaintext highlighter-rouge">parent</code> element and zero or more <code class="language-plaintext highlighter-rouge">children</code> elements.<li>to store information that naturally forms a <code class="language-plaintext highlighter-rouge">hierarchy</code>.<li>Trees provide <strong>moderate access/search</strong> (quicker than Linked List and slower than arrays).<li>Trees provide <strong>moderate insertion/deletion</strong> (quicker than Arrays and slower than Unordered Linked Lists).<li>Like Linked Lists and unlike Arrays<ol><li>Trees dont have an upper limit on number of nodes as nodes are linked using pointers.</ol></ol><p>define a tree T as <code class="language-plaintext highlighter-rouge">a set of nodes</code> storing elements such that the nodes have a parent-child relationship that satisfies the following properties:</p><ul><li>If T is nonempty, it has a special node, called the root of T, that has no parent.<li>Each node v of T different from the root has a unique parent node w; every node with parent w is a child of w.<li>a tree can be empty, meaning that it does not have any nodes.<li>Two nodes that are children of the same <code class="language-plaintext highlighter-rouge">parent</code> are <code class="language-plaintext highlighter-rouge">siblings</code>.<li>A node v is <strong>external</strong> if v has no children.<ul><li>External nodes are also known as <code class="language-plaintext highlighter-rouge">leaves</code>.</ul><li>A node v is <strong>internal</strong> if it has one or more children.</ul><ol><li>用以描述具有<code class="language-plaintext highlighter-rouge">階層結構(hierarchical structure)</code>的問題的首選，<ul><li>階層結構意味著明確的先後次序，<li>例如，若要印出ABC三個字母的所有排列組合(permutation)<li>trees are structured in layers<ul><li>the more general things near the top<li>and the more specific things near the bottom.</ul></ul><li>all of the children of one node are independent of the children of another node.<ul><li>we can change the node without affecting other child node.</ul><li>each leaf node is unique.<ul><li>can follow a path from the root to any directory.<li>That path will uniquely identify that subdirectory (and all the files in it).</ul><li>can move entire sections of a tree (called a subtree) to a different position in the tree without affecting the lower levels of the hierarchy.<ul><li>derived from their hierarchical nature</ul><li><strong>Edges and Paths in Trees</strong><ul><li>An edge of tree T is a pair of <code class="language-plaintext highlighter-rouge">nodes (u,v)</code><li>u is the parent of v, or vice versa.<li>A path of T is a sequence of nodes such that any two consecutive nodes in the sequence form an edge.</ul></ol><hr /><h3 id="ordered-trees">Ordered Trees</h3><p>A tree is ordered if there is a meaningful linear order among the children of each node;</p><ul><li>purposefully identify the children of a node as being the first, second, third, and so on.<li>Such an order is usually visualized by arranging siblings left to right, according to their order.</ul><hr /><h3 id="properties-or-binary-tree">Properties or Binary tree</h3><ol><li>The maximum number of nodes at level <code class="language-plaintext highlighter-rouge">l</code>: <code class="language-plaintext highlighter-rouge">2^l</code><ul><li>level is number of nodes on path from root to the node (including root and node).<li>Level of root is 0, number of nodes = 2^0 = 1</ul><li>Maximum number of nodes in a binary tree of height <code class="language-plaintext highlighter-rouge">h</code>: <code class="language-plaintext highlighter-rouge">2^h – 1</code>.<ul><li>height of a tree is maximum number of nodes on root to leaf path.<li>Height of a tree with single node is considered as 1.<li>In some books, height of the root is considered as 0. In this convention, the above formula becomes 2h+1 – 1</ul><li>In a Binary Tree with <code class="language-plaintext highlighter-rouge">N</code> nodes, minimum possible height or minimum number of levels: <code class="language-plaintext highlighter-rouge">Log2(N+1)</code><ul><li>This can be directly derived from point 2 above.<li>If we consider the height of a leaf node is considered as 0, then above formula for minimum possible height becomes ? Log2(N+1) ? – 1</ul><li><p>A Binary Tree with L leaves has at least: <code class="language-plaintext highlighter-rouge">Log2L ? + 1</code> levels A Binary tree has maximum number of leaves (and minimum number of levels) when all levels are fully filled. Let all leaves be at level l, then below is true for number of leaves L.</p><p>L &lt;= 2l-1 [From Point 1] l = ? Log2L ? + 1 where l is the minimum number of levels.</p></ol><p>5) In Binary tree where every node has 0 or 2 children, number of leaf nodes is always one more than nodes with two children.</p><hr /><h3 id="樹的元素">樹的元素</h3><p>針對node / vertex：</p><p><img data-proofer-ignore data-src="https://i.imgur.com/EVshcEh.png" alt="f9" /></p><ul><li><code class="language-plaintext highlighter-rouge">degree</code>(分歧度)：<ul><li>一個node擁有的subtree(子樹)的個數。<li>A的degree為3，F的degree為2，N的degree為0。</ul><li><code class="language-plaintext highlighter-rouge">root</code>(樹根)：<ul><li>樹中最上層的node，也是唯一一個其parent為NULL的node。<li>A即為root。</ul><li><code class="language-plaintext highlighter-rouge">external node/leaf</code>：<ul><li>沒有child/subtree的node。<li>G、H、J、K、L、M、N皆為leaf node。</ul><li><code class="language-plaintext highlighter-rouge">internal node</code>：<ul><li>至少有一個child的node。<li>A、B、C、D、E、F、I皆為internal node。</ul><li><code class="language-plaintext highlighter-rouge">parent &lt;--&gt; child</code>：<ul><li>以pointer說明，被指向者(pointed)為child，指向者(point to)為parent。</ul><li><code class="language-plaintext highlighter-rouge">siblings：擁有相同parent的node們，互相稱兄道弟。</code><ul><li>B、C、D共同的parent為A，B、C、D即為彼此的sibling。</ul><li><code class="language-plaintext highlighter-rouge">descendant</code>(子嗣)：<ul><li>站在A，所有能夠以「parent指向child」的方式找到的node，皆稱為A的descendant，因此整棵樹除了A以外皆為A的descendant。<li>在F，能夠以「parent指向child」找到的node有L、M，則稱L、M為F的descendant。</ul><li><code class="language-plaintext highlighter-rouge">ancestor</code>(祖先)：<ul><li>圖四中，站在K，所有能夠以「尋找parent」的方式找到的node，皆稱為K的ancestor，因此，E、B、A皆為K的ancestor。</ul><li><code class="language-plaintext highlighter-rouge">path</code>(路徑)：<ul><li>由descendant與ancestor關係連結成的<code class="language-plaintext highlighter-rouge">edge</code>，例如A-B-E-K、A-C-F-N。</ul><li><code class="language-plaintext highlighter-rouge">level</code>： root-2-3-4<ul><li>定義root的level為1，其餘node的level為其parent的level加一。</ul><li><code class="language-plaintext highlighter-rouge">height of node</code>：<ul><li>某一node與其最長path上之descendant leaf node之間的edge數。<li>例如，F的height為1，D的height為2，leaf node的height為0。</ul><li><code class="language-plaintext highlighter-rouge">height of tree</code>：樹的height即為root的height。<ul><li>樹的height為A的height，等於3。</ul><li><code class="language-plaintext highlighter-rouge">depth</code>：<ul><li>某一node與root之間的edge數。<li>例如，F的depth為2，L的depth為3。</ul></ul><p>在樹中的traversal(尋訪)之時間複雜度(time complexity)會與height(樹高)有關。</p><hr /><h3 id="集合關係">集合關係</h3><p>Tree(樹)位居承先啟後的重要戰略位置，資料結構之集合關係圖：</p><p><img data-proofer-ignore data-src="https://i.imgur.com/xqAyRXN.png" alt="f11" /></p><p>本篇介紹的Tree(樹)並沒有限制child/ subtree的個數</p><ul><li>理論上可以有多到超過記憶體空間的child node。<ul><li><img data-proofer-ignore data-src="https://i.imgur.com/wt3t5d0.png" alt="f1-1" /></ul><li>然而在實務上，較常使用每個node至多只有兩個child的樹，為<code class="language-plaintext highlighter-rouge">Binary Tree(二元樹)</code>。<ul><li><img data-proofer-ignore data-src="https://i.imgur.com/ngahlhP.png" alt="f2" /><li>樹上的每一個node之degree皆為2<li>並稱兩個child pointer為left child和right child。</ul><li>從Binary Tree再增加「鍵值(Key)大小規則」，即<code class="language-plaintext highlighter-rouge">Binary Search Tree(BST，二元搜尋樹)</code>。<li>以BST為基礎，在每個node上添加顏色(紅與黑)用以平衡樹的height，以減短搜尋時間，這種樹稱為<code class="language-plaintext highlighter-rouge">Red Black Tree(RBT，紅黑樹)</code>。<li>常見的平衡樹(balanced tree)還有：AVL tree、2-3-4 tree、Splay tree等等，請參考：Wikipedia：Self-balancing binary search tree<li>另一個方向，若打破「不能存在cycle」的限制，則從Tree推廣至圖(Graph)。</ul><hr /><h2 id="tree-interface">Tree <strong>Interface</strong></h2><h3 id="tree-abstract-data-type">Tree Abstract Data Type</h3><ul><li>define a tree ADT using the concept of a position as an abstraction for a node of a tree.<li>An element is stored at each position,<li>and positions satisfy parent-child relationships that define the tree structure.</ul><p>A <strong>position</strong> object for a tree supports the method:</p><ul><li><code class="language-plaintext highlighter-rouge">getElement()</code>: Returns the element stored at this position.</ul><p><strong>accessor methods</strong>, allowing a user to navigate the various positions of a tree T :</p><ul><li><p><code class="language-plaintext highlighter-rouge">root()</code>: Returns the position of the root of the tree (or null if empty).</p><li><p><code class="language-plaintext highlighter-rouge">parent(p)</code>: Returns the position of the parent of position p (or null if p is the root).</p><li><p><code class="language-plaintext highlighter-rouge">children(p)</code>: Returns an iterable collection containing the children of position p (if any).</p><li><p><code class="language-plaintext highlighter-rouge">numChildren(p)</code>: Returns the number of children of position p.</p></ul><p><strong>query methods</strong>:</p><ul><li><code class="language-plaintext highlighter-rouge">isInternal(p)</code>: Returns true if position p has at least one child.<li><code class="language-plaintext highlighter-rouge">isExternal(p)</code>: Returns true if position p does not have any children.<li><code class="language-plaintext highlighter-rouge">isRoot(p)</code>: Returns true if position p is the root of the tree.</ul><p><strong>general methods</strong>, unrelated to the specific structure of the tree. These incude:</p><ul><li><p><code class="language-plaintext highlighter-rouge">size()</code>: Returns the number of positions (and hence elements) that are contained in the tree.</p><li><p><code class="language-plaintext highlighter-rouge">isEmpty()</code>: Returns true if the tree does not contain any positions (and thus no elements).</p><li><p><code class="language-plaintext highlighter-rouge">iterator()</code>: Returns an iterator for all elements in the tree (so that the tree itself is Iterable).</p><li><p><code class="language-plaintext highlighter-rouge">positions()</code>: Returns an iterable collection of all positions of the tree.</p></ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Tree</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">root</span><span class="o">();</span>
    <span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">parent</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalStateException</span><span class="o">;</span>
    <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="nf">children</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalStateException</span><span class="o">;</span>

    <span class="kt">int</span> <span class="nf">numChildren</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalStateException</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="nf">isInternal</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalStateException</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="nf">isExternal</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalStateException</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="nf">isRoot</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalStateException</span><span class="o">;</span>

    <span class="kt">int</span> <span class="nf">size</span><span class="o">();</span>
    <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">();</span>

    <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">();</span>
    <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="nf">positions</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="abstracttree-class">AbstractTree <strong>class</strong></h3><ul><li>define an AbstractTree base class,<li>demonstrating how many tree-based algorithms can be described independently of the low-level representation of a tree data structure.<li>In fact, if a concrete implementation provides three fundamental methods—root(), parent(p), and children(p)— all other behaviors of the Tree interface can be derived within the AbstractTree base class.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// /∗∗ An abstract base class providing some functionality of the Tree interface. ∗/</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractTree</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Tree</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isInternal</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">numChildren</span><span class="o">(</span><span class="n">p</span><span class="o">)&gt;</span><span class="mi">0</span><span class="o">;}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isExternal</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">numChildren</span><span class="o">(</span><span class="n">p</span><span class="o">)&lt;</span><span class="mi">0</span><span class="o">;}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isRoot</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">p</span><span class="o">==</span><span class="n">root</span><span class="o">();}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">(){</span><span class="k">return</span> <span class="n">size</span><span class="o">()==</span><span class="mi">0</span><span class="o">;}</span>

    <span class="c1">// ∗ Returns the number of levels separating Position p from the root. ∗/</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">depth</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isRoot</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">depth</span><span class="o">(</span><span class="n">parent</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">heightBad</span><span class="o">(){</span>
        <span class="kt">int</span> <span class="n">h</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nl">p:</span> <span class="n">positions</span><span class="o">())</span> <span class="n">h</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">depth</span><span class="o">(</span><span class="n">p</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">height</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">h</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nl">c:</span> <span class="n">children</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="n">h</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">height</span><span class="o">(</span><span class="n">c</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Computing Depth and Height</strong></p><ul><li>Let p be a position within tree T.</ul><p><strong>Depth</strong></p><ul><li><code class="language-plaintext highlighter-rouge">The depth of p</code> can be recursively defined:<ul><li>If p is the root, then the depth of p is 0.<li>Otherwise, the depth of p is one plus the depth of the parent of p.</ul></ul><blockquote><p>The running time of depth(p) for position p is O(dp +1), where dp denotes the depth of p in the tree, because the algorithm performs a constant-time recursive step for each ancestor of p. Thus, algorithm depth(p) runs in O(n) worst-case time, where n is the total number of positions of T , because a position of T may have depth n − 1 if all nodes form a single branch. Although such a running time is a function of the input size, it is more informative to characterize the running time in terms of the parameter dp, as this parameter may be much smaller than n.</p></blockquote><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// ∗ Returns the number of levels separating Position p from the root. ∗/</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">depth</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span><span class="o">(</span><span class="n">isRoot</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">return</span> <span class="nf">depth</span><span class="o">(</span><span class="n">parent</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Height</strong></p><ul><li><p>the height of a tree to be equal to the maximum of the depths of its positions (or zero, if the tree is empty).</p><li><p><code class="language-plaintext highlighter-rouge">heightBad</code>:</p><ul><li>a method that computes the height of a tree based on this definition.<li>not very efficient, declare it as a private method of the AbstractTree class (so that it cannot be used by others).<li>positions() iteration runs in <code class="language-plaintext highlighter-rouge">O(n)</code> time, where n is the number of positions of T.<li>algorithm heightBad runs in <code class="language-plaintext highlighter-rouge">O(n^2)</code> worst-case time.</ul></ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">int</span> <span class="nf">heightBad</span><span class="o">(){</span>
    <span class="kt">int</span> <span class="n">h</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nl">p:</span> <span class="n">positions</span><span class="o">())</span> <span class="n">h</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">depth</span><span class="o">(</span><span class="n">p</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">height</code>:<ul><li>O(n) worst-case time,<li>The algorithm is recursive, and it progresses in a top-down fashion.<li>If the method is initially called on the root of T , it will eventually be called once for each position of T. This is because the root eventually invokes the recursion on each of its children, which in turn invokes the recursion on each of their children, and so on.</ul></ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">int</span> <span class="nf">height</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">h</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nl">p:</span> <span class="n">children</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="n">h</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">height</span><span class="o">(</span><span class="n">c</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="binary-tree-interface">Binary Tree <strong>interface</strong></h2><ul><li>A binary tree is an ordered tree with the following properties:<ul><li>a tree data structure in which <code class="language-plaintext highlighter-rouge">each node has at most two children</code><li>referred to as the left child and right child<li>A left child precedes a right child in the order of children of a node.</ul><li><p>The subtree rooted at a left or right child of an internal node v is called a left subtree or right subtree, respectively, of v.</p><li>Full Tree <strong>proper</strong>:<ul><li>every node has either 0 or 2 children<li>A binary tree that is not proper is improper.</ul><li>Perfect Binary Tree:<ul><li>all nodes have two children<li>and all leave have the same depth</ul><li>Complete Tree:<ul><li>every level except possibly the last is full<li>and all nodes in the last level are <code class="language-plaintext highlighter-rouge">as far left</code> as possible</ul></ul><p>以程式碼實作一棵樹，常用的手法為：先以<code class="language-plaintext highlighter-rouge">class TreeNode</code>(或是struct)定義出每顆node能夠指向多少subtree、攜帶哪些資料形態，再以另一個class Tree表示整棵樹，並以root作為樹的存取點：</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BinaryTree</span> <span class="o">{</span>

    <span class="c1">// 根节点</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">TreeNode</span> <span class="n">root</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">BinaryTree</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><hr /><h4 id="binary-tree-abstract-data-type">Binary Tree Abstract Data Type</h4><ol><li>Defining a BinaryTree Interface<ol><li>This interface extends the Tree interface to add the three new behaviors.<li>a binary tree is expected to support all the functionality that was defined for general trees (e.g., root, isExternal, parent), and the new behaviors left, right, and sibling.</ol><li>Defining an AbstractBinaryTree Base Class<ol><li>use abstract base classes to promote greater reusability within our code. The AbstractBinaryTree class inherits from the AbstractTree class<li>It provides additional concrete methods that can be derived from the newly declared left and right methods (which remain abstract).</ol></ol><hr /><h4 id="abstractbinarytree-class">AbstractBinaryTree <strong>class</strong></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AbstractBinaryTree</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractTree</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">BinaryTree</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">sibling</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">){</span>
        <span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parent</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">==</span><span class="n">left</span><span class="o">(</span><span class="n">parent</span><span class="o">))</span> <span class="k">return</span> <span class="n">right</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="k">else</span> <span class="k">return</span> <span class="nf">left</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numChildren</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">(</span><span class="n">p</span><span class="o">)!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">count</span><span class="o">++;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">(</span><span class="n">p</span><span class="o">)!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">count</span><span class="o">++;</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="nf">children</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">){</span>
        <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="mi">2</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">(</span><span class="n">p</span><span class="o">)!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">snapshot</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">left</span><span class="o">(</span><span class="n">p</span><span class="o">));</span>
        <span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">(</span><span class="n">p</span><span class="o">)!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">snapshot</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">right</span><span class="o">(</span><span class="n">p</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">snapshot</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>

</pre></table></code></div></div><hr /><h5 id="tree-in-java2">Tree in java2</h5><p>Binary Tree: A tree whose elements have at most 2 children is called a binary tree. Since each element in a binary tree can have only 2 children, we typically name them the left and right child.</p><p>Summary: Tree is a hierarchical data structure. Main uses of trees include maintaining hierarchical data, providing moderate access and insert/delete operations. Binary trees are special cases of tree where every node has at most two children.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre><span class="cm">/* Class containing left and right child of current node and key value*/</span>

<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">key</span><span class="o">;</span>
	<span class="nc">Node</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>


<span class="kd">class</span> <span class="nc">BinaryTree</span> <span class="o">{</span>
	<span class="c1">// Root of Binary Tree</span>
	<span class="nc">Node</span> <span class="n">root</span><span class="o">;</span>

	<span class="c1">// Constructors</span>
	<span class="nc">BinaryTree</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="nc">BinaryTree</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span>


  <span class="c1">// create a simple tree with 4 nodes</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

		<span class="nc">BinaryTree</span> <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BinaryTree</span><span class="o">();</span>

		<span class="cm">/*create root*/</span>
		<span class="n">tree</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

		<span class="cm">/* following is the tree after above statement
			1
			/ \
		null null	 */</span>

		<span class="n">tree</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
		<span class="n">tree</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>

		<span class="cm">/* 2 and 3 become left and right children of 1
			1
			/ \
			2	 3
		/ \ / \
		null null null null */</span>


		<span class="n">tree</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
		<span class="cm">/* 4 becomes left child of 2
					1
				/	 \
			2		 3
			/ \	 / \
			4 null null null
		/ \
		null null
		*/</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h5 id="tree-in-python1">Tree in python1</h5><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre><td class="rouge-code"><pre><span class="n">myTree</span> <span class="o">=</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span>
         <span class="p">[</span><span class="s">'b'</span><span class="p">,</span> <span class="p">[</span><span class="s">'d'</span><span class="p">,[],[]],</span> <span class="p">[</span><span class="s">'e'</span><span class="p">,[],[]]</span> <span class="p">],</span>
         <span class="p">[</span><span class="s">'c'</span><span class="p">,</span> <span class="p">[</span><span class="s">'f'</span><span class="p">,[],[]],</span> <span class="p">[]]</span> <span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="n">myTree</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">'left subtree = '</span><span class="p">,</span> <span class="n">myTree</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="s">'root = '</span><span class="p">,</span> <span class="n">myTree</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="s">'right subtree = '</span><span class="p">,</span> <span class="n">myTree</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>


<span class="c1"># The BinaryTree function simply constructs a list with a root node and two empty sublists for the children.
</span><span class="k">def</span> <span class="nf">BinaryTree</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]]</span>


<span class="c1"># To add a left subtree to the root of a tree, insert a new list into the second position of the root list.
# If the list already has something in the second position, we need to keep track of it and push it down the tree as the left child of the list we are adding.
</span><span class="k">def</span> <span class="nf">insertLeft</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">newBranch</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">root</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span> <span class="n">newBranch</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="p">[]</span> <span class="p">]</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">root</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span> <span class="n">newBranch</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]</span> <span class="p">]</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">root</span>
<span class="c1"># Notice that to insert a left child, we first obtain the (possibly empty) list that corresponds to the current left child. We then add the new left child, installing the old left child as the left child of the new one. This allows us to splice a new node into the tree at any position.
</span>

<span class="k">def</span> <span class="nf">insertRight</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">newBranch</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">root</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,[</span><span class="n">newBranch</span><span class="p">,[],</span><span class="n">t</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">root</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,[</span><span class="n">newBranch</span><span class="p">,[],[]])</span>
    <span class="k">return</span> <span class="n">root</span>


<span class="k">def</span> <span class="nf">getRootVal</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">setRootVal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">newVal</span><span class="p">):</span>
    <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">newVal</span>

<span class="k">def</span> <span class="nf">getLeftChild</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">getRightChild</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>


<span class="n">r</span> <span class="o">=</span> <span class="nc">BinaryTree</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nf">insertLeft</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="nf">insertLeft</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="nf">insertRight</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="nf">insertRight</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="n">l</span> <span class="o">=</span> <span class="nf">getLeftChild</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

<span class="nf">setRootVal</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="nf">insertLeft</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">getRightChild</span><span class="p">(</span><span class="nf">getRightChild</span><span class="p">(</span><span class="n">r</span><span class="p">)))</span>

<span class="kn">from</span> <span class="n">test</span> <span class="kn">import</span> <span class="n">testEqual</span>

<span class="k">def</span> <span class="nf">buildTree</span><span class="p">():</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nc">BinaryTree</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="nf">insertRight</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="s">'c'</span><span class="p">)</span>
    <span class="nf">insertLeft</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="s">'c'</span><span class="p">)</span>
    <span class="n">one_left</span> <span class="o">=</span> <span class="nf">getLeftChild</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="nf">insertRight</span><span class="p">(</span><span class="n">one_left</span><span class="p">,</span><span class="s">'d'</span><span class="p">)</span>
    <span class="n">one_right</span> <span class="o">=</span> <span class="nf">getRightChild</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="nf">insertRight</span><span class="p">(</span><span class="n">one_right</span><span class="p">,</span><span class="s">'f'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>

<span class="n">ttree</span> <span class="o">=</span> <span class="nf">buildTree</span><span class="p">()</span>
<span class="nf">testEqual</span><span class="p">(</span><span class="nf">getRootVal</span><span class="p">(</span><span class="nf">getRightChild</span><span class="p">(</span><span class="n">ttree</span><span class="p">)),</span><span class="s">'c'</span><span class="p">)</span>
<span class="nf">testEqual</span><span class="p">(</span><span class="nf">getRootVal</span><span class="p">(</span><span class="nf">getRightChild</span><span class="p">(</span><span class="nf">getLeftChild</span><span class="p">(</span><span class="n">ttree</span><span class="p">))),</span><span class="s">'d'</span><span class="p">)</span>
<span class="nf">testEqual</span><span class="p">(</span><span class="nf">getRootVal</span><span class="p">(</span><span class="nf">getRightChild</span><span class="p">(</span><span class="nf">getRightChild</span><span class="p">(</span><span class="n">ttree</span><span class="p">))),</span><span class="s">'f'</span><span class="p">)</span>

</pre></table></code></div></div><hr /><h5 id="tree-in-python-2---using-nodes-and-references">Tree in python 2 - Using nodes and references</h5><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">rootObj</span><span class="p">):</span>
    <span class="n">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">rootObj</span>
    <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="bp">None</span>

  <span class="k">def</span> <span class="nf">insertLeft</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">newNode</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="nc">BinaryTree</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># a node with an existing left child. In the second case, we insert a node and push the existing child down one level in the tree.
</span>      <span class="n">t</span> <span class="o">=</span> <span class="nc">BinaryTree</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
      <span class="n">t</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span>
      <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">t</span>

  <span class="k">def</span> <span class="nf">insertRight</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">newNode</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="nc">BinaryTree</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">t</span> <span class="o">=</span> <span class="nc">BinaryTree</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
      <span class="n">t</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span>
      <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">t</span>

  <span class="k">def</span> <span class="nf">getRightChild</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span>

  <span class="k">def</span> <span class="nf">getLeftChild</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span>

  <span class="k">def</span> <span class="nf">setRootVal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">obj</span><span class="p">):</span>
    <span class="n">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">obj</span>

  <span class="k">def</span> <span class="nf">getRootVal</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">key</span>


<span class="n">r</span> <span class="o">=</span> <span class="nc">BinaryTree</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="nf">getRootVal</span><span class="p">())</span>
<span class="nf">print</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="nf">getLeftChild</span><span class="p">())</span>
<span class="n">r</span><span class="p">.</span><span class="nf">insertLeft</span><span class="p">(</span><span class="s">'b'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="nf">getLeftChild</span><span class="p">())</span>
<span class="nf">print</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="nf">getLeftChild</span><span class="p">().</span><span class="nf">getRootVal</span><span class="p">())</span>
<span class="n">r</span><span class="p">.</span><span class="nf">insertRight</span><span class="p">(</span><span class="s">'c'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="nf">getRightChild</span><span class="p">())</span>
<span class="nf">print</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="nf">getRightChild</span><span class="p">().</span><span class="nf">getRootVal</span><span class="p">())</span>
<span class="n">r</span><span class="p">.</span><span class="nf">getRightChild</span><span class="p">().</span><span class="nf">setRootVal</span><span class="p">(</span><span class="s">'hello'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="nf">getRightChild</span><span class="p">().</span><span class="nf">getRootVal</span><span class="p">())</span>

</pre></table></code></div></div><hr /><h5 id="relating-internal-nodes-to-external-nodes-in-a-proper-binary-tree">Relating Internal Nodes to External Nodes in a Proper Binary Tree</h5><p>In a nonempty proper binary tree T</p><ul><li>with nE external nodes and nI internal nodes, we have nE = nI + 1.</ul><blockquote><p>the above relationship does not hold, in general, for improper binary trees and nonbinary trees, although there are other interesting relationships that do hold.</p></blockquote><hr /><h3 id="implementing-trees">Implementing Trees</h3><hr /><h4 id="linked-binary-tree-structure-class-linked-structure-for-binary-trees">Linked Binary Tree Structure <strong>class</strong> (Linked Structure for Binary Trees)</h4><ul><li>A natural way to realize a binary tree T is to use a linked structure, with a node that maintains references to the <code class="language-plaintext highlighter-rouge">element stored at a position p</code> and to the <code class="language-plaintext highlighter-rouge">nodes associated with the children and parent of p</code>.<li>If p is the root of T, then the parent field of p is null.<li>if p does not have a left child (respectively, right child), the associated field is null.<li>The tree itself<ul><li>maintains an instance variable storing a reference to the root node (if any),<li>and a variable size, that represents the overall number of nodes of T.</ul></ul><p><strong>Operations for Updating a Linked Binary Tree</strong></p><ul><li><code class="language-plaintext highlighter-rouge">addRoot(e):</code><li><code class="language-plaintext highlighter-rouge">addLeft(p, e):</code><li><code class="language-plaintext highlighter-rouge">addRight(p, e):</code><li><code class="language-plaintext highlighter-rouge">set(p, e): </code><li><code class="language-plaintext highlighter-rouge">attach(p, T1, T2):</code><li><p><code class="language-plaintext highlighter-rouge">remove(p):</code></p><li><code class="language-plaintext highlighter-rouge">size, isEmpty</code>: O(1)<li><code class="language-plaintext highlighter-rouge">root, parent, left, right, sibling, children, numChildren</code>: O(1)<li><code class="language-plaintext highlighter-rouge">isInternal, isExternal, isRoot</code>: O(1)<li><code class="language-plaintext highlighter-rouge">addRoot, addLeft, addRight, set, attach, remove</code>: O(1)<li><code class="language-plaintext highlighter-rouge">depth( p)</code>: O(dp +1)<li><code class="language-plaintext highlighter-rouge">height</code>: O(n)</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">tree</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">list.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinkedBinaryTree</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractBinaryTree</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">//---------------- nested Node class ----------------</span>
    <span class="kd">protected</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;{</span>
        <span class="kd">private</span> <span class="no">E</span> <span class="n">element</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">parent</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">left</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">right</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">above</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">leftChild</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">rightChild</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">above</span><span class="o">;</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">leftChild</span><span class="o">;</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">rightChild</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// accessor methods</span>
        <span class="kd">public</span> <span class="no">E</span> <span class="nf">getElement</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">element</span><span class="o">;</span> <span class="o">}</span>
        <span class="kd">public</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">getParent</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">parent</span><span class="o">;</span> <span class="o">}</span>
        <span class="kd">public</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">getLeft</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">left</span><span class="o">;</span> <span class="o">}</span>
        <span class="kd">public</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">getRight</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">right</span><span class="o">;</span> <span class="o">}</span>
        <span class="c1">// update methods</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setElement</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="n">element</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span> <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setParent</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">parentNode</span><span class="o">)</span> <span class="o">{</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">parentNode</span><span class="o">;</span> <span class="o">}</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLeft</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">leftChild</span><span class="o">)</span> <span class="o">{</span> <span class="n">left</span> <span class="o">=</span> <span class="n">leftChild</span><span class="o">;</span> <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRight</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">rightChild</span><span class="o">)</span> <span class="o">{</span> <span class="n">right</span> <span class="o">=</span> <span class="n">rightChild</span><span class="o">;</span> <span class="o">}</span>
    <span class="o">}</span>


    <span class="c1">// /∗∗ Factory function to create a new node storing element e. ∗/</span>
    <span class="kd">protected</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">createNode</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">parent</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">left</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;(</span><span class="n">e</span><span class="o">,</span> <span class="n">parent</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// LinkedBinaryTree instance variables</span>
    <span class="kd">protected</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="c1">// constructor</span>
    <span class="kd">public</span> <span class="nf">LinkedBinaryTree</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

    <span class="c1">// nonpublic utility</span>
    <span class="c1">// /∗∗ Validates the position and returns it as a node. ∗/</span>
    <span class="kd">protected</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">validate</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span><span class="o">{</span>
        <span class="k">if</span><span class="o">(</span> <span class="o">!</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="nc">Node</span><span class="o">)</span> <span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Not valid position type"</span><span class="o">);</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;)</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getParent</span><span class="o">()==</span><span class="n">node</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"p is no longer in the tree"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// accessor methods (not already implemented in AbstractBinaryTree)</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">size</span><span class="o">;}</span>
    <span class="kd">public</span> <span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">root</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">root</span><span class="o">;}</span>
    <span class="kd">public</span> <span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">parent</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">validate</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">getParent</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">left</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">validate</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">getLeft</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">right</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">validate</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">getRight</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">addRoot</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalStateException</span><span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">isEmpty</span><span class="o">(</span> <span class="o">))</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="s">"Tree is not empty"</span><span class="o">);</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">createNode</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">addLeft</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalStateException</span><span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">validate</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">getLeft</span><span class="o">()!=</span><span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"p already has a left child"</span><span class="o">);</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">child</span> <span class="o">=</span> <span class="n">createNode</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">parent</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="n">parent</span><span class="o">.</span><span class="na">setLeft</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
        <span class="n">size</span><span class="o">++;</span>
        <span class="k">return</span> <span class="n">child</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">addRight</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalStateException</span><span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">validate</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">getRight</span><span class="o">()!=</span><span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"p already has a right child"</span><span class="o">);</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">child</span> <span class="o">=</span> <span class="n">createNode</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">parent</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="n">parent</span><span class="o">.</span><span class="na">setRight</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
        <span class="n">size</span><span class="o">++;</span>
        <span class="k">return</span> <span class="n">child</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="no">E</span> <span class="nf">set</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalStateException</span><span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">validate</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="no">E</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">getElement</span><span class="o">();</span>
        <span class="n">node</span><span class="o">.</span><span class="na">setElement</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// /∗∗ Attaches trees t1 and t2 as left and right subtrees of external p. ∗/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">attach</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">LinkedBinaryTree</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">t1</span><span class="o">,</span> <span class="nc">LinkedBinaryTree</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">t2</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span><span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">validate</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isInternal</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"p must be a leaf"</span><span class="o">);</span>
        <span class="n">size</span><span class="o">+=</span> <span class="n">t1</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">+</span> <span class="n">t2</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">t1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">t1</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">setParent</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="n">node</span><span class="o">.</span><span class="na">setLeft</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">root</span><span class="o">);</span>
            <span class="n">t1</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">t1</span><span class="o">.</span><span class="na">size</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">t2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">t2</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">setParent</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="n">node</span><span class="o">.</span><span class="na">setRight</span><span class="o">(</span><span class="n">t2</span><span class="o">.</span><span class="na">root</span><span class="o">);</span>
            <span class="n">t2</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">t2</span><span class="o">.</span><span class="na">size</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Removes the node at Position p and replaces it with its child, if any. ∗</span>
    <span class="kd">public</span> <span class="no">E</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span><span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">validate</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">numChildren</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"p has two children"</span><span class="o">);</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">getLeft</span><span class="o">()!=</span><span class="kc">null</span><span class="o">?</span> <span class="n">node</span><span class="o">.</span><span class="na">getLeft</span><span class="o">():</span><span class="n">node</span><span class="o">.</span><span class="na">getRight</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">child</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">child</span><span class="o">.</span><span class="na">setParent</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getParent</span><span class="o">());</span>
        <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">==</span><span class="n">root</span><span class="o">)</span> <span class="n">root</span><span class="o">=</span><span class="n">child</span><span class="o">;</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">getParent</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">parent</span><span class="o">.</span><span class="na">getLeft</span><span class="o">())</span> <span class="n">parent</span><span class="o">.</span><span class="na">setLeft</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
            <span class="k">else</span> <span class="n">parent</span><span class="o">.</span><span class="na">setRight</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">size</span><span class="o">--;</span>
        <span class="no">E</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">getElement</span><span class="o">();</span>
        <span class="c1">// help garbage collection</span>
        <span class="n">node</span><span class="o">.</span><span class="na">setElement</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="n">node</span><span class="o">.</span><span class="na">setLeft</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="n">node</span><span class="o">.</span><span class="na">setRight</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="c1">// our convention for defunct node</span>
        <span class="n">node</span><span class="o">.</span><span class="na">setParent</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="linked-binary-tree-structure-class-array-based-structure-for-binary-trees">Linked Binary Tree Structure <strong>class</strong> (Array-Based Structure for Binary Trees)</h4><ul><li>numbering the positions of T .<ul><li>For every position p of T , let f ( p) be the integer defined as follows.<li>If p is the root of T,then f(p)=0.<li>If p is the left child of position q, then f(p) = 2*f(q)+1.<li>If p is the right child of position q, then f(p) = 2*f(q)+2.</ul></ul><p>The numbering function f is known as a <strong>level numbering</strong> of the positions in a binary tree T , for it numbers the positions on each level of T in increasing order from left to right.</p><p><img data-proofer-ignore data-src="https://i.imgur.com/lpMPUP7.png" alt="Screen Shot 2022-03-21 at 03.12.08" /></p><p><strong>an array-based representation of a binary tree</strong></p><p><img data-proofer-ignore data-src="https://i.imgur.com/nkzeoyz.png" alt="Screen Shot 2022-03-21 at 03.13.09" /></p><p>One advantage of an array-based representation of a binary tree is that a position p can be represented by the single integer f(p)</p><ul><li>position-based methods such as root, parent, left, and right can be implemented using simple arithmetic operations on the number f(p).<li>Based on level numbering, the left child of p has index 2f(p)+1, the right child of p has index 2f(p)+2, and the parent of p has index ⌊( f ( p) − 1)/2⌋.</ul><hr /><h4 id="linked-structure-for-general-trees">Linked Structure for General Trees</h4><ul><li>For a general tree, there is no a priori limit on the number of children that a node may have.<li>A natural way to realize a general tree T as a linked structure is to have each node store a single container of references to its children.<ul><li>For example, a children field of a node can be an array or list of references to the children of the node (if any).</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/n0oAaGe.png" alt="Screen Shot 2022-03-21 at 03.46.09" /></p><hr /><h3 id="types-of-bt">Types of BT</h3><p><img data-proofer-ignore data-src="https://i.imgur.com/B41rB2I.png" alt="Screen Shot 2021-09-15 at 8.28.09 PM" /></p><h4 id="full-binary-tree-要么有要么没">Full Binary Tree 要么有要么没</h4><p><strong>every node has either 0 or 2 children</strong></p><ul><li>number of leaf nodes is the number of internal nodes plus 1:<ul><li>Number of leaf nodes = Number of internal nodes + 1</ul></ul><div class="language-plaintext highlighter-rouge"><div class="code-header" text-data="plaintext"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>               18
           /       \
         15         30
        /  \        /  \
      40    50    100   40

             18
           /    \
         15     20
        /  \
      40    50
    /   \
   30   50

               18
            /     \
          40       30
                   /  \
                 100   40
</pre></table></code></div></div><hr /><h4 id="perfect-binary-tree">Perfect Binary Tree</h4><p><strong>all nodes have two children and all leave have the same depth</strong></p><ul><li>所有internal node都有兩個<code class="language-plaintext highlighter-rouge">subtree(child pointer)</code><li><p>所有leaf node具有相同的level(或相同的height)。</p><li>由以上性質能夠推論出：<ul><li>若leaf node之level為<code class="language-plaintext highlighter-rouge">n</code>，整棵樹共有 <code class="language-plaintext highlighter-rouge">2^n − 1</code>個node。</ul><li>並且，每個node與其child有以下關係：<ul><li>第i個node的left child之index為 2i；<li>第i個node的right child之index為 2i+1；<li>除了root之parent為NULL之外，第i個node的parent之index為 ⌊i/2⌋ 。</ul></ul><div class="language-plaintext highlighter-rouge"><div class="code-header" text-data="plaintext"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>               18
           /       \
         15         30
        /  \        /  \
      40    50    100   40


               18
           /       \
         15         30
</pre></table></code></div></div><hr /><h4 id="complete-binary-tree">Complete Binary Tree</h4><p><strong>every level except possibly the last is full and all nodes in the last level are <code class="language-plaintext highlighter-rouge">as far left</code> as possible</strong></p><ul><li>node按照Full Binary Tree的次序排列(由上至下，由左至右)<ul><li>樹共有10個node，<li>且<code class="language-plaintext highlighter-rouge">這十個node正好填滿Full Binary Tree的前十個位置</code>，<li>則此樹為Complete Binary Tree。</ul><li>if all the levels are completely filled except possibly the last level and the last level has all keys as left as possible</ul><div class="language-plaintext highlighter-rouge"><div class="code-header" text-data="plaintext"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>               18
           /       \
         15         30
        /  \        /  \
      40    50    100   40


               18
           /       \
         15         30
        /  \        /  \
      40    50    100   40
     /  \   /
    8   7  9
</pre></table></code></div></div><p><img data-proofer-ignore data-src="https://i.imgur.com/K8LQjx1.png" alt="f4" /></p><blockquote><p>Complete Binary Tree。</p></blockquote><p><img data-proofer-ignore data-src="https://i.imgur.com/ed7613u.png" alt="f5" /></p><blockquote><p>不是一棵Complete Binary Tree。</p></blockquote><p><strong>property of a complete tree</strong></p><p><img data-proofer-ignore data-src="https://i.imgur.com/FzGkeOJ.png" alt="heapOrder" /></p><ul><li>can represent it using a single list.<ul><li>no need to use nodes and references or even lists of lists.</ul><li>Because the tree is complete,<li>the left child of a parent (at position <code class="language-plaintext highlighter-rouge">𝑝</code> ) is the node that is found in position <code class="language-plaintext highlighter-rouge">2𝑝</code> in the list.<li>Similarly, the right child of the parent is at position <code class="language-plaintext highlighter-rouge">2𝑝+1</code> in the list.<li>To find the parent of any node in the tree, Given that a node is at position <code class="language-plaintext highlighter-rouge">𝑛</code> in the list, the parent is at position <code class="language-plaintext highlighter-rouge">𝑛/2</code></ul><p>The list representation of the tree, along with the full structure property, allows us to efficiently traverse a complete binary tree <code class="language-plaintext highlighter-rouge">using only a few simple mathematical operations</code>.</p><hr /><h4 id="balanced-binary-tree">Balanced Binary Tree</h4><ul><li>A binary tree is balanced if the height of the tree is O(Log n) where n is the number of nodes.<li>For Example, the AVL tree maintains <code class="language-plaintext highlighter-rouge">O(Log n)</code> height by making sure that the difference between the heights of the left and right subtrees is almost 1.<li>Red-Black trees maintain O(Log n) height by making sure that the number of Black nodes on every root to leaf paths is the same and there are no adjacent red nodes.<li>performance-wise good: woest: O(log n) time for search, insert and delete.</ul><hr /><h4 id="degenerate--pathological-tree">degenerate / pathological tree</h4><ul><li>A Tree where every internal node has one child. Such trees are performance-wise same as linked list.</ul><div class="language-plaintext highlighter-rouge"><div class="code-header" text-data="plaintext"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>      10
      /
    20
     \
     30
      \
      40
</pre></table></code></div></div><hr /><h1 id="tree-traversal-algorithms-visiting-the-positions-of-a-tree">Tree Traversal Algorithms: visiting the positions of a tree</h1><ul><li>A traversal of a tree T is a systematic way of accessing, or “visiting,” all the positions of T .<li>The specific action associated with the “visit” of a position p depends on the application of this traversal, and could involve anything from incrementing a counter to performing some complex computation for p.</ul><hr /><h2 id="preorder-and-postorder-traversals-of-general-trees">Preorder and Postorder Traversals of General Trees</h2><p><strong>Running-Time Analysis</strong></p><ul><li>Both preorder and postorder traversal algorithms are efficient ways to access all the positions of a tree.<li>At each position p, the <strong>nonrecursive part of the traversal algorithm</strong> requires time <code class="language-plaintext highlighter-rouge">O(cp + 1)</code>, where cp is the number of children of p, under the assumption that the “visit” itself takes O(1) time.<li>the overall running time for the traversal of tree T is <code class="language-plaintext highlighter-rouge">O(n)</code>, where n is the number of positions in the tree.<li>This running time is asymptotically optimal since the traversal must visit all n positions of the tree.</ul><hr /><h3 id="preorder-traversal-n-l-r-general-visit---each-child-preorderc">preorder traversal <code class="language-plaintext highlighter-rouge">N-L-R</code> <strong>General</strong> <strong>Visit() -&gt; each child preorder(c)</strong></h3><p>In a preorder traversal of a tree T</p><ul><li>the root of T is visited first and then the subtrees rooted at its children are traversed recursively.<li>If the tree is ordered, then the subtrees are traversed according to the order of the children.</ul><font color="red"> Algorithm </font><p>preorder(p):</p><ol><li>perform the “visit” action for position p { this happens before any recursion }<li>for each child c in children(p) do<ol><li>preorder(c) { recursively traverse the subtree rooted at c }</ol></ol><p><img data-proofer-ignore data-src="https://i.imgur.com/hSFUAB2.png" alt="Screen Shot 2022-03-21 at 03.55.20" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/bDWOafI.png" alt="Screen Shot 2020-07-23 at 01.29.46" /></p><p>10 -&gt; 7 -&gt; 6 -&gt; 1 -&gt; 8 -&gt; 9 -&gt; 11 -&gt; 20 -&gt; 14 -&gt; 22</p><div class="language-plaintext highlighter-rouge"><div class="code-header" text-data="plaintext"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>             10
           /     \
          7       11
        /  \        \
       6    8        20
      /      \      /  \
     1        9    14  22
</pre></table></code></div></div><p><img data-proofer-ignore data-src="https://i.imgur.com/8V6IjcI.png" alt="Screen Shot 2020-07-24 at 14.39.24" /></p><h4 id="preorder-in-java">preorder in java</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TreeTraversals</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">preOrder</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span><span class="k">return</span><span class="o">;}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">data</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="n">preOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">preOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">preOrderItr</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">){</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>
        <span class="n">stack</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">data</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>

            <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span><span class="n">stack</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">!=</span> <span class="kc">null</span><span class="o">){</span><span class="n">stack</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="preorder-in-python">preorder in python</h4><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">getRootVal</span><span class="p">())</span>
        <span class="nf">preorder</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">getLeftChild</span><span class="p">())</span>
        <span class="nf">preorder</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">getRightChild</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="nf">preorder</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="nf">preorder</span><span class="p">()</span>
</pre></table></code></div></div><p>The answer is that implementing preorder as an external function is probably better in this case.</p><ul><li>The reason is that you very rarely want to just traverse the tree.<li>In most cases you are going to want to accomplish something else while using one of the basic traversal patterns.</ul><hr /><h3 id="postorder-traversal-l-r-n-general-each-child-preorderc---visit">postorder traversal <code class="language-plaintext highlighter-rouge">L-R-N</code> <strong>General</strong> <strong>Each child preorder(c) -&gt; Visit()</strong></h3><p>postorder traversal.</p><ul><li>can be viewed as the opposite of the preorder traversal, because it recursively traverses the subtrees rooted at the children of the root first, and then visits the root (hence, the name “postorder”).</ul><font color="red"> Algorithm </font><p>postorder(p):</p><ol><li>for each child c in children(p) do<ol><li>postorder(c) { recursively traverse the subtree rooted at c }</ol><li>perform the “visit” action for position p { this happens after any recursion }</ol><p><img data-proofer-ignore data-src="https://i.imgur.com/TIlKPeO.png" alt="Screen Shot 2022-03-21 at 03.58.42" /></p><p>1 -&gt; 6 -&gt; 9 -&gt; 8 -&gt; 7 -&gt; 14 -&gt; 22 -&gt; 20 -&gt; 11 -&gt; 10</p><div class="language-plaintext highlighter-rouge"><div class="code-header" text-data="plaintext"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>             10
           /     \
          7       11
        /  \        \
       6    8        20
      /      \      /  \
     1        9    14  22
</pre></table></code></div></div><hr /><h4 id="postorder-in-java">postorder in java</h4><p><img data-proofer-ignore data-src="https://i.imgur.com/EpqGSIW.png" alt="Screen Shot 2020-07-24 at 13.57.34" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/fNYgO5h.png" alt="Screen Shot 2020-07-24 at 14.00.03" /></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="n">cass</span> <span class="nc">TreeTraversals</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postOrder</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span><span class="k">return</span><span class="o">;}</span>
        <span class="n">postOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">postOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">data</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 1.</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">iterPostOrder</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span><span class="o">;}</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>
        <span class="n">s1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">s1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">root</span><span class="o">=</span><span class="n">s1</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="n">s2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">s1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">s1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">s2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">root</span><span class="o">=</span><span class="n">s2</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">data</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 2.</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postOrderItr</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">){</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">stack1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">stack2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>
        <span class="n">stack1</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">stack1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">stack1</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">stack1</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">stack1</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">stack2</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">stack2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">stack2</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">().</span><span class="na">data</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postOrderItrOneStack</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">){</span>
        <span class="nc">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="nc">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">right</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">temp</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">temp</span><span class="o">.</span><span class="na">data</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
                    <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">temp</span> <span class="o">==</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">right</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">temp</span><span class="o">.</span><span class="na">data</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="postorder-in-python">postorder in python</h4><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">tree</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="nf">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">getLeftChild</span><span class="p">())</span>
        <span class="nf">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">getRightChild</span><span class="p">())</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">getRootVal</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">postordereval</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="n">opers</span> <span class="o">=</span> <span class="p">{</span><span class="s">'+'</span><span class="p">:</span><span class="n">operator</span><span class="p">.</span><span class="n">add</span><span class="p">,</span> <span class="s">'-'</span><span class="p">:</span><span class="n">operator</span><span class="p">.</span><span class="n">sub</span><span class="p">,</span> <span class="s">'*'</span><span class="p">:</span><span class="n">operator</span><span class="p">.</span><span class="n">mul</span><span class="p">,</span> <span class="s">'/'</span><span class="p">:</span><span class="n">operator</span><span class="p">.</span><span class="n">truediv</span><span class="p">}</span>
    <span class="n">res1</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">res2</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">tree</span><span class="p">:</span>
        <span class="n">res1</span> <span class="o">=</span> <span class="nf">postordereval</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">getLeftChild</span><span class="p">())</span>
        <span class="n">res2</span> <span class="o">=</span> <span class="nf">postordereval</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">getRightChild</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">res1</span> <span class="ow">and</span> <span class="n">res2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">opers</span><span class="p">[</span><span class="n">tree</span><span class="p">.</span><span class="nf">getRootVal</span><span class="p">()](</span><span class="n">res1</span><span class="p">,</span><span class="n">res2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tree</span><span class="p">.</span><span class="nf">getRootVal</span><span class="p">()</span>

</pre></table></code></div></div><hr /><h2 id="bfs-and-dfs">BFS and DFS</h2><ol><li>为什么 BFS 可以找到最短距离，DFS 不行吗？<ol><li>BFS 的逻辑，depth 每增加一次，队列中的所有节点都向前迈一步，这保证了<code class="language-plaintext highlighter-rouge">第一次到达终点的时候，走的步数是最少的</code>。<li>DFS 也是可以的，但是时间复杂度相对高很多。DFS 实际上是靠递归的堆栈记录走过的路径，找最短路径得<code class="language-plaintext highlighter-rouge">把二叉树中所有树杈都探索完, 才能对比出最短的路径有多长</code><li>BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。<li>形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动</ol><li>既然 BFS 那么好，为啥 DFS 还要存在？<ol><li>BFS 可以找到最短距离，但是<strong>空间复杂度高</strong>，而 DFS 的空间复杂度较低。<li>假设二叉树是满二叉树，节点数为 N<ol><li>对于 DFS 算法来说，<strong>空间复杂度</strong>无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 <code class="language-plaintext highlighter-rouge">O(logN)</code>。<li>BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下<strong>空间复杂度</strong>应该是树的最底层节点的数量，也就是 N/2，用 Big O 表示的话也就是 <code class="language-plaintext highlighter-rouge">O(N)</code>。</ol><li>由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。</ol></ol><font color="red"> BFS 相对 DFS 的最主要的区别是：BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多 </font><hr /><h3 id="bfs---breadth-first-tree-traversal-general-queue">BFS - Breadth-First Tree Traversal <strong>General</strong> <strong>Queue()</strong></h3><blockquote><p>preorder and postorder traversals are common ways of visiting the positions of a tree, another approach is to traverse a tree so that we visit <code class="language-plaintext highlighter-rouge">all the positions at depth d</code> before we visit the <code class="language-plaintext highlighter-rouge">positions at depth d + 1.</code> Such an algorithm is known as a breadth-first traversal.</p></blockquote><p>breadth-first traversal</p><ul><li>visit all the positions at depth <code class="language-plaintext highlighter-rouge">d</code> before we visit the positions at depth <code class="language-plaintext highlighter-rouge">d + 1</code>.</ul><p>BFS 出现的常见场景</p><ul><li>问题的本质就是让你在一幅「图」中找到从起点 start 到终点 target 的最近距离<li>BFS 算法问题其实都是在干这个事儿，<ul><li>比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？<li>比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？<li>比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？<li>playing games.<ul><li>A game tree represents the possible choices of moves made by a player (or computer) during a game,<li>with the root of the tree being the initial configuration for the game.<li>For example, game tree for Tic-Tac-Toe.</ul></ul><li>本质上就是一幅「图」，让你从一个起点，走到终点，问最短路径。</ul><blockquote><p>A breadth-first traversal of such a game tree is often performed because a computer may be unable to explore a complete game tree in a limited amount of time. So the computer will consider all moves, then responses to those moves, going as deep as computational time allows.</p></blockquote><hr /><h4 id="bfs-pseudocode">BFS Pseudocode</h4><ul><li>The process is not recursive, since we are not traversing entire subtrees at once.<li>We use a queue to produce a FIFO (i.e., first-in first-out) semantics for the order in which we visit nodes.<li>The overall running time is <code class="language-plaintext highlighter-rouge">O(n)</code>, due to the n calls to enqueue and n calls to dequeue.</ul><font color="red"> Algorithm </font><p>breadthfirst():</p><ol><li>Initialize queue Q to contain root()<li><strong>while</strong> Q not empty <strong>do</strong><ol><li>p = Q.dequeue() { p is the oldest entry in the queue }<li>perform the visit action for position p<li><strong>for</strong> each child c in children(p) <strong>do</strong><ol><li>Q.enqueue(c) { add p’s children to the end of the queue for later visits }</ol></ol></ol><hr /><h4 id="bfs-in-java">BFS in Java</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="c1">// /∗∗ Returns an iterable collection of positions of the tree in breadth-first order. ∗/</span>
<span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="nf">breadthfirst</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="n">fringe</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedQueue</span><span class="o">&lt;&gt;();</span>
        <span class="n">fringe</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">root</span><span class="o">());</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">fringe</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">fringe</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>
            <span class="n">snapshot</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nl">c:</span> <span class="n">children</span><span class="o">(</span><span class="n">p</span><span class="o">)){</span>
                <span class="n">fringe</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">snapshot</span><span class="o">;</span>
<span class="o">}</span>


<span class="c1">// 计算从起点 start 到终点 target 的最近距离</span>
<span class="kt">int</span> <span class="nf">BFS</span><span class="o">(</span><span class="nc">Node</span> <span class="n">start</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">;</span> <span class="c1">// 核心数据结构</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">visited</span><span class="o">;</span> <span class="c1">// 避免走回头路</span>

    <span class="c1">// 将起点加入队列</span>
    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
    <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 记录扩散的步数</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">q</span> <span class="n">not</span> <span class="n">empty</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="cm">/* 将当前队列中的所有节点向四周扩散 */</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="cm">/* 划重点：这里判断是否到达终点 */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cur</span> <span class="n">is</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="n">step</span><span class="o">;</span>
            <span class="cm">/* 将 cur 的相邻节点加入队列 */</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span> <span class="n">x</span> <span class="o">:</span> <span class="n">cur</span><span class="o">.</span><span class="na">adj</span><span class="o">())</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="n">not</span> <span class="n">in</span> <span class="n">visited</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                    <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                <span class="o">}</span>
        <span class="o">}</span>
        <span class="cm">/* 划重点：更新步数在这里 */</span>
        <span class="n">step</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="inorder-traversal-l-n-r-binary-tree">inorder traversal <code class="language-plaintext highlighter-rouge">L-N-R</code> <strong>Binary tree</strong></h2><p>traversal algorithm specifically for a binary tree.</p><ul><li>visit a position between the recursive traversals of its left and right subtrees.<li>The inorder traversal of a binary tree T can be informally viewed as visiting the nodes of T “from left to right.”<li>Indeed, for every position p, the inorder traversal visits p after all the positions in the left subtree of p and before all the positions in the right subtree of p.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/UbdlT5J.png" alt="Screen Shot 2022-03-28 at 22.15.10" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/q4wCoVb.png" alt="Screen Shot 2020-07-23 at 01.33.45" /></p><p>1 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 14 -&gt; 20 &gt; 22</p><div class="language-plaintext highlighter-rouge"><div class="code-header" text-data="plaintext"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>             10
           /     \
          7       11
        /  \        \
       6    8        20
      /      \      /  \
     1        9    14  22
</pre></table></code></div></div><hr /><h3 id="pseudocode">Pseudocode</h3><font color="red"> Algorithm </font><p>inorder(p):</p><ol><li><strong>if</strong> p has a left child lc <strong>then</strong><ol><li>inorder(lc) { recursively traverse the left subtree of p }</ol><li>perform the “visit” action for position p<li><strong>if</strong> p has a right child rc <strong>then</strong><ol><li>inorder(rc) { recursively traverse the right subtree of p }</ol></ol><hr /><h3 id="inorder-in-java">inorder in java</h3><p>O(n)</p><p><img data-proofer-ignore data-src="https://i.imgur.com/ReKolwj.png" alt="Screen Shot 2020-07-25 at 00.40.01" /></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TreeTraversals</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">inOrder</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span><span class="k">return</span><span class="o">;}</span>
        <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">data</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="n">inOrder</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">inorderItr</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
                <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">root</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>



    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">inorderItr</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">){</span>
        <span class="nc">Stack</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">();</span>
        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">inorderItr</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">(</span><span class="n">root</span><span class="o">)</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// public void inorderItr(Node root){</span>
    <span class="c1">//     Deque&lt;Node&gt; stack = new LinkedList&lt;Node&gt;();</span>
    <span class="c1">//     Node node = root;</span>
    <span class="c1">//     while(true){</span>
    <span class="c1">//         if(node != null){</span>
    <span class="c1">//             stack.addFirst(node);</span>
    <span class="c1">//             node = node.left;</span>
    <span class="c1">//         }</span>
    <span class="c1">//         else{</span>
    <span class="c1">//             if(stack.isEmpty()){</span>
    <span class="c1">//                 break;</span>
    <span class="c1">//             }</span>
    <span class="c1">//             node = stack.pollFirst();</span>
    <span class="c1">//             System.out.println(node.data);</span>
    <span class="c1">//             node = node.right;</span>
    <span class="c1">//         }</span>
    <span class="c1">//     }</span>
    <span class="c1">// }</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="inorder-in-python">inorder in python</h3><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">tree</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
      <span class="nf">inorder</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">getLeftChild</span><span class="p">())</span>
      <span class="nf">print</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">getRootVal</span><span class="p">())</span>
      <span class="nf">inorder</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">getRightChild</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">printexp</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
  <span class="n">sVal</span> <span class="o">=</span> <span class="s">""</span>
  <span class="k">if</span> <span class="n">tree</span><span class="p">:</span>
      <span class="n">sVal</span> <span class="o">=</span> <span class="s">'('</span> <span class="o">+</span> <span class="nf">printexp</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">getLeftChild</span><span class="p">())</span>
      <span class="n">sVal</span> <span class="o">=</span> <span class="n">sVal</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">getRootVal</span><span class="p">())</span>
      <span class="n">sVal</span> <span class="o">=</span> <span class="n">sVal</span> <span class="o">+</span> <span class="nf">printexp</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="nf">getRightChild</span><span class="p">())</span><span class="o">+</span><span class="s">')'</span>
  <span class="k">return</span> <span class="n">sVal</span>

</pre></table></code></div></div><hr /><h3 id="application">application</h3><p>The inorder traversal algorithm has several important applications.</p><ul><li>When using a binary tree to represent an arithmetic expression, the inorder traversal visits positions in a consistent order with the standard representation of the expression, as in 3 + 1 × 3/9 − 5 + 2 . . . (albeit without parentheses).</ul><hr /><h4 id="bst---binary-search-trees-左小右大">BST - Binary Search Trees 左小右大</h4><ul><li>a type of binary tree<li>maintains the property that：<ul><li>the value in each node must be<li>greater than or equal to any value stored in the left sub-tree,<li>and less than or equal to any value stored in the right sub-tree</ul></ul><p><strong>bst property</strong></p><ul><li>store an ordered sequence of elements in a binary tree, defining structure <strong>binary search tree</strong>.<li>Let S be a set whose unique elements have an order relation.<ul><li>For example, S could be a set of integers.<li>A <strong>binary search tree for S</strong> is a <code class="language-plaintext highlighter-rouge">proper binary tree T</code> such that, for each internal position p of T :<ul><li> <font color="red"> subtree_v(left) &lt; value(center) &lt; subtree_v(right) </font><li>Position p stores an element of S, denoted as <code class="language-plaintext highlighter-rouge">e(p)</code>.<li>Elements stored in the left subtree of p (if any) are less than <code class="language-plaintext highlighter-rouge">e(p)</code>.<li>Elements stored in the right subtree of p (if any) are greater than <code class="language-plaintext highlighter-rouge">e(p)</code>.</ul></ul><li>A binary search tree relies on the property that<ul><li>keys that are less than the parent are found in the left subtree,<li>keys that are greater than the parent are found in the right subtree.</ul><li>We call this the <code class="language-plaintext highlighter-rouge">bst property</code>.</ul><p>the running time of searching in a binary search tree T is proportional to the height of T .</p><ul><li>the height of a binary tree with n nodes: <code class="language-plaintext highlighter-rouge">log(n+1)−1</code> ~ <code class="language-plaintext highlighter-rouge">n−1</code></ul><p><strong>Time Complexity</strong>:</p><ul><li>Access: O(log(n))<li>Search: O(log(n))<li>Insert: O(log(n))<li>Remove: O(log(n))</ul><p>As we implement the Map interface as described above, the <strong>bst property</strong> will guide our implementation.</p><p><img data-proofer-ignore data-src="https://i.imgur.com/7XMfVRk.png" alt="simpleBST" /></p><hr /><h5 id="implementing-tree-traversals-in-java">Implementing Tree Traversals in Java</h5><p>any of the tree traversal algorithms can be used to produce these iterations as concrete implementations within the <code class="language-plaintext highlighter-rouge">AbstractTree</code> or <code class="language-plaintext highlighter-rouge">AbstractBinaryTree</code> base classes.</p><hr /><h5 id="preorder-traversals">Preorder Traversals</h5><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>
<span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="nf">positions</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">preorder</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// ∗∗ Returns an iterable collection of positions of the tree, reported in preorder. ∗/</span>
<span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="nf">preorder</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">isEmpty</span><span class="o">())</span> <span class="n">preorderSubtree</span><span class="o">(</span><span class="n">root</span><span class="o">(),</span> <span class="n">snapshot</span><span class="o">);</span> <span class="c1">// fill the snapshot recursively</span>
    <span class="k">return</span> <span class="n">snapshot</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// ∗∗ Adds positions of the subtree rooted at Position p to the given snapshot. ∗/</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">preorderSubtree</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="n">snapshot</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">snapshot</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span> <span class="c1">// for preorder, we add position p before exploring subtrees</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">:</span> <span class="n">children</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="n">preorderSubtree</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">snapshot</span><span class="o">);</span>
<span class="o">}</span>

</pre></table></code></div></div><hr /><h5 id="postorder-traversal">Postorder Traversal</h5><ul><li>implement a postorder traversal using a similar design as we used for a preorder traversal.<li>The only difference is that a “visited” position is not added to a postorder snapshot until after all of its subtrees have been traversed.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>
<span class="c1">// ∗∗ Returns an iterable collection of positions of the tree, reported in preorder. ∗/</span>
<span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="nf">postorder</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">isEmpty</span><span class="o">())</span> <span class="n">postorderSubtree</span><span class="o">(</span><span class="n">root</span><span class="o">(),</span> <span class="n">snapshot</span><span class="o">);</span> <span class="c1">// fill the snapshot recursively</span>
    <span class="k">return</span> <span class="n">snapshot</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// ∗∗ Adds positions of the subtree rooted at Position p to the given snapshot. ∗/</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">postorderSubtree</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="n">snapshot</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">snapshot</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span> <span class="c1">// for preorder, we add position p before exploring subtrees</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">:</span> <span class="n">children</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="n">postorderSubtree</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">snapshot</span><span class="o">);</span>
<span class="o">}</span>

</pre></table></code></div></div><hr /><h5 id="inorder-traversal">Inorder Traversal</h5><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>    <span class="c1">// ∗∗ Returns an iterable collection of positions of the tree, reported in inorder. ∗/</span>
    <span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="nf">inorder</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">isEmpty</span><span class="o">())</span> <span class="n">inorderSubtree</span><span class="o">(</span><span class="n">root</span><span class="o">(),</span> <span class="n">snapshot</span><span class="o">);</span> <span class="c1">// fill the snapshot recursively</span>
        <span class="k">return</span> <span class="n">snapshot</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// ∗∗ Adds positions of the subtree rooted at Position p to the given snapshot. ∗/</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">inorderSubtree</span><span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Position</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="n">snapshot</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">inorderSubtree</span><span class="o">(</span><span class="n">left</span><span class="o">(</span><span class="n">p</span><span class="o">),</span> <span class="n">snapshot</span><span class="o">);</span>
        <span class="n">snapshot</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">right</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">inorderSubtree</span><span class="o">(</span><span class="n">right</span><span class="o">(</span><span class="n">p</span><span class="o">),</span> <span class="n">snapshot</span><span class="o">);</span>
    <span class="o">}</span>
</pre></table></code></div></div><hr /><h5 id="implementing-tree-traversals-in-python">Implementing Tree Traversals in Python</h5><p>To implement the binary search tree, we will use the <code class="language-plaintext highlighter-rouge">nodes</code> and references approach similar to the one we used to implement the linked list, and the expression tree.</p><p>However, because we must be able create and work with a binary search tree that is empty, our implementation will use two classes.</p><ul><li>The first class we will call <code class="language-plaintext highlighter-rouge">BinarySearchTree</code>,<li>and the second class we will call <code class="language-plaintext highlighter-rouge">TreeNode</code>.</ul><p>the interface provided by the map ADT.</p><ul><li><code class="language-plaintext highlighter-rouge">Map()</code><ul><li>Create a new, empty map.</ul><li><code class="language-plaintext highlighter-rouge">put(key,val)</code><ul><li>Add a new key-value pair to the map.<li>If the key is already in the map then replace the old value with the new value.</ul><li><code class="language-plaintext highlighter-rouge">get(key)</code><ul><li>Given a key, return the value stored in the map or None otherwise.</ul><li><code class="language-plaintext highlighter-rouge">del</code><ul><li>Delete the key-value pair from the map using a statement of the form <code class="language-plaintext highlighter-rouge">del map[key]</code>.</ul><li><code class="language-plaintext highlighter-rouge">len()</code><ul><li>Return the number of key-value pairs stored in the map.</ul><li><code class="language-plaintext highlighter-rouge">in</code><ul><li>Return True for a statement of the form key in map, if the given key is in the map.</ul></ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">self</span><span class="p">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>

    <span class="k">def</span> <span class="nf">hasLeftChild</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span>

    <span class="k">def</span> <span class="nf">hasRightChild</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span>

    <span class="k">def</span> <span class="nf">isLeftChild</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">==</span> <span class="n">self</span>

    <span class="k">def</span> <span class="nf">isRightChild</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">==</span> <span class="n">self</span>

    <span class="k">def</span> <span class="nf">isRoot</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span>

    <span class="k">def</span> <span class="nf">isLeaf</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rightChild</span> <span class="ow">or</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hasAnyChildren</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span> <span class="ow">or</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span>

    <span class="k">def</span> <span class="nf">hasBothChildren</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span>

    <span class="k">def</span> <span class="nf">spliceOut</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">isLeaf</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">isLeftChild</span><span class="p">():</span>
                <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="nf">hasAnyChildren</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">hasLeftChild</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">isLeftChild</span><span class="p">():</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span>
                <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">isLeftChild</span><span class="p">():</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span>
                <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span>

    <span class="k">def</span> <span class="nf">findSuccessor</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">succ</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">hasRightChild</span><span class="p">():</span>
            <span class="n">succ</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="nf">findMin</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span>
                   <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">isLeftChild</span><span class="p">():</span>
                       <span class="n">succ</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span>
                   <span class="k">else</span><span class="p">:</span>
                       <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="bp">None</span>
                       <span class="n">succ</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="nf">findSuccessor</span><span class="p">()</span>
                       <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">self</span>
        <span class="k">return</span> <span class="n">succ</span>

    <span class="k">def</span> <span class="nf">findMin</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">self</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">.</span><span class="nf">hasLeftChild</span><span class="p">():</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">leftChild</span>
        <span class="k">return</span> <span class="n">current</span>

    <span class="k">def</span> <span class="nf">replaceNodeData</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">lc</span><span class="p">,</span><span class="n">rc</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">self</span><span class="p">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">lc</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">rc</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">hasLeftChild</span><span class="p">():</span>
            <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">self</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">hasRightChild</span><span class="p">():</span>
            <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">self</span>


<span class="k">class</span> <span class="nc">BinarySearchTree</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">_put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_put</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">currentNode</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">hasLeftChild</span><span class="p">():</span>
                   <span class="n">self</span><span class="p">.</span><span class="nf">_put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                   <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">parent</span><span class="o">=</span><span class="n">currentNode</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">hasRightChild</span><span class="p">():</span>
                   <span class="n">self</span><span class="p">.</span><span class="nf">_put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                   <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">parent</span><span class="o">=</span><span class="n">currentNode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
       <span class="n">self</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
       <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
           <span class="n">res</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">)</span>
           <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                  <span class="k">return</span> <span class="n">res</span><span class="p">.</span><span class="n">payload</span>
           <span class="k">else</span><span class="p">:</span>
                  <span class="k">return</span> <span class="bp">None</span>
       <span class="k">else</span><span class="p">:</span>
           <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">currentNode</span><span class="p">):</span>
       <span class="k">if</span> <span class="ow">not</span> <span class="n">currentNode</span><span class="p">:</span>
           <span class="k">return</span> <span class="bp">None</span>
       <span class="k">elif</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
           <span class="k">return</span> <span class="n">currentNode</span>
       <span class="k">elif</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
           <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">)</span>
       <span class="k">else</span><span class="p">:</span>
           <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
       <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
       <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">):</span>
           <span class="k">return</span> <span class="bp">True</span>
       <span class="k">else</span><span class="p">:</span>
           <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
         <span class="n">nodeToRemove</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">nodeToRemove</span><span class="p">:</span>
             <span class="n">self</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="n">nodeToRemove</span><span class="p">)</span>
             <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span>
         <span class="k">else</span><span class="p">:</span>
             <span class="k">raise</span> <span class="nc">KeyError</span><span class="p">(</span><span class="s">'Error, key not in tree'</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
         <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="bp">None</span>
         <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">raise</span> <span class="nc">KeyError</span><span class="p">(</span><span class="s">'Error, key not in tree'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
       <span class="n">self</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">currentNode</span><span class="p">):</span>
         <span class="k">if</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">isLeaf</span><span class="p">():</span> <span class="c1">#leaf
</span>           <span class="k">if</span> <span class="n">currentNode</span> <span class="o">==</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span><span class="p">:</span>
               <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="bp">None</span>
           <span class="k">else</span><span class="p">:</span>
               <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="bp">None</span>
         <span class="k">elif</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">hasBothChildren</span><span class="p">():</span> <span class="c1">#interior
</span>           <span class="n">succ</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">findSuccessor</span><span class="p">()</span>
           <span class="n">succ</span><span class="p">.</span><span class="nf">spliceOut</span><span class="p">()</span>
           <span class="n">currentNode</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">succ</span><span class="p">.</span><span class="n">key</span>
           <span class="n">currentNode</span><span class="p">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">succ</span><span class="p">.</span><span class="n">payload</span>

         <span class="k">else</span><span class="p">:</span> <span class="c1"># this node has one child
</span>           <span class="k">if</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">hasLeftChild</span><span class="p">():</span>
             <span class="k">if</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">isLeftChild</span><span class="p">():</span>
                 <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span>
                 <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span>
             <span class="k">elif</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">isRightChild</span><span class="p">():</span>
                 <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span>
                 <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span>
             <span class="k">else</span><span class="p">:</span>
                 <span class="n">currentNode</span><span class="p">.</span><span class="nf">replaceNodeData</span><span class="p">(</span><span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">key</span><span class="p">,</span>
                                    <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">payload</span><span class="p">,</span>
                                    <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">leftChild</span><span class="p">,</span>
                                    <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">rightChild</span><span class="p">)</span>
           <span class="k">else</span><span class="p">:</span>
             <span class="k">if</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">isLeftChild</span><span class="p">():</span>
                 <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span>
                 <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span>
             <span class="k">elif</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">isRightChild</span><span class="p">():</span>
                 <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span>
                 <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span>
             <span class="k">else</span><span class="p">:</span>
                 <span class="n">currentNode</span><span class="p">.</span><span class="nf">replaceNodeData</span><span class="p">(</span><span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">key</span><span class="p">,</span>
                                    <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">payload</span><span class="p">,</span>
                                    <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">leftChild</span><span class="p">,</span>
                                    <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">rightChild</span><span class="p">)</span>




<span class="n">mytree</span> <span class="o">=</span> <span class="nc">BinarySearchTree</span><span class="p">()</span>
<span class="n">mytree</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="s">"red"</span>
<span class="n">mytree</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="s">"blue"</span>
<span class="n">mytree</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span><span class="s">"yellow"</span>
<span class="n">mytree</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="s">"at"</span>

<span class="nf">print</span><span class="p">(</span><span class="n">mytree</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mytree</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></table></code></div></div><hr /><p><strong><code class="language-plaintext highlighter-rouge">BinarySearchTree</code> class</strong></p><p>The <code class="language-plaintext highlighter-rouge">BinarySearchTree</code> class has a reference to the <code class="language-plaintext highlighter-rouge">TreeNode</code> that is the root of the binary search tree.</p><ul><li>In most cases the external methods defined in the outer class simply check to see if the tree is empty.<li>If there are nodes in the tree, the request is just passed on to a private method defined in the BinarySearchTree class that takes the root as a parameter.<li>In the case where the tree is empty or we want to delete the key at the root of the tree, we must take special action.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">BinarySearchTree</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="nf">__iter__</span><span class="p">()</span>
</pre></table></code></div></div><hr /><p><strong><code class="language-plaintext highlighter-rouge">TreeNode</code> class</strong></p><p>The <code class="language-plaintext highlighter-rouge">TreeNode</code> class provides many helper functions that make the work done in the <code class="language-plaintext highlighter-rouge">BinarySearchTree</code> class methods much easier.</p><ul><li>many of these helper functions help to classify a node according to its own position as a child, (left or right) and the kind of children the node has.<li>The <code class="language-plaintext highlighter-rouge">TreeNode</code> class will also explicitly keep track of the <code class="language-plaintext highlighter-rouge">parent</code> as an attribute of each node.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">,</span>
                <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">self</span><span class="p">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>

    <span class="k">def</span> <span class="nf">hasLeftChild</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span>

    <span class="k">def</span> <span class="nf">hasRightChild</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span>

    <span class="k">def</span> <span class="nf">isLeftChild</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">==</span> <span class="n">self</span>

    <span class="k">def</span> <span class="nf">isRightChild</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">==</span> <span class="n">self</span>

    <span class="k">def</span> <span class="nf">isRoot</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span>

    <span class="k">def</span> <span class="nf">isLeaf</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rightChild</span> <span class="ow">or</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hasAnyChildren</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span> <span class="ow">or</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span>

    <span class="k">def</span> <span class="nf">hasBothChildren</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span>

    <span class="k">def</span> <span class="nf">replaceNodeData</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">lc</span><span class="p">,</span><span class="n">rc</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">self</span><span class="p">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">lc</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">rc</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">hasLeftChild</span><span class="p">():</span>
            <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">self</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">hasRightChild</span><span class="p">():</span>
            <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">self</span>
</pre></table></code></div></div><hr /><p><strong><code class="language-plaintext highlighter-rouge">put</code> method</strong></p><p><strong>put method</strong></p><ul><li>to build our binary search tree.<li>The put method is a method of the <code class="language-plaintext highlighter-rouge">BinarySearchTree</code> class.<li>This method will check to see if the tree already has a root.<ul><li>If there is not a root then put will create a new <code class="language-plaintext highlighter-rouge">TreeNode</code> and install it as the root of the tree.<li>If a root node is already in place then put calls the private, recursive, helper function _put to search the tree according to the following algorithm:<ul><li>Starting at the root of the tree,<ul><li>search the binary tree comparing the <code class="language-plaintext highlighter-rouge">new key</code> to the <code class="language-plaintext highlighter-rouge">key in the current node</code>.<li>If the new key is less than the current node, search the left subtree.<li>If the new key is greater than the current node, search the right subtree.</ul><li>When there is no left (or right) child to search,<ul><li>we have found the position in the tree where the new node should be installed.</ul><li>To add a node to the tree,<ul><li>create a new TreeNode object<li>and insert the object at the point discovered in the previous step.</ul></ul></ul></ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
      <span class="n">self</span><span class="p">.</span><span class="nf">_put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">)</span>
    <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">_put</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">currentNode</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">hasLeftChild</span><span class="p">():</span> <span class="n">self</span><span class="p">.</span><span class="nf">_put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">parent</span><span class="o">=</span><span class="n">currentNode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">hasRightChild</span><span class="p">():</span> <span class="n">self</span><span class="p">.</span><span class="nf">_put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">parent</span><span class="o">=</span><span class="n">currentNode</span><span class="p">)</span>
</pre></table></code></div></div><p>One important problem with our implementation of insert is that <code class="language-plaintext highlighter-rouge">duplicate keys</code> are not handled properly.</p><ul><li>As our tree is implemented a duplicate key will create a new node with the same key value in the right subtree of the node having the original key.<li>The result of this is that the node with the new key will never be found during a search.<li>A better way to handle the insertion of a duplicate key is for the value associated with the new key to replace the old value.<li>We leave fixing this bug as an exercise for you.</ul><hr /><p><strong><code class="language-plaintext highlighter-rouge">__setitem__</code> method</strong></p><p>overload the <code class="language-plaintext highlighter-rouge">[]</code> operator for assignment by having the <code class="language-plaintext highlighter-rouge">__setitem__</code> method call (see Listing 4) the put method.</p><ul><li>This allows us to write Python statements like <code class="language-plaintext highlighter-rouge">myZipTree['Plymouth'] = 55446</code>, just like a Python dictionary.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="n">self</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
</pre></table></code></div></div><hr /><p><strong><code class="language-plaintext highlighter-rouge">get</code> method</strong></p><ul><li>implement the retrieval of a value for a given key.<li>The get method is even easier than the put method because it simply searches the tree recursively until it gets to a <code class="language-plaintext highlighter-rouge">non-matching leaf node</code> or <code class="language-plaintext highlighter-rouge">finds a matching key</code>.<li>When a matching key is found, the value stored in the payload of the node is returned.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">:</span> <span class="k">return</span> <span class="n">res</span><span class="p">.</span><span class="n">payload</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">currentNode</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">currentNode</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">elif</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">currentNode</span>

    <span class="k">elif</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></table></code></div></div><hr /><p><strong><code class="language-plaintext highlighter-rouge">in</code> method</strong></p><ul><li>implement the <code class="language-plaintext highlighter-rouge">in</code> operation by writing a <code class="language-plaintext highlighter-rouge">__contains__</code> method for the BinarySearchTree.<li>The <code class="language-plaintext highlighter-rouge">__contains__</code> method will simply call get and return <code class="language-plaintext highlighter-rouge">True</code> if get returns a value, or <code class="language-plaintext highlighter-rouge">False</code> if it returns None.<li>The code for <code class="language-plaintext highlighter-rouge">__contains__</code> is shown in Listing 6.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">):</span> <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
</pre></table></code></div></div><hr /><p><strong><code class="language-plaintext highlighter-rouge">del</code> method</strong></p><ul><li>the most challenging method in the binary search tree<li>The first task is to find the node to delete by searching the tree.<li>If the tree has more than one node, search using the <code class="language-plaintext highlighter-rouge">_get</code> method to find the <code class="language-plaintext highlighter-rouge">TreeNode</code> that needs to be removed.<li>If the tree only has a single node, that means removing the root of the tree, but we still must check to make sure the key of the root matches the key that is to be deleted.<li>In either case if the key is not found the <code class="language-plaintext highlighter-rouge">del</code> operator raises an error.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
  <span class="c1"># search the tree
</span>  <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">nodeToRemove</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">nodeToRemove</span><span class="p">:</span>
          <span class="n">self</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="n">nodeToRemove</span><span class="p">)</span>
          <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="k">raise</span> <span class="nc">KeyError</span><span class="p">(</span><span class="s">'Error, key not in tree'</span><span class="p">)</span>
  <span class="c1"># key is the root
</span>  <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
      <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="bp">None</span>
      <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="c1"># empty tree
</span>  <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="nc">KeyError</span><span class="p">(</span><span class="s">'Error, key not in tree'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
    <span class="n">self</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></table></code></div></div><p>found the node containing the key we want to delete, there are three cases must consider:</p><ul><li>The node to be deleted has no children<li>The node to be deleted has only one child<li>The node to be deleted has two children</ul><p><strong>The node to be deleted has no children</strong></p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1"># The node to be deleted has no children
</span><span class="k">if</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">isLeaf</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">currentNode</span> <span class="o">==</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span><span class="p">:</span>
        <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="bp">None</span>
</pre></table></code></div></div><p><strong>The node to be deleted has only one child</strong></p><ul><li>If a node has only a single child, then we can simply promote the child to take the place of its parent.<li>there are six cases to consider.<li>discuss the case where the current node has a left child.<ul><li>If the current node is a <code class="language-plaintext highlighter-rouge">left child</code><ul><li>then we only need to update the <code class="language-plaintext highlighter-rouge">parent reference of the left child</code> to point to the <code class="language-plaintext highlighter-rouge">parent of the current node</code>,<li>and then update the <code class="language-plaintext highlighter-rouge">left child reference of the parent</code> to point to the current node’s left child.</ul><li>If the current node is a <code class="language-plaintext highlighter-rouge">right child</code><ul><li>then we only need to update the <code class="language-plaintext highlighter-rouge">parent reference of the left child</code> to point to the <code class="language-plaintext highlighter-rouge">parent of the current node</code>,<li>and then update the <code class="language-plaintext highlighter-rouge">right child reference of the parent</code> to point to the current node’s left child.</ul><li>If the current node has no parent, it must be the root.<ul><li>In this case we will just replace the key, payload, leftChild, and rightChild data by calling the replaceNodeData method on the root.</ul></ul></ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1"># this node has one child
</span><span class="k">else</span><span class="p">:</span>
  <span class="c1"># leftchild -&gt; currentNode
</span>  <span class="k">if</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">hasLeftChild</span><span class="p">():</span>
      <span class="c1"># LeftChild -&gt; parent
</span>      <span class="k">if</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">isLeftChild</span><span class="p">():</span>
          <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span>
          <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span>
      <span class="c1"># parent &lt;- RightChild
</span>      <span class="k">elif</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">isRightChild</span><span class="p">():</span>
          <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span>
          <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="n">currentNode</span><span class="p">.</span><span class="nf">replaceNodeData</span><span class="p">(</span><span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">key</span><span class="p">,</span>
                                      <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">payload</span><span class="p">,</span>
                                      <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">leftChild</span><span class="p">,</span>
                                      <span class="n">currentNode</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">rightChild</span><span class="p">)</span>
  <span class="c1"># currentNode &lt;- RightChild
</span>  <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">isLeftChild</span><span class="p">():</span>
          <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span>
          <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span>
      <span class="k">elif</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">isRightChild</span><span class="p">():</span>
          <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span>
          <span class="n">currentNode</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="n">currentNode</span><span class="p">.</span><span class="nf">replaceNodeData</span><span class="p">(</span><span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">key</span><span class="p">,</span>
                             <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">payload</span><span class="p">,</span>
                             <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">leftChild</span><span class="p">,</span>
                             <span class="n">currentNode</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">rightChild</span><span class="p">)</span>
</pre></table></code></div></div><p><strong>The node to be deleted has two children</strong></p><ul><li>The third case is the most difficult case to handle<li>If a node has two children, then it is unlikely that we can simply promote one of them to take the node’s place.<li>however, search the tree for a node that can be used to replace the one scheduled for deletion.<li>find a node that will preserve the binary search tree relationships for both of the existing left and right subtrees.<li>The node that will do this is the node that has the next-largest key in the tree. We call this node the successor, and we will look at a way to find the successor shortly.<li>The successor is guaranteed to have no more than one child, so we know how to remove it using the two cases for deletion that we have already implemented.<li>Once the successor has been removed, we simply put it in the tree in place of the node to be deleted.<li>make use of the <code class="language-plaintext highlighter-rouge">helper</code> methods <code class="language-plaintext highlighter-rouge">findSuccessor</code> and findMin to find the successor.<li>To remove the successor, we make use of the method <code class="language-plaintext highlighter-rouge">spliceOut</code>.<ul><li>it goes directly to the node to splice out and makes the right changes.<li>We could call delete recursively, but then we would waste time re-searching for the key node.</ul></ul><p>The code to find the successor is a method of the <code class="language-plaintext highlighter-rouge">TreeNode</code> class.</p><ul><li>This code makes use of the same properties of binary search trees that cause an inorder traversal to print out the nodes in the tree from smallest to largest.<li>There are three cases to consider when looking for the successor:<ul><li>If the node has a right child, then the successor is the smallest key in the right subtree.<li>If the node has no right child and is the left child of its parent, then the parent is the successor.<li>If the node is the right child of its parent, and itself has no right child, then the successor to this node is the successor of its parent, excluding this node.</ul></ul><p>The <code class="language-plaintext highlighter-rouge">findMin</code> method is called to find the minimum key in a subtree.</p><ul><li>the minimum valued key in any binary search tree is the leftmost child of the tree.<li>Therefore the findMin method simply follows the leftChild references in each node of the subtree until it reaches a node that does not have a left child.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">#interior
</span><span class="k">elif</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">hasBothChildren</span><span class="p">():</span>
  <span class="n">succ</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">.</span><span class="nf">findSuccessor</span><span class="p">()</span>
  <span class="n">succ</span><span class="p">.</span><span class="nf">spliceOut</span><span class="p">()</span>
  <span class="n">currentNode</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">succ</span><span class="p">.</span><span class="n">key</span>
  <span class="n">currentNode</span><span class="p">.</span><span class="n">payload</span> <span class="o">=</span> <span class="n">succ</span><span class="p">.</span><span class="n">payload</span>
</pre></table></code></div></div><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">findSuccessor</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="n">succ</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">hasRightChild</span><span class="p">():</span>
        <span class="n">succ</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="nf">findMin</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">:</span>
               <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">isLeftChild</span><span class="p">():</span>
                   <span class="n">succ</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span>
               <span class="k">else</span><span class="p">:</span>
                   <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="bp">None</span>
                   <span class="n">succ</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="nf">findSuccessor</span><span class="p">()</span>
                   <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">self</span>
    <span class="k">return</span> <span class="n">succ</span>

<span class="k">def</span> <span class="nf">findMin</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">self</span>
    <span class="k">while</span> <span class="n">current</span><span class="p">.</span><span class="nf">hasLeftChild</span><span class="p">():</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">leftChild</span>
    <span class="k">return</span> <span class="n">current</span>

<span class="k">def</span> <span class="nf">spliceOut</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">isLeaf</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">isLeftChild</span><span class="p">():</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="nf">hasAnyChildren</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">hasLeftChild</span><span class="p">():</span>
      <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">isLeftChild</span><span class="p">():</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span>
      <span class="k">else</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span>
      <span class="n">self</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">isLeftChild</span><span class="p">():</span>
        <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span>
      <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span>
</pre></table></code></div></div><hr /><p><strong><code class="language-plaintext highlighter-rouge">__iter__</code> iterate over all the keys</strong></p><p>to simply iterate over all the keys in the tree in order.</p><ul><li>using the inorder traversal algorithm.<li>the iterator requires a bit more work, since an iterator should return only one node each time the iterator is called.</ul><p><code class="language-plaintext highlighter-rouge">yield</code> is similar to return in that it returns a value to the caller.</p><ul><li>However, <code class="language-plaintext highlighter-rouge">yield</code> also takes the additional step of freezing the state of the function so that the next time the function is called it continues executing from the exact point it left off earlier. Functions that create objects that can be iterated are called generator functions.</ul><p>The code for an inorder iterator of a binary tree is shown in the next listing. Look at this code carefully; at first glance you might think that the code is not recursive. However, remember that <code class="language-plaintext highlighter-rouge">__iter__</code> overrides the for x in operation for iteration, so it really is recursive! Because it is recursive over TreeNode instances the <code class="language-plaintext highlighter-rouge">__iter__</code> method is defined in the TreeNode class.</p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
   <span class="k">if</span> <span class="n">self</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">hasLeftChild</span><span class="p">():</span>
             <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">leftChiLd</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">elem</span>
      <span class="k">yield</span> <span class="n">self</span><span class="p">.</span><span class="n">key</span>
      <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="nf">hasRightChild</span><span class="p">():</span>
             <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">rightChild</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">elem</span>
</pre></table></code></div></div><hr /><h5 id="search-tree-analysis-𝑂log2𝑛-to-𝑂𝑛">Search Tree Analysis <code class="language-plaintext highlighter-rouge">𝑂(log2𝑛) to 𝑂(𝑛)</code></h5><ul><li>The number of nodes at any particular level is 2𝑑 where 𝑑 is the depth of the level.<li><p>The total number of nodes in a perfectly balanced binary tree is 2^(ℎ+1)−1, where ℎ represents the height of the tree.</p><li>A perfectly balanced tree has the same number of nodes in the left subtree as the right subtree.<li>In a balanced binary tree, the worst-case performance of put is <code class="language-plaintext highlighter-rouge">𝑂(log2𝑛)</code>, where <code class="language-plaintext highlighter-rouge">𝑛</code> is the number of nodes in the tree.<ul><li>this is the inverse relationship to the calculation in the previous paragraph.<li>So <code class="language-plaintext highlighter-rouge">log2𝑛</code> gives us the height of the tree, and represents the maximum number of comparisons that put will need to do as it searches for the proper place to insert a new node.</ul><li>Unfortunately it is possible to construct a search tree that has height 𝑛 simply by inserting the keys in sorted order!<ul><li>In this case the performance of the put method is <code class="language-plaintext highlighter-rouge">𝑂(𝑛)</code></ul><li>the performance of the put method is limited by the height of the tree, you can probably guess that other methods, get, in, and del, are limited as well. Since get searches the tree to find the key, in the worst case the tree is searched all the way to the bottom and no key is found. At first glance del might seem more complicated, since it may need to search for the successor before the deletion operation can complete. But remember that the worst-case scenario to find the successor is also just the height of the tree which means that you would simply double the work. Since doubling is a constant factor it does not change worst case</ul><hr /><h2 id="applications-of-tree-traversals">Applications of Tree Traversals</h2><hr /><h3 id="table-of-contents">Table of Contents</h3><h4 id="preorder-1-n-l-r">preorder 1 <code class="language-plaintext highlighter-rouge">N-L-R</code></h4><p><img data-proofer-ignore data-src="https://i.imgur.com/CLdamir.png" alt="Screen Shot 2022-03-29 at 07.32.16" /></p><Font color="red"> The unindented version (a) &lt;/font&gt; - given a tree T supporting the `preorder()` method: - `for (Position<E> p : T.preorder()) System.out.println(p.getElement( ));` <Font color="red"> The version (b) &lt;/font&gt; - indent each element with a number of spaces equal to twice the element’s depth in the tree - given a tree T supporting the `preorder()` method: ```java // the work to produce the preorder traversal runs in O(n) time // the calls to depth incur a hidden cost. // Making a call to depth from every position of the tree results in O(n^2) worst-case time for (Position<E> p : T.preorder()) { System.out.println(spaces(2∗T.depth(p)) + p.getElement()); } // A preferred approach to producing an indented table of contents is to redesign a top-down recursion that includes the current depth as an additional parameter. // implementation runs in worst-case O(n) time // ∗∗ Prints preorder representation of subtree of T rooted at p having depth d. ∗/ public static <E> void printPreorderIndent(Tree<E> T, Position<E> p, int d) { System.out.println(spaces(2∗d) + p.getElement()); // indent based on d for (Position<E> c : T.children(p)) printPreorderIndent(T, c, d+1); // child depth is d+1 } ``` --- #### preorder 2 `N-L-R` ![Screen Shot 2022-03-29 at 07.38.37](https://i.imgur.com/0G9eyDE.png) - the numbering was embedded within the elements of the tree. - using a preorder traversal to display the structure of a tree, with indentation and also explicit numbering that was not present in the tree. - more challenging - because the numbers used as labels are implicit in the structure of the tree. - label depends on the path from the root to the current position. - add an additional parameter to the recursive signature. - send a list of integers representing the labels leading to a particular position. - For example - node Domestic, send the list of values {2,1} that comprise its label. ```java // /∗∗ Prints labeled representation of subtree of T rooted at p having depth d. ∗/ public static <E> void printPreorderLabeled(Tree<E> T, Position<E> p, ArrayList<Integer> path) { int d = path.size(); // depth equals the length of the path System.out.print(spaces(2*d)); // print indentation, then label for (int j=0; j &lt; d; j++) System.out.print(path.get(j) + (j == d−1 ? " " : ".")); System.out.println(p.getElement( )); path.add(1); // add path entry for first child for (Position<E> c : T.children(p)) { printPreorderLabeled(T, c, path); // increment last entry of path path.set(d, 1 + path.get(d)); } path.remove(d);// restore path to its incoming state } ``` --- ### Computing Disk Space `postorder L-R-N` - The recursive computation of disk space is emblematic of a **postorder** traversal, as we cannot effectively compute the total space used by a directory until after we know the space that is used by its children directories. - We would like to have a mechanism for children to return information to the parent as part of the traversal process. ```java // ∗∗ Returns total disk space for subtree of T rooted at p. ∗/ public static int diskSpace(Tree<Integer> T, Position<Integer> p) { int subtotal = p.getElement(); // we assume element represents space usage for (Position<Integer> c : T.children(p)) subtotal += diskSpace(T, c); return subtotal; } ``` --- ### Parenthetic Representations of a Tree - It is not possible to reconstruct a general tree, given only the preorder sequence of elements - Some additional context is necessary for the structure of the tree to be well defined. - The use of indentation or numbered labels provides such context, with a very human-friendly presentation. - However, there are more concise string representations of trees that are computer-friendly. one such representation - The parenthetic string representation P(T) of tree T is recursively defined. - If T consists of a single position p, then `P(T ) = p.getElement( )`. - Otherwise, it is defined recursively as, `P(T)= p.getElement()+"("+P(T1)+","+ ··· +","+P(Tk)+")"` - where p is the root of T and - T1,T2,...,Tk are the subtrees rooted at the children of p, which are given in order if T is an ordered tree. - We are using “+” here to denote string concatenation. ![Screen Shot 2022-03-29 at 07.38.37](https://i.imgur.com/0G9eyDE.png) - As an example, the parenthetic representation of the tree of Figure 8.2 would appear as follows (line breaks are cosmetic): - Electronics R’Us (R&amp;D, Sales (Domestic, International (Canada, S. America, Overseas (Africa, Europe, Asia, Australia))), Purchasing, Manufacturing (TV, CD, Tuner)) Although the parenthetic representation is essentially a preorder traversal - cannot easily produce the additional punctuation using the formal implementation of preorder. - The opening parenthesis must be produced just before` the loop over a position’s children`, the separating commas between children, and the closing parenthesis just after the loop completes. ```java // /∗∗ Prints parenthesized representation of subtree of T rooted at p. ∗/ public static <E> void parenthesize(Tree<E> T, Position<E> p) { System.out.print(p.getElement()); if (T.isInternal(p)) { boolean firstTime = true; for(Position<E> c : T.children(p)){ System.out.print( (firstTime ? " (" : ", ") ); // determine proper punctuation firstTime = false; parenthesize(T, c); } System.out.print(")"); } } ``` --- ### Using Inorder Traversal for Tree Drawing An inorder traversal can be applied to compute a graphical layout of a binary tree - assume that x-coordinates increase left to right and y-coordinates increase top to bottom, - so that the origin is in the upper left corner of the drawing. ![Screen Shot 2022-03-30 at 22.28.04](https://i.imgur.com/bkHrXjA.png) The geometry is determined by an algorithm that - assigns x- and y-coordinates to each position p of a binary tree T using the following two rules: - x(p) is the number of positions visited before p in an inorder traversal of T. - y(p) is the depth of p inT. ```java public static <E> int layout(BinaryTree<E> T, Position<E> p, int d, int x) { if (T.left(p) != null) x = layout(T, T.left(p), d+1, x); p.getElement().setX(x++); p.getElement().setY(d); if (T.left(p) != null) x = layout(T, T.left(p), d+1, x); return x; } ``` --- ### Euler Tours - not every application strictly fits the mold of a preorder, postorder, or inorder traversal. - We can unify the tree-traversal algorithms into a single framework known as an `Euler tour traversal`. - The Euler tour traversal of a tree T can be informally defined as `a “walk” around T` - where we start by going from the root toward its leftmost child, viewing the edges of T as being “walls” that we always keep to our left ![Screen Shot 2022-03-30 at 22.39.02](https://i.imgur.com/Qg59Ibi.png) The complexity of the walk is `O(n)`, for a tree with n nodes, - because it progresses exactly two times along each of the n − 1 edges of the tree - once going downward along the edge, - and later going upward along the edge. - To unify the concept of preorder and postorder traversals, we can view there being two notable “visits” to each position p: - A “pre visit” occurs when first reaching the position, that is, when the walk passes immediately left of the node in our visualization. - A “postvisit” occurs when the walk later proceed supward from that position, that is, when the walk passes to the right of the node in our visualization. The process of an Euler tour can be naturally viewed as recursive. - In between the “pre visit” and “post visit” of a given position will be a recursive tour of each of its subtrees. - Looking at Figure 8.20 as an example, there is a contiguous portion of the entire tour that is itself an Euler tour of the subtree of the node with element “/”. That tour contains two contiguous subtours, one traversing that position’s left subtree and another traversing the right subtree. - In the special case of a binary tree, we can designate the time when the walk passes immediately below a node as an “in visit” event. - This will be just after the tour of its left subtree (if any), but before the tour of its right subtree (if any). #### pseudocode - pseudocode for an Euler tour traversal of a subtree rooted at a position p <font color="red"> Algorithm </font> eulerTour(T , p): - perform the `“pre visit” action` for position p - **for** each child c in T.children(p) **do** - eulerTour(T , c) { recursively tour the subtree rooted at c } - perform the `“post visit” action` for position p The Euler tour traversal extends the preorder and postorder traversals, but it can also perform other kinds of traversals. For example, suppose we wish to compute the number of descendants of each position p in an n-node binary tree. - We start an Euler tour by initializing a counter to 0, and then increment the counter during the “pre visit” for each position. To determine the number of descendants of a position p, we compute the difference between the values of the counter from when the pre-visit occurs and when the post-visit occurs, and add 1 (for p). - This simple rule gives us the number of descendants of p, because each node in the subtree rooted at p is counted between p’s visit on the left and p’s visit on the right. - Therefore, we have an O(n)-time method for computing the number of descendants of each node. For the case of a binary tree, we can customize the algorithm to include an explicit “in visit” action <font color="red"> Algorithm </font> eulerTourBinary(T , p): - perform the `“pre visit” action` for position p - **if** p has a left child lc **then** - eulerTourBinary(T , lc) { recursively tour the left subtree of p } - perform the `“in visit” action` for position p - **if** p has a right child rc **then** - eulerTourBinary(T , rc) { recursively tour the right subtree of p } - perform the `“post visit” action` for position p ![Screen Shot 2022-03-30 at 22.39.02](https://i.imgur.com/Qg59Ibi.png) - For example - binary Euler tour can produce a traditional parenthesized arithmetic expression - such as `"((((3+1)x3)/((9-5)+2))-((3x(7-4))+6))"` for the tree as follows: - “Pre visit” action: if the position is internal, print “(”. - “In visit” action: print the value or operator stored at the position. - “Post visit” action: if the position is internal, print “)”. --- ## Balanced Binary Search Trees &gt; the binary search tree can degrade to `𝑂(𝑛)` for operations like get and put when the tree becomes unbalanced. **Balanced Binary Search Trees** - binary search tree -&gt; the tree remains balanced at all times. - This tree is called an **AVL tree** -&gt; inventors: G.M. Adelson-Velskii and E.M. Landis. An AVL tree implements the `Map` `abstract data type` just like a regular binary search tree, - the only difference is in how the tree performs. - To implement our AVL tree we need to keep track of a `balance factor` for each node in the tree. - We do this by looking at the heights of the left and right subtrees for each node. - <font color="red"> balance factor for a node: </font> - the difference between the `height of the left subtree` and the `height of the right subtree`. - `𝑏𝑎𝑙𝑎𝑛𝑐𝑒𝐹𝑎𝑐𝑡𝑜𝑟=ℎ𝑒𝑖𝑔ℎ𝑡(𝑙𝑒𝑓𝑡𝑆𝑢𝑏𝑇𝑟𝑒𝑒)−ℎ𝑒𝑖𝑔ℎ𝑡(𝑟𝑖𝑔ℎ𝑡𝑆𝑢𝑏𝑇𝑟𝑒𝑒)` - `𝑏𝑎𝑙𝑎𝑛𝑐𝑒𝐹𝑎𝑐𝑡𝑜𝑟= | ℎ𝑒𝑖𝑔ℎ𝑡(𝑙𝑒𝑓𝑡𝑆𝑢𝑏𝑇𝑟𝑒𝑒) − ℎ𝑒𝑖𝑔ℎ𝑡(𝑟𝑖𝑔ℎ𝑡𝑆𝑢𝑏𝑇𝑟𝑒𝑒) | ` - `𝑏𝑎𝑙𝑎𝑛𝑐𝑒 : | ℎ𝑒𝑖𝑔ℎ𝑡(𝑙𝑒𝑓𝑡𝑆𝑢𝑏𝑇𝑟𝑒𝑒) − ℎ𝑒𝑖𝑔ℎ𝑡(𝑟𝑖𝑔ℎ𝑡𝑆𝑢𝑏𝑇𝑟𝑒𝑒) | &lt;= 1` - `𝑏𝑎𝑙𝑎𝑛𝑐𝑒 : 𝑏𝑎𝑙𝑎𝑛𝑐𝑒𝐹𝑎𝑐𝑡𝑜𝑟 &lt;= 1` ![Screen Shot 2021-09-30 at 1.22.34 PM](https://i.imgur.com/IStFEbJ.png) ![Screen Shot 2021-09-30 at 1.24.44 PM](https://i.imgur.com/6zs8rDx.png) - a subtree is `left-heavy` if the balance factor is greater than zero. - If the balance factor is less than zero then the subtree is `right heavy`. - If the balance factor is zero then the tree is `perfectly in balance`. For purposes of implementing an AVL tree - we will define a tree to be in balance if the balance factor is `-1, 0, or 1`. - Once the balance factor of a node in a tree is outside this range we will need to have a procedure to bring the tree back into balance. --- ### AVL Tree Performance Before we proceed any further let’s look at the result of enforcing this new balance factor requirement. - by ensuring tree always has a balance factor of `-1, 0, or 1` we can get better `Big-O` performance of key operations. - Let us start by thinking about how this balance condition changes the worst-case tree. - There are two possibilities to consider, - a left-heavy tree and a right heavy tree. - If we consider trees of heights 0, 1, 2, and 3, Figure 2 illustrates the most unbalanced left-heavy tree possible under the new rules. - for the number of nodes in a tree of height `h`: `𝑁ℎ=1+𝑁ℎ−1+𝑁ℎ−2` `Root.AVLTree = RChild.AVLTree + LChild.AVLTree` <font color="blue"> worse case, less node: </font> - same height - min nodes - `RChild.AVLTree.Height - LChild.AVLTree.Height &lt;= 1` <font color="blue"> if not, not balanced: </font> ![Screen Shot 2021-09-30 at 9.37.06 PM](https://i.imgur.com/T3Ehnv6.png) [derivation](https://runestone.academy/runestone/books/published/pythonds/Trees/AVLTreePerformance.html) - This derivation shows us that at any time the height of our AVL tree is equal to a constant(1.44) times the log of the number of nodes in the tree. - This is great news for searching our AVL tree because it limits the search to `𝑂(log𝑁)`. **keeping an AVL tree in balance is going to be a big performance improvement** --- ### AVL Tree Implementation **new Node** - Since all new keys are inserted into the tree as `leaf nodes` and the `balance factor` for a new leaf is `zero` - no new requirements for the node that was just inserted. **Node.parent** - But once the new leaf is added we must update the `balance factor` of its parent. - new leaf affects the parent’s balance factor depends on whether the leaf node is a left child or a right child. - If the new node is a `right` child, the balance factor of the parent `- 1` - If the new node is a `left` child. then the balance factor of the parent `+ 1` - This relation can be applied recursively to the grandparent of the new node, and possibly to every ancestor all the way up to the root of the tree. **`updateBalance`** - two base cases for updating balance factors: - The recursive call has reached the root of the tree. - The balance factor of the parent has been adjusted to zero. - once a subtree has a balance factor of zero, then the balance of its ancestor nodes does not change. Implement the AVL tree as a subclass of BinarySearchTree. - verride the `_put` method and write a new `updateBalance` helper method. - the definition for `_put` is exactly the same as in simple binary search trees except for the additions of the calls to updateBalance on lines 7 and 13. ```py def _put(self, key, val, currentNode): # -&gt; key will be currentNode.leftchild if key &lt; currentNode.key: if currentNode.hasLeftChild(): self._put(key,val, currentNode.leftChild) else: currentNode.leftChild = TreeNode(key,val,parent=currentNode) self.updateBalance(currentNode.leftChild) # -&gt; key will be currentNode.rightchild else: if currentNode.hasRightChild(): self._put(key,val, currentNode.rightChild) else: currentNode.rightChild = TreeNode(key,val,parent=currentNode) self.updateBalance(currentNode.rightChild) def updateBalance(self,node): # be balenced itself if node.balanceFactor &gt; 1 or node.balanceFactor &lt; -1: self.rebalance(node) return # if have parent if node.parent != None: if node.isLeftChild(): node.parent.balanceFactor += 1 elif node.isRightChild(): node.parent.balanceFactor -= 1 # if parent become unbalanced, rebalance it if node.parent.balanceFactor != 0: self.updateBalance(node.parent) ``` The new `updateBalance` method is where most of the work is done. - This implements the recursive procedure - If the **current node is out of balance enough to require rebalancing** - then the `rebalancing is done` and no further updating to parents is required. - If the **current node does not require rebalancing** - then the balance factor of the parent is adjusted. - If the **balance factor of the parent is non-zero** - then the algorithm continues to work its way up the tree toward the root by recursively calling `updateBalance` on the parent. **`rebalance`** When a rebalancing of the tree is necessary - Efficient rebalancing is the key to making the AVL Tree work well without sacrificing performance. - In order to bring an AVL Tree back into balance we will perform one or more rotations on the tree. ![Screen Shot 2021-09-30 at 9.54.31 PM](https://i.imgur.com/HEcpmWW.png) ![Screen Shot 2021-09-30 at 9.55.02 PM](https://i.imgur.com/uwWs5Qf.png) ![simpleunbalanced](https://i.imgur.com/4yZPpbt.png) step: - Promote the right child (B) to be the root of the subtree. - Move the old root (A) to be the left child of the new root. - If new root (B) already had a left child then make it the right child of the new left child (A). Note: Since the new root (B) was the right child of A the right child of A is guaranteed to be empty at this point. This allows us to add a new node as the right child without any further consideration. ```py def rotateLeft(self,rotRoot): newRoot = rotRoot.rightChild rotRoot.rightChild = newRoot.leftChild if newRoot.leftChild != None: newRoot.leftChild.parent = rotRoot newRoot.parent = rotRoot.parent if rotRoot.isRoot(): self.root = newRoot else: # make rotroot.parent.child to newroot if rotRoot.isLeftChild(): rotRoot.parent.leftChild = newRoot else: rotRoot.parent.rightChild = newRoot # make rotroot.parent to newroot newRoot.leftChild = rotRoot rotRoot.parent = newRoot rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0) newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0) ``` example: ![bfderive](https://i.imgur.com/q6a8tBa.png) - 𝑜𝑙𝑑𝐵𝑎𝑙(𝐵)=ℎ𝐴−ℎ𝐷 - 𝑛𝑒𝑤𝐵𝑎𝑙(𝐵)=ℎ𝐴−ℎ𝐶 - 𝑜𝑙𝑑h(D) = 1 + 𝑚𝑎𝑥(ℎ𝐶,ℎ𝐸) - 𝑜𝑙𝑑𝐵𝑎𝑙(𝐵)= ℎ𝐴 − (1 + 𝑚𝑎𝑥(ℎ𝐶,ℎ𝐸)) - 𝑛𝑒𝑤𝐵𝑎𝑙(𝐵)−𝑜𝑙𝑑𝐵𝑎𝑙(𝐵) = ℎ𝐴−ℎ𝐶 − (ℎ𝐴−(1+𝑚𝑎𝑥(ℎ𝐶,ℎ𝐸))) - 𝑛𝑒𝑤𝐵𝑎𝑙(𝐵)−𝑜𝑙𝑑𝐵𝑎𝑙(𝐵) = ℎ𝐴−ℎ𝐶 − ℎ𝐴 +(1+𝑚𝑎𝑥(ℎ𝐶,ℎ𝐸)) - 𝑛𝑒𝑤𝐵𝑎𝑙(𝐵)−𝑜𝑙𝑑𝐵𝑎𝑙(𝐵) = ℎ𝐴−ℎ𝐴 +1 +𝑚𝑎𝑥(ℎ𝐶,ℎ𝐸) −ℎ𝐶 - 𝑛𝑒𝑤𝐵𝑎𝑙(𝐵)−𝑜𝑙𝑑𝐵𝑎𝑙(𝐵) = 1 + 𝑚𝑎𝑥(ℎ𝐶,ℎ𝐸) −ℎ𝐶 - 𝑚𝑎𝑥(𝑎,𝑏)−𝑐 = 𝑚𝑎𝑥(𝑎−𝑐,𝑏−𝑐) - 𝑛𝑒𝑤𝐵𝑎𝑙(𝐵) = 𝑜𝑙𝑑𝐵𝑎𝑙(𝐵) +1 + 𝑚𝑎𝑥(ℎ𝐶−ℎ𝐶,ℎ𝐸−ℎ𝐶) - ℎ𝐸−ℎ𝐶 = −𝑜𝑙𝑑𝐵𝑎𝑙(𝐷) - 𝑚𝑎𝑥(−𝑎,−𝑏) = −𝑚𝑖𝑛(𝑎,𝑏) - 𝑛𝑒𝑤𝐵𝑎𝑙(𝐵) = 𝑜𝑙𝑑𝐵𝑎𝑙(𝐵) +1 +𝑚𝑎𝑥(0,−𝑜𝑙𝑑𝐵𝑎𝑙(𝐷)) - 𝑛𝑒𝑤𝐵𝑎𝑙(𝐵) = 𝑜𝑙𝑑𝐵𝑎𝑙(𝐵) +1 −𝑚𝑖𝑛(0,𝑜𝑙𝑑𝐵𝑎𝑙(𝐷)) - rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(0,newRoot.balanceFactor) To correct the balance: - If a subtree needs a `left rotation` to bring it into balance, - first check the balance factor of the right child. - If the right child is left heavy then do a `right rotation` on right child, - followed by the `original left rotation`. - If a subtree needs a `right rotation` to bring it into balance, - first check the balance factor of the left child. - If the left child is right heavy then do a `left rotatio`n on the left child, - followed by the `original right rotation`. ```py def rebalance(self,node): if node.balanceFactor &lt; 0: if node.rightChild.balanceFactor &gt; 0: self.rotateRight(node.rightChild) self.rotateLeft(node) else: self.rotateLeft(node) elif node.balanceFactor &gt; 0: if node.leftChild.balanceFactor &lt; 0: self.rotateLeft(node.leftChild) self.rotateRight(node) else: self.rotateRight(node) ``` --- #### analyze By keeping the tree in balance at all times, ensure that the `get` method will run in order `𝑂(𝑙𝑜𝑔2(𝑛))` time. cost to our `put` method - Since a new node is inserted as a leaf, - updating the balance factors of all the parents will require a maximum of `𝑙𝑜𝑔(𝑛)` operations, one for each level of the tree. - If a subtree is found to be out of balance a maximum of two rotations are required to bring the tree back into balance. - But, each of the rotations works in `𝑂(1)` time, so even our put operation remains `𝑂(𝑙𝑜𝑔(𝑛))`. --- ## Binary Search Tree code (depth-first) ### Binary Search Tree Search in java ```java public class BSTSearch { public Node search(Node root, int key) { if (root.data == null) { return null;} if (root.data == key) { return root;} else if (root.data &gt; key) { search(root.left, key); } else { search(root.right, key); } } public static void main(String args[]){ BinaryTree bt = new BinaryTree(); Node root = null; root = bt.addNode(10, root); root = bt.addNode(20, root); root = bt.addNode(-10, root); root = bt.addNode(15, root); root = bt.addNode(0, root); root = bt.addNode(21, root); root = bt.addNode(-1, root); BSTSearch bstSearch = new BSTSearch(); Node result = bstSearch.search(root, 21); assert result.data == 21; result = bstSearch.search(root, -1); assert result.data == 21; result = bstSearch.search(root, 11); assert result == null; } } ``` --- ## Binary Search Tree Insertion (Iterative method) worst: O(n) ```Java public class BinaryTree{ public Node insert(Node root, int data){ Node node = new Node(data); if (root == null) { return node; } Node parent = null; Node current = root; while (root != null) { parent = root; if (root.data &lt; data) { root = root.right; } else { root = root.left; } } if (parent.data &lt; data) { parent.right = data; } else { parent.left = data; } return parent; // if (root.data &lt; key &amp;&amp; root.next == null) { // root.left.data == key // } // if (root.data &gt; key &amp;&amp; root.next == null) { // root.left.data == key // } // if (root.next != null) { // root = root.next; // bstInsert(Node root.next, int key); // } } } ``` --- --- ## Size Of Binary Tree `node numebr` ![Screen Shot 2020-07-24 at 13.30.14](https://i.imgur.com/mbLl3ws.png ) ```java public class SizeOfBinaryTree { public int size(Node root){ if(root == null){ return 0; } return size(root.left) + size(root.right) + 1; } public static void main(String args[]){ BinaryTree bt = new BinaryTree(); Node head = null; head = bt.addNode(10, head); head = bt.addNode(15, head); head = bt.addNode(5, head); head = bt.addNode(7, head); head = bt.addNode(19, head); head = bt.addNode(20, head); head = bt.addNode(-1, head); SizeOfBinaryTree sbt = new SizeOfBinaryTree(); System.out.println(sbt.size(head)); } } ``` --- ## check if Balanced time: O(n) space: O(H) --- ## check Height Of Binary Tree time &amp; space: O(n) ![Screen Shot 2020-07-24 at 13.29.49](https://i.imgur.com/WrgJy8X.png ) ```java public class SameTree { public int height(Node root){ if(root == null){ return 0; } int leftHeight = height(root.left); int rightHeight = height(root.right); return Math.max(leftHeight, rightHeight) + 1; } // public int height(Node root){ // if(root.left == null &amp;&amp; root.right == null) { // return 1; // } // else { // return 0; // } // return 1 + height(root.right) + height(root.left) // } } ``` --- ## Root To Leaf Sum Binary Tree ![Screen Shot 2020-07-24 at 13.29.20](https://i.imgur.com/ezvZIHd.png ) ```java public class Root { public boolean RootToLeaf(Node root, int sum, list<Integer result="">) { if (root == null) {return false;} if (root.left == null &amp;&amp; root.right == null) { if (root.data == sum) { result.add(root.data); return true; } else {return false;} } if (RootToLeaf(Node root.left, int sum-root.data, list<Integer result="">)) { result.add(root.data); return true; } else {return false;} if (RootToLeaf(Node root.right, int sum-root.data, list<Integer result="">)) { result.add(root.data); return true; } else {return false;} return false; } } ``` --- ## Check if Binary Tree is Binary Search Tree ![Screen Shot 2020-07-24 at 13.34.44](https://i.imgur.com/8uaDJ2C.png ) ```java public class Root { public boolean isBST(Node root, int min, int max) { if (root == null) {return true;} if (root.data &lt; min || root.data &gt; max) {return false;} return isBST(root.left, min, root.data) &amp;&amp; isBST(root, root.data, max) } } ``` --- # Binary Search Tree code (Level Order -&gt; queue) ![Screen Shot 2020-07-24 at 13.44.59](https://i.imgur.com/f5M3oF1.png ) time: O(n) space: the size of the tree, O(n) --- ## Level Order Traversal (in one line) ![Screen Shot 2020-07-24 at 13.53.38](https://i.imgur.com/nd0fEXX.png ) ```java public class LevelOrderTraversal { public void levelOrder(Node root){ if(root == null){ System.out.println("Please enter a valid tree!"); return; } Queue<Node> queue = new LinkedList<Node>(); queue.offer(root); while(queue.size() &gt; 0){ root = queue.poll(); System.out.print(root.data + " "); if(root.left != null){ queue.add(root.left); } if(root.right != null){ queue.add(root.right); } } } public static void main(String args[]){ LevelOrderTraversal loi = new LevelOrderTraversal(); BinaryTree bt = new BinaryTree(); Node head = null; head = bt.addNode(10, head); head = bt.addNode(15, head); head = bt.addNode(5, head); head = bt.addNode(7, head); head = bt.addNode(19, head); head = bt.addNode(20, head); head = bt.addNode(-1, head); loi.levelOrder(head); } } ``` --- ## Level by Level Printing (in different line) 1. use 2 quesues ![Screen Shot 2020-07-25 at 00.49.14](https://i.imgur.com/eeISHog.png ) ```java void levelByLevelTwoQueue(Node root) { if (root==null) return; Queue<Node> q1 = new Queue<Node>(); Queue<Node> q2 = new Queue<Node>(); q1.add(root); while ( !q1.isEmpty() || !q2.isEmpty() ) { while (!q1.isEmpty()) { root=q1.pull(); System.out.print(root); if (root.left != null) {q2.add(root.left);} if (root.right != null) {q2.add(root.right);} } System.out.println(); while (!q2.isEmpty()) { root=q2.pull(); System.out.print(root); if (root.left != null) {q1.add(root.left);} if (root.right != null) {q1.add(root.right);} } System.out.println(); } } ``` 2. use 1 queue ![Screen Shot 2020-07-25 at 00.52.36](https://i.imgur.com/YvovZpO.png ) ```java void levelByLevelOneQueueUsingDelimiter(Node root) { if (root==null) return; Queue<Node> q = new Queue<Node>(); q.add(root); while (!q.isEmpty()) { root=q.poll(); if (root==null) { System.out.println(); break } if (root != null) { System.out.print(root.data + " "); if (root.left != null) { q.add(root.left); } if (root.left != null) { q.add(root.left); } } q.add(null); } } public void levelByLevelOneQueueUsingDelimiter(Node root) { if (root == null) { return; } Queue<Node> q = new LinkedList<Node>(); q.offer(root); q.offer(null); while (!q.isEmpty()) { root = q.poll(); if (root != null) { System.out.print(root.data + " "); if (root.left != null) { q.offer(root.left); } if (root.right != null) { q.offer(root.right); } } else { if (!q.isEmpty()) { System.out.println(); q.offer(null); } } } } ``` 3. 1 queue &amp; 2 conter ![Screen Shot 2020-07-25 at 01.41.49](https://i.imgur.com/kcl3RcP.png ) ![Screen Shot 2020-07-25 at 00.57.11](https://i.imgur.com/pl4FPNv.png ) ```java public void levelByLevelOneQueueUsingCount(Node root) { if (root == null) return; Queue<Node> q = new LinkedList<Node>(); int levelCount = 1; int currentCount = 0; int current = 0; q.add(root); while (!q.isEmpty()) { while (levelCount &gt; 0) { current = q.poll(); if (current.left != null) { q.add(root.left); currentCount++; } if (current.right != null) { q.add(root.right); currentCount++; } System.out.print(current.data + " "); levelCount--; } System.out.println(); levelCount = currentCount; currentCount = 0; } } ``` --- ## `Reverse` level order traversal binary tree ![Screen Shot 2020-07-25 at 01.55.58](https://i.imgur.com/UJFL9fn.png ) ```java public void reverseLevelOrderTraversal(Node root) { if (root=null) return; Stack<Node> s = new Stack<Node>(); Queue<Node> q = new Queue<Node>(); q.add(root); while(!q.isEmpty()){ current = q.poll(); if (current.right != null) { q.add(root.right); } if (current.left != null) { q.add(root.left); } s.push(current) } while(!s.isEmpty()){ System.out.print(s.pop().data + " "); } } ``` --- # Handshaking Lemma and Interesting Tree Properties ?? --- # Enumeration of Binary Trees ??? A Binary Tree is `labeled` if every node is assigned a label a Binary Tree is `unlabeled` if nodes are not assigned any label. ``` Below two are considered same unlabeled trees o o / \ / \ o o o o Below two are considered different labeled trees A C / \ / \ B C A B ``` How many different Unlabeled Binary Trees can be there with n nodes? ``` For n = 1, there is only one tree o For n = 2, there are two possible trees o o / \ o o For n = 3, there are five possible trees o o o o o / \ / \ / \ o o o o o o / \ \ / o o o o ``` The idea is to `consider all possible pair of counts for nodes in left and right subtrees` and multiply the counts for a particular pair. Finally add results of all pairs. ``` For example, let T(n) be count for n nodes. T(0) = 1 [There is only 1 empty tree] T(1) = 1 T(2) = 2 T(3) = T(0)*T(2) + T(1)*T(1) + T(2)*T(0) = 1*2 + 1*1 + 2*1 = 5 T(4) = T(0)*T(3) + T(1)*T(2) + T(2)*T(1) + T(3)*T(0) = 1*5 + 1*2 + 2*1 + 5*1 = 14 ``` The above pattern basically represents n`th Catalan Numbers. First few catalan numbers are 1 1 2 5 14 42 132 429 1430 4862,… T(n)=\sum_{i=1}^{n}T(i-1)T(n-i)=\sum_{i=0}^{n-1}T(i)T(n-i-1)=C_n Here, T(i-1) represents number of nodes on the left-sub-tree T(n−i-1) represents number of nodes on the right-sub-tree n`th Catalan Number can also be evaluated using direct formula. T(n) = (2n)! / (n+1)!n! Number of Binary Search Trees (BST) with n nodes is also same as number of unlabeled trees. The reason for this is simple, in BST also we can make any key as root, If root is i`th key in sorted order, then i-1 keys can go on one side and (n-i) keys can go on other side. How many labeled Binary Trees can be there with n nodes? To count labeled trees, we can use above count for unlabeled trees. The idea is simple, every unlabeled tree with n nodes can create n! different labeled trees by assigning different permutations of labels to all nodes. Therefore, Number of Labeled Tees = (Number of unlabeled trees) * n! = [(2n)! / (n+1)!n!] × n! For example for n = 3, there are 5 * 3! = 5*6 = 30 different labeled trees --- # Insertion in a Binary Tree ![binary-tree-insertion](https://i.imgur.com/xjtBYaX.png ) ```java import java.util.LinkedList; import java.util.Queue; public class GFG { /* A binary tree node has key, pointer to left child and a pointer to right child */ static class Node { int key; Node left, right; // constructor Node(int key) { this.key = key; left = null; right = null; } } static Node root; static Node temp = root; /* Inorder traversal of a binary tree*/ static void inorder(Node temp) { if (temp == null) return; inorder(temp.left); System.out.print(temp.key+" "); inorder(temp.right); } /*function to insert element in binary tree */ static void insert(Node temp, int key) { Queue<Node> q = new LinkedList<Node>(); q.add(temp); // Do level order traversal until we find // an empty place. while (!q.isEmpty()) { temp = q.peek(); q.remove(); if (temp.left == null) { temp.left = new Node(key); break; } else q.add(temp.left); if (temp.right == null) { temp.right = new Node(key); break; } else q.add(temp.right); } } // Driver code public static void main(String args[]) { root = new Node(10); root.left = new Node(11); root.left.left = new Node(7); root.right = new Node(9); root.right.left = new Node(15); root.right.right = new Node(8); System.out.print( "Inorder traversal before insertion:"); inorder(root); int key = 12; insert(root, key); System.out.print("\nInorder traversal after insertion:"); inorder(root); } } ``` --- Deletion in a Binary Tree BFS vs DFS for Binary Tree Binary Tree (Array implementation) AVL with duplicate keys Applications of tree data structure Applications of Minimum Spanning Tree Problem Continuous Tree Foldable Binary Trees Expression Tree Evaluation of Expression Tree Symmetric Tree (Mirror Image of itself) --- # exersice ## Parse Tree Parse trees can be used to represent real-world constructions like sentences or mathematical expressions. define four rules as follows: - If the current token is a `'('`, add a new node as the left child of the current node, and descend to the left child. - If the current token is in the list `['+','-','/','*']`, set the root value of the current node to the operator represented by the current token. - Add a new node as the right child of the current node and descend to the right child. - If the current token is a number, set the root value of the current node to the number and return to the parent. - If the current token is a `')'`, go to the parent of the current node. example: `['(', '3', '+', '(', '4', '*', '5' ,')',')']` ![buildExp8](https://i.imgur.com/v8ieqBx.png) ```py from pythonds.basic import Stack from pythonds.trees import BinaryTree def buildParseTree(fpexp): fplist = fpexp.split() pStack = Stack() eTree = BinaryTree('') pStack.push(eTree) currentTree = eTree for i in fplist: if i == '(': currentTree.insertLeft('') pStack.push(currentTree) currentTree = currentTree.getLeftChild() elif i in ['+', '-', '*', '/']: currentTree.setRootVal(i) currentTree.insertRight('') pStack.push(currentTree) currentTree = currentTree.getRightChild() elif i == ')': currentTree = pStack.pop() elif i not in ['+', '-', '*', '/', ')']: try: currentTree.setRootVal(int(i)) parent = pStack.pop() currentTree = parent except ValueError: raise ValueError("token '{}' is not a valid integer".format(i)) return eTree pt = buildParseTree("( ( 10 + 5 ) * 3 )") pt.postorder() #defined and explained in the next section import operator def evaluate(parseTree): opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv} leftC = parseTree.getLeftChild() rightC = parseTree.getRightChild() if leftC and rightC: fn = opers[parseTree.getRootVal()] return fn(evaluate(leftC),evaluate(rightC)) else: return parseTree.getRootVal() ``` Evaluating the expression represented by an expression tree: Let t be the expression tree If t is not null then If t.value is operand then Return t.value A = solve(t.left) B = solve(t.right) // calculate applies operator 't.value' // on A and B, and returns value Return calculate(A, B, t.value) --- ## Check Same Binary Tree ![Screen Shot 2020-07-24 at 11.27.26](https://i.imgur.com/dcOA8T4.png ) time O(n) ```java public class SameTree { public boolean sameTree(Node root1, Node root2){ if(root1 == null &amp;&amp; root2 == null){ return true; } if(root1 == null || root2 == null){ return false; } return root1.data == root2.data &amp;&amp; sameTree(root1.left, root2.left) &amp;&amp; sameTree(root1.right, root2.right); } public static void main(String args[]){ BinaryTree bt = new BinaryTree(); Node root1 = null; root1 = bt.addNode(10, root1); root1 = bt.addNode(20, root1); root1 = bt.addNode(15, root1); root1 = bt.addNode(2, root1); Node root2 = null; root2 = bt.addNode(10, root2); root2 = bt.addNode(20, root2); root2 = bt.addNode(15, root2); root2 = bt.addNode(2, root2); SameTree st = new SameTree(); assert st.sameTree(root1, root2); } } ``` . </Node></Node></Node></Node></Node></Node></Node></Node></Node></Node></Node></Node></Node></Node></Node></Node></Node></Node></Integer></Integer></Integer></E></E></E></E></E></E></E></Integer></Integer></Integer></E></Integer></E></E></E></E></E></E></E></E></Font></E></Font></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/00codenote/'>00CodeNote</a>, <a href='/categories/ds/'>DS</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Data Structures - Basic 1 - Tree - Grace&url=https://ocholuo.github.io//posts/7-Tree/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Data Structures - Basic 1 - Tree - Grace&u=https://ocholuo.github.io//posts/7-Tree/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Data Structures - Basic 1 - Tree - Grace&url=https://ocholuo.github.io//posts/7-Tree/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Amazon-CloudFront/">AWS Lab - AWS CloudFront</a><li><a href="/posts/Alexa-1stSkill/">AWS Alex First Skill - RedVelvet Time</a><li><a href="/posts/NetworkProtocol-SSL-TLS-Handshake/">NetworkProtocol SSL/TLS Handshake</a><li><a href="/posts/pythonCrash/">Python Crash</a><li><a href="/posts/%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%A7%A3%E9%87%8AAWS/">AWS - 一句话解释AWS</a><li><a href="/posts/GKE/">GCP - Google Cloud Computing - Kubernetes and Kubernetes Engine</a><li><a href="/posts/Go-Note/">Go Note</a><li><a href="/posts/SCPs/">AWS - IdenAccessManage - SCPs (Service Control Policies)</a><li><a href="/posts/CompanyBenefit/">Company Benefit</a><li><a href="/posts/Encryption-SSL&TLS/">Cryptography - SSL/TLS Encryption</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/soc/">SOC</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/DS-Basic1-DS/"><div class="card-body"> <span class="timeago small" >Oct 10, 2021<i class="unloaded">2021-10-10T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Data Structures - Basic 1 - Data Structures</h3><div class="text-muted small"><p> Data Structures - Basic 1 - Data Structures overall pic Linear Structures String String class StringBuilder class ...</p></div></div></a></div><div class="card"> <a href="/posts/DS-Basic0-OOD/"><div class="card-body"> <span class="timeago small" >Oct 10, 2021<i class="unloaded">2021-10-10T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Data Structures - Basic 0 - Object Oriented Programming</h3><div class="text-muted small"><p> Object-oriented programming 面向对象编程 language different 面向过程和OOP在程序流程上的不同之处。 code different OOP inter Basic OOD Goals...</p></div></div></a></div><div class="card"> <a href="/posts/DS-Basic0/"><div class="card-body"> <span class="timeago small" >Oct 10, 2021<i class="unloaded">2021-10-10T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Data Structures - Basic 0</h3><div class="text-muted small"><p> DS Type Base Type Enum Types 枚举 Type Conversions Wrapper Classes and Objects Creating and Using O...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/7-DS-Basic1-PriorityQueues/" class="btn btn-outline-primary" prompt="Older"><p>Data Structures - Basic 1 - Priority Queues</p></a> <a href="/posts/8-Graphy/" class="btn btn-outline-primary" prompt="Newer"><p>DS - pythonds3 - 8. Graphs and Graph Algorithms</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/ocholuo">Grace JyL</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/soc/">SOC</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://ocholuo.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script defer src="/assets/js/dist/pvreport.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-179830187-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-179830187-1'); }); </script>
