<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="pv-proxy-endpoint" content="https://myochosite-291718.appspot.com/query?id=ahNwfm15b2Nob3NpdGUtMjkxNzE4chULEghBcGlRdWVyeRiAgIDo14eBCgw"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Labuladong" /><meta property="og:locale" content="en" /><meta name="description" content="Labuladong question to ask helper basic timeline 算法 Algorithm Analysis 算法 一、数据结构的存储方式 二、数据结构的基本操作 数组遍历框架，典型的线性 迭代结构： 链表遍历框架，兼具迭代和递归结构： 二叉树遍历框架，典型的非线性 递归 遍历 结构： 二叉树框架 扩展为 N 叉树的遍历框架 图的遍历 三、算法刷题指南 四、总结几句 前缀和技巧 303. Range Sum Query - Immutable 计算索引区间/list中指定位置的和 preSum[i] = preSum[i - 1] + nums[i - 1]; 560. Subarray Sum Equals K 和为k的子数组 if (preSum[j] == preSum[i] - k) res++; 304. Range Sum Query 2D - Immutable 二维区域和检索 图像块之间相互减 1099.Two-Sum-Less-Than-K (easy) 找Max A[i] + A[j] &lt; K. 差分 差分数组 increment(i,j,val)-&gt;{diff[i]+=val; diff[j+1]-=val; 370. 区间加法（中等）Difference df = new Difference(nums); df.increment(i, j, val); 1109. Corporate Flight Bookings 航班预订统计 1094 题「拼车」 LinkedList basicc singly linked list Circularly Linked Lists doubly linked list general method Equivalence Testing Cloning Data Structures 单链表的六大解题套路 合并两个有序链表 Merge 2 Sorted Lists 23. Merge k Sorted Lists 合并 k 个有序链表 Merge k Sorted Lists 递归反转链表 206. Reverse Linked List 递归反转整个链表 递归+pointer +++++ 递归 +++++ 2 pointer 反转链表前 N 个节点 92. Reverse Linked List II 反转链表的一部分 +++++ iterative +++++ recursive 25. Reverse Nodes in k-Group K个一组反转链表 +++++ a,b reverse(), a.next=reverseK(b,k) 143. Reorder List (Medium) +++++ Two pointer, find middle, reverse(), combine(n1,n2) +++++ 2 pointer. list.add(ListNode), reorder list 1721. Swapping Nodes in a Linked List (Medium) 24. Swap Nodes in Pairs (Medium) +++++ 2 pointer and swap +++++ recursive example 870 题「优势洗牌」 链表的环 判断单链表是否包含环 142. Linked List Cycle II 计算链表中环起点 回文链表 Palindromic other 9. Palindrome Number 判断回文Number +++++ reverse half of it Best Elimination Game !!! Perform String Shifts !!! Subtree Removal Game with Fibonacci Tree 排序 快速排序 归并排序 stack 队列 栈 232. Implement Queue using Stacks 用栈实现队列 225. Implement Stack using Queue 用队列实现栈 code Reversing an Array Using a Stack Matching Parentheses/Delimiters Matching Tags in a Markup Language 单调栈 返回等长数组for更大的元素 739. Daily Temperatures 返回等长数组for更大的元素的index 环形数组 单调队列结构 滑动窗口问题 Queue code Simulation: Hot Potato 🔒🔒 Tree 🔒🔒 二叉树 计算一棵二叉树共有几个节点 翻转二叉树 填充二叉树节点的右侧指针 将二叉树展开为链表 构造最大二叉树 通过前序和中序/后序和中序遍历结果构造二叉树(kong) 寻找重复子树(kong) 🔒🔒 层序遍历框架 BST with Hash/Set BFS（广度优先搜索）用Queue和q.size去遍历child + not visited 111. Minimum Depth of Binary Tree 二叉树min层级遍历 +++++ 用Queue和q.size去遍历左右 653. Two Sum IV - Input is a BST (Easy) +++++ recurse solution HashSet +++++ iterative 每个都放到queue里 104. Maximum Depth of Binary Tree 二叉树max层级遍历 +++++ 用Queue和q.size去遍历左右 559. Maximum Depth of N-ary Tree 多叉树的层序遍历框架 +++++ 用Queue和q.size去遍历child 穷举所有可能的密码组合 用Queue和q.size去遍历all 二叉搜索树 BST 判断 BST 的合法性 在 BST 中搜索元素 在 BST 中插入一个数 在 BST 中删除一个数 不同的二叉搜索树 - 穷举问题 不同的二叉搜索树II 二叉树后序遍历 二叉树的序列化与反序列化 二叉树打平到一个字符串 Binary Heap 二叉堆 最大堆和最小堆 Graphy 图的遍历 转换成图 所有可能路径 判断有向图是否存在环 拓扑排序 搜索名人 暴力解法 优化解法 最终解法 UNION-FIND 并查集算法 计算 连通分量 UNION-FIND算法 基本思路 平衡性优化 路径压缩 UNION-FIND算法应用 DFS 的替代方案 判定合法等式 DIJKSTRA 算法 DIJKSTRA 算法 起点 start 到某一个终点 end 的最短路径 网络延迟时间 路径经过的权重最大值 概率最大的路径 设计数据结构 缓存淘汰 LRU 缓存淘汰算法 Least Recently Used 造轮子 LRU 算法 使用 Java 内置的 LinkedHashMap 来实现一遍。 LFU 淘汰算法 Least Frequently Used 最大栈 Maximum Frequency Stack 数据流 Reservoir Sampling 随机 水塘抽样算法 382. Linked List Random Node 无限序列随机抽取1元素 be list, size, random n Reservoir Sampling 无限序列随机抽取 k 个数 398. Random Pick Index (Medium) Reservoir Sampling HashMap 380. Insert Delete GetRandom O(1) 实现随机集合 710. Random Pick with Blacklist 避开黑名单的随机数 blacklist index to good index 528. Random Pick with Weight (Medium) 2 for: [1,2,3] -&gt; [1,2,2,3,3,3] Reservoir Sampling reservoir sampling BEST other 295. Find Median from Data Stream 中位数 DFS and BFS 🔒🔒 BFS 🔒 752. Open the Lock 解开密码锁最少次数 用Queue和q.size去遍历all + visited + deads BFS 双向 BFS 优化 用Queue和q.size去遍历 q1=q2;q2=temp 🔒🔒 DFS backtrack 回溯算法 🔒 46. Permutations 全排列问题 ??????????/ 🔒 51. N-Queens N 皇后问题 ?????????? 78. Subsets 子集（中等） 90. Subsets II 77. Combinations 功能 设计朋友圈时间线 🔒🔒 Map Application Application: Counting Word Frequencies 🔒🔒 动态规划 🔒 动态规划 斐波那契数列 动态规划解法 322. Coin Change 凑零钱 ` for i, for coin, dp[i] = Math.min(dp[i], dp[i-coin]+1);` 暴力解法 best 带备忘录的递归 dp 数组的迭代解法 983. Minimum Cost For Tickets (Medium) bottom-up dp Memoization 64. Minimum Path Sum 最小路径和（中等） 931. Minimum Falling Path Sum 下降路径最小和 174. Dungeon Game 地下城游戏 ???????????? 514. Freedom Trail 自由之路（困难）?????? 加权有向图 最短路径 787. K 站中转内最便宜的航班（中等） 🔒 子序列 🔒 SubArray 152. Maximum Product Subarray (Medium) +++++ record max and min 🔒 子序列 - 一维dp数组 53. Maximum Subarray 最大子序和（Easy) +++++ int[] dp, max = Math.max(max, dp[i]) +++++ 状态压缩 dp[i] 仅仅和 dp[i-1] 的状态有关 217. Contains Duplicate (Easy) +++++ hash 记住出现过的数字 +++++ Sort the array better 300. Longest Increasing Subsequence 最长递增子序列 1143. Longest Common Subsequence 最长公共子序列 583. Delete Operation for Two Strings 两个字符串的删除操作 712. Minimum ASCII Delete Sum for Two Strings 最小 ASCII 删除和 5. Longest Palindromic Substring 最长回文子序列 516. Longest Palindromic Subsequence 最长回文子序列长度 494. Target Sum 目标和 回溯思路 消除重叠子问题 72. Edit Distance 编辑距离（困难） 354. Russian Doll Envelopes 俄罗斯套娃信封问题（困难） 背包类型问题 子集背包问题 416. Partition Equal Subset Sum 分割等和子集（中等） 698. Partition to K Equal Sum Subsets 215. Kth Largest Element in an Array 🔒🔒 Hash 🔒 Hash - Array int[] 1. Two Sum (Easy) 找两个数sum=target +++++ brute force 穷举 +++++ two pointer +++++ HashMap 15. 3 sum (Medium) ++++++ i + 2 sum(Hash+Set) ++++++ best: 2 pointer 🔒🔒 Prefix Sum 🔒 Prefix Sum - Array 数组 167. Two Sum II - Input Array Is Sorted +++++ BinarySearch +++++ HashMap +++++ Two pointers start from 2 sides 653. Two Sum IV - Input is a BST (Easy) 238. Product of Array Except Self (Medium) +++++ 左乘 右乘 result[i] = left[i] * right[i]; +++++ 右边数字先计算 再参与计算 +++++ ??????? 724. Find Pivot Index (Easy) ++++++ Brute Force approach for i: adding left, adding right ++++++ 2 pointer, left - nums[i] - right ++++++ prefix sum. for i: sum[i] - nums[i] == sum[n-1]-sum[i] 747. Largest Number At Least Twice of Others (Easy) 🔒🔒 One-pointer 左右指针 one pointer oreo count 🔒🔒 Two-pointer 左右指针 two pointer + BS - 二分查找 / 在有序数组中搜索指定元素 153. Find Minimum in Rotated Sorted Array Medium +++++ 2 pointer + BS, l,m,r -&gt; nums[m]&lt;nums[m-1] return nums[m] 寻找右侧边界的二分查找 33. Search in Rotated Sorted Array (Medium) ++++++ BS chop 34. Find First and Last Position of Element in Sorted Array (Medium) 寻找左右边界的二分搜索 +++++ BS: find first + find last 704. Binary Search 寻找一个数（基本的二分搜索） 寻找左侧边界的二分搜索 278. First Bad Version 二分搜索算法运用 875. Koko Eating Bananas 运送货物？？？？？？？？？？？？？？ https://labuladong.github.io/algo/2/21/59/ ？？？？ 344. Reverse String 反转数组 滑动窗口技巧 right++, missing==0, left++ 76. Minimum Window Substring 最小覆盖子串 567. Permutation in String 字符串排列 438. Find All Anagrams in a String 找所有字母异位词 3. Longest Substring Without Repeating Characters 最长无重复子串 🔒 two pointer - Array 数组 11. Container With Most Water (Medium) +++++ 2 pointer l++, r-- 121. Best Time to Buy and Sell Stock (Easy) +++++ brute force +++++ 2 pointer 求出最小前数，算数求最大 83. Remove Duplicates from Sorted List 有序链表去重 快慢指针前后走 python 26. Remove Duplicates from Sorted Array 有序数组去重（简单）快慢指针前后走 python 80. Remove Duplicates from Sorted Array II nums[i]!=nums[i-2] FU. Each unique element should appear at most K times 27. Remove Element 移除元素 （简单）快慢指针前后走 python 283. Move Zeroes 移除0 快慢指针前后走 349. Intersection of Two Arrays (Easy) +++++ Hash(num1 had), Hash.remove(num2 has) BEST +++++ sorting, compare, get the same 350. Intersection of Two Arrays II (Easy) 2 pointer Arrays.sort(); 左右指针，Arrays.copyOfRange(nums1,0,k); 1089. Duplicate Zeros (Easy) 1385. Find the Distance Value Between Two Arrays (Easy) brute force Binary Search ??? sort + sliding window BEST 696. Count Binary Substrings (Easy) 找00110011成对项 +++++ Brute Force res+=Math.min(pre, cur); 1346. Check If N and Its Double Exist (Easy) +++++ Bruteforce 放入HashSet，rotate看出现 +++++ BS 33. Search in Rotated Sorted Array !!!!!! 81. Search in Rotated Sorted Array II !!!!!! 154. Find Minimum in Rotated Sorted Array II + FollowUp !!!!!! 🔒 two pointer - 链表 203. Remove Linked List Elements (Easy) +++++ recursive solution 237. Delete Node in a Linked List (Easy) 876. Middle of the Linked List 寻找单链表的中点 2095. Delete the Middle Node of a Linked List (Medium) 寻找单链表的倒数n节点 19. Remove Nth Node From End of List remove倒数n节点 删除倒数n,找倒数n+1 Delete N Nodes After M Nodes of a Linked List ?????????? 160. 判断两个单链表是否相交并找出交点 🔒 two pointer - palindrome 回文 2108. Find First Palindromic String in the Array (Easy) +++++ 2 pointer Check each word +++++ StringBuilder.reverse.equals 832. Flipping an Image (Easy) only same values flip both. 1332. Remove Palindromic Subsequences (Easy) +++++ 只有0，1，2 三种答案，aaabbb最多两下消完 Best reverse logic also 125. Valid Palindrome 判断回文链表String +++++ Brute-Force +++++ 2 pointer + (x &lt;= y &amp;&amp; !Character.isLetterOrDigit(s.charAt(x)) ) best 680. Valid Palindrome II (Easy) 可去掉一个字母查看Palindrome Brute-Force validPalindrome+validSubPalindrome recursive version 判断回文单链表 - 把原始链表反转存入一条新的链表，然后比较 判断回文单链表 - 二叉树后序遍历 判断回文单链表 - 用栈结构倒序处理单链表 判断回文单链表 - 不完全反转链表，仅仅反转部分链表，空间复杂度O(1)。 🔒 two pointer - String 917. Reverse Only Letters (Easy) 只反转字母 2000. Reverse Prefix of Word (Easy) 到s[i]之前反转 +++++ char[] +++++ StringBuilder 557. Reverse Words in a String III (Easy) 一句话单词各自反转 541. Reverse String II (Easy) 2134 6578 k个一组反转 942. DI String Match (Easy) Increase l++; Decrease r-- 905. Sort Array By Parity (Easy) +++++ new int[i] = nums[l/r] +++++ In Place Solution Best 1768. Merge Strings Alternately (Easy) 穿插s,t加字母 +++++ for (int i=0; i&lt;Math.max(s1,s2); i++); +++++ substring 977. Squares of a Sorted Array (Easy) 每个数字操作后排序 +++++ Brute Force Approach +++++ Math.abs(nums[l]) &gt; Math.abs(nums[r]) Best 821. Shortest Distance to a Character (Easy) 到特定字母距离 +++++ ``Math.min(fromLeft, fromRight)` +++++ when s.char==c, j=i-1; j=i+1 +++++ combine 2 BEST 922. Sort Array By Parity II (Easy) 按奇偶排序 +++++ new res, nums[i]%2==0?; res[oddindex] oddindex++, res[evenindex] evenindex++ +++++ for(int i=0;i&lt;n; i+=2) should be even, if (odd), check prev num[odd] BEST 392. Is Subsequence (Easy) abc inside ahbgdc ? 28. Implement strStr() (Easy) ll在hello里 +++++ Brute Force string matching +++++ use haystack.substring(i,i+l2).equals(needle) +++++ KMP solution Backlog 925. Long Pressed Name (Easy) “alex”对比”aaleex” +++++ +++++ 2 pointer iterate 844. Backspace String Compare (Easy) &quot;ab##&quot;==&quot;c#d#&quot;? +++++ 2 pointer, StringBuilder.add StringBuilder.deleteCharAt(i) +++++ 2 pointer, Stack.push / Stack.pop +++++ 2 pointer, Stack.push / Stack.pop 345. Reverse Vowels of a String (Easy) 🔒🔒 bit operation 🔒 bit operation - basic Bit Hack #1. Check if the integer is even or odd. x&amp;1==0? even: odd Bit Hack #2. Test if the n-th bit is set. x &amp; (1&lt;&lt;n) ? Bit Hack #3. Set the n-th bit. x | (1&lt;&lt;n) Bit Hack #4. Unset the n-th bit. x &amp; ~(1&lt;&lt;n) Bit Hack #5. Toggle the n-th bit. x ^ (1&lt;&lt;n) Bit Hack #6. Turn off the rightmost 1-bit. x &amp; (x-1) Bit Hack #7. Isolate the rightmost 1-bit. x &amp; (-x) Bit Hack #8. Right propagate the rightmost 1-bit. x | (x-1) Bit Hack #9. Isolate the rightmost 0-bit. ~x &amp; (x+1) Bit Hack #10. Turn on the rightmost 0-bit. x | (x+1) Bonus stuff 🔒 bit operation - Binary 268. Missing Number (Easy) XOR SUM Binary Search 338. Counting Bits (Easy) +++++ check each, Integar.bitCount(n) +++++ DP + bit operation 191. Number of 1 Bits (Easy) +++++ Brian Kernighan Algorithm +++++ &amp;检查每一个 last 1，然后carry +++++ use Integer.bitCount(n); 371. Sum of Two Integers (Medium) +++++ bit operation carry +++++ Recursive system design game TicTacToe" /><meta property="og:description" content="Labuladong question to ask helper basic timeline 算法 Algorithm Analysis 算法 一、数据结构的存储方式 二、数据结构的基本操作 数组遍历框架，典型的线性 迭代结构： 链表遍历框架，兼具迭代和递归结构： 二叉树遍历框架，典型的非线性 递归 遍历 结构： 二叉树框架 扩展为 N 叉树的遍历框架 图的遍历 三、算法刷题指南 四、总结几句 前缀和技巧 303. Range Sum Query - Immutable 计算索引区间/list中指定位置的和 preSum[i] = preSum[i - 1] + nums[i - 1]; 560. Subarray Sum Equals K 和为k的子数组 if (preSum[j] == preSum[i] - k) res++; 304. Range Sum Query 2D - Immutable 二维区域和检索 图像块之间相互减 1099.Two-Sum-Less-Than-K (easy) 找Max A[i] + A[j] &lt; K. 差分 差分数组 increment(i,j,val)-&gt;{diff[i]+=val; diff[j+1]-=val; 370. 区间加法（中等）Difference df = new Difference(nums); df.increment(i, j, val); 1109. Corporate Flight Bookings 航班预订统计 1094 题「拼车」 LinkedList basicc singly linked list Circularly Linked Lists doubly linked list general method Equivalence Testing Cloning Data Structures 单链表的六大解题套路 合并两个有序链表 Merge 2 Sorted Lists 23. Merge k Sorted Lists 合并 k 个有序链表 Merge k Sorted Lists 递归反转链表 206. Reverse Linked List 递归反转整个链表 递归+pointer +++++ 递归 +++++ 2 pointer 反转链表前 N 个节点 92. Reverse Linked List II 反转链表的一部分 +++++ iterative +++++ recursive 25. Reverse Nodes in k-Group K个一组反转链表 +++++ a,b reverse(), a.next=reverseK(b,k) 143. Reorder List (Medium) +++++ Two pointer, find middle, reverse(), combine(n1,n2) +++++ 2 pointer. list.add(ListNode), reorder list 1721. Swapping Nodes in a Linked List (Medium) 24. Swap Nodes in Pairs (Medium) +++++ 2 pointer and swap +++++ recursive example 870 题「优势洗牌」 链表的环 判断单链表是否包含环 142. Linked List Cycle II 计算链表中环起点 回文链表 Palindromic other 9. Palindrome Number 判断回文Number +++++ reverse half of it Best Elimination Game !!! Perform String Shifts !!! Subtree Removal Game with Fibonacci Tree 排序 快速排序 归并排序 stack 队列 栈 232. Implement Queue using Stacks 用栈实现队列 225. Implement Stack using Queue 用队列实现栈 code Reversing an Array Using a Stack Matching Parentheses/Delimiters Matching Tags in a Markup Language 单调栈 返回等长数组for更大的元素 739. Daily Temperatures 返回等长数组for更大的元素的index 环形数组 单调队列结构 滑动窗口问题 Queue code Simulation: Hot Potato 🔒🔒 Tree 🔒🔒 二叉树 计算一棵二叉树共有几个节点 翻转二叉树 填充二叉树节点的右侧指针 将二叉树展开为链表 构造最大二叉树 通过前序和中序/后序和中序遍历结果构造二叉树(kong) 寻找重复子树(kong) 🔒🔒 层序遍历框架 BST with Hash/Set BFS（广度优先搜索）用Queue和q.size去遍历child + not visited 111. Minimum Depth of Binary Tree 二叉树min层级遍历 +++++ 用Queue和q.size去遍历左右 653. Two Sum IV - Input is a BST (Easy) +++++ recurse solution HashSet +++++ iterative 每个都放到queue里 104. Maximum Depth of Binary Tree 二叉树max层级遍历 +++++ 用Queue和q.size去遍历左右 559. Maximum Depth of N-ary Tree 多叉树的层序遍历框架 +++++ 用Queue和q.size去遍历child 穷举所有可能的密码组合 用Queue和q.size去遍历all 二叉搜索树 BST 判断 BST 的合法性 在 BST 中搜索元素 在 BST 中插入一个数 在 BST 中删除一个数 不同的二叉搜索树 - 穷举问题 不同的二叉搜索树II 二叉树后序遍历 二叉树的序列化与反序列化 二叉树打平到一个字符串 Binary Heap 二叉堆 最大堆和最小堆 Graphy 图的遍历 转换成图 所有可能路径 判断有向图是否存在环 拓扑排序 搜索名人 暴力解法 优化解法 最终解法 UNION-FIND 并查集算法 计算 连通分量 UNION-FIND算法 基本思路 平衡性优化 路径压缩 UNION-FIND算法应用 DFS 的替代方案 判定合法等式 DIJKSTRA 算法 DIJKSTRA 算法 起点 start 到某一个终点 end 的最短路径 网络延迟时间 路径经过的权重最大值 概率最大的路径 设计数据结构 缓存淘汰 LRU 缓存淘汰算法 Least Recently Used 造轮子 LRU 算法 使用 Java 内置的 LinkedHashMap 来实现一遍。 LFU 淘汰算法 Least Frequently Used 最大栈 Maximum Frequency Stack 数据流 Reservoir Sampling 随机 水塘抽样算法 382. Linked List Random Node 无限序列随机抽取1元素 be list, size, random n Reservoir Sampling 无限序列随机抽取 k 个数 398. Random Pick Index (Medium) Reservoir Sampling HashMap 380. Insert Delete GetRandom O(1) 实现随机集合 710. Random Pick with Blacklist 避开黑名单的随机数 blacklist index to good index 528. Random Pick with Weight (Medium) 2 for: [1,2,3] -&gt; [1,2,2,3,3,3] Reservoir Sampling reservoir sampling BEST other 295. Find Median from Data Stream 中位数 DFS and BFS 🔒🔒 BFS 🔒 752. Open the Lock 解开密码锁最少次数 用Queue和q.size去遍历all + visited + deads BFS 双向 BFS 优化 用Queue和q.size去遍历 q1=q2;q2=temp 🔒🔒 DFS backtrack 回溯算法 🔒 46. Permutations 全排列问题 ??????????/ 🔒 51. N-Queens N 皇后问题 ?????????? 78. Subsets 子集（中等） 90. Subsets II 77. Combinations 功能 设计朋友圈时间线 🔒🔒 Map Application Application: Counting Word Frequencies 🔒🔒 动态规划 🔒 动态规划 斐波那契数列 动态规划解法 322. Coin Change 凑零钱 ` for i, for coin, dp[i] = Math.min(dp[i], dp[i-coin]+1);` 暴力解法 best 带备忘录的递归 dp 数组的迭代解法 983. Minimum Cost For Tickets (Medium) bottom-up dp Memoization 64. Minimum Path Sum 最小路径和（中等） 931. Minimum Falling Path Sum 下降路径最小和 174. Dungeon Game 地下城游戏 ???????????? 514. Freedom Trail 自由之路（困难）?????? 加权有向图 最短路径 787. K 站中转内最便宜的航班（中等） 🔒 子序列 🔒 SubArray 152. Maximum Product Subarray (Medium) +++++ record max and min 🔒 子序列 - 一维dp数组 53. Maximum Subarray 最大子序和（Easy) +++++ int[] dp, max = Math.max(max, dp[i]) +++++ 状态压缩 dp[i] 仅仅和 dp[i-1] 的状态有关 217. Contains Duplicate (Easy) +++++ hash 记住出现过的数字 +++++ Sort the array better 300. Longest Increasing Subsequence 最长递增子序列 1143. Longest Common Subsequence 最长公共子序列 583. Delete Operation for Two Strings 两个字符串的删除操作 712. Minimum ASCII Delete Sum for Two Strings 最小 ASCII 删除和 5. Longest Palindromic Substring 最长回文子序列 516. Longest Palindromic Subsequence 最长回文子序列长度 494. Target Sum 目标和 回溯思路 消除重叠子问题 72. Edit Distance 编辑距离（困难） 354. Russian Doll Envelopes 俄罗斯套娃信封问题（困难） 背包类型问题 子集背包问题 416. Partition Equal Subset Sum 分割等和子集（中等） 698. Partition to K Equal Sum Subsets 215. Kth Largest Element in an Array 🔒🔒 Hash 🔒 Hash - Array int[] 1. Two Sum (Easy) 找两个数sum=target +++++ brute force 穷举 +++++ two pointer +++++ HashMap 15. 3 sum (Medium) ++++++ i + 2 sum(Hash+Set) ++++++ best: 2 pointer 🔒🔒 Prefix Sum 🔒 Prefix Sum - Array 数组 167. Two Sum II - Input Array Is Sorted +++++ BinarySearch +++++ HashMap +++++ Two pointers start from 2 sides 653. Two Sum IV - Input is a BST (Easy) 238. Product of Array Except Self (Medium) +++++ 左乘 右乘 result[i] = left[i] * right[i]; +++++ 右边数字先计算 再参与计算 +++++ ??????? 724. Find Pivot Index (Easy) ++++++ Brute Force approach for i: adding left, adding right ++++++ 2 pointer, left - nums[i] - right ++++++ prefix sum. for i: sum[i] - nums[i] == sum[n-1]-sum[i] 747. Largest Number At Least Twice of Others (Easy) 🔒🔒 One-pointer 左右指针 one pointer oreo count 🔒🔒 Two-pointer 左右指针 two pointer + BS - 二分查找 / 在有序数组中搜索指定元素 153. Find Minimum in Rotated Sorted Array Medium +++++ 2 pointer + BS, l,m,r -&gt; nums[m]&lt;nums[m-1] return nums[m] 寻找右侧边界的二分查找 33. Search in Rotated Sorted Array (Medium) ++++++ BS chop 34. Find First and Last Position of Element in Sorted Array (Medium) 寻找左右边界的二分搜索 +++++ BS: find first + find last 704. Binary Search 寻找一个数（基本的二分搜索） 寻找左侧边界的二分搜索 278. First Bad Version 二分搜索算法运用 875. Koko Eating Bananas 运送货物？？？？？？？？？？？？？？ https://labuladong.github.io/algo/2/21/59/ ？？？？ 344. Reverse String 反转数组 滑动窗口技巧 right++, missing==0, left++ 76. Minimum Window Substring 最小覆盖子串 567. Permutation in String 字符串排列 438. Find All Anagrams in a String 找所有字母异位词 3. Longest Substring Without Repeating Characters 最长无重复子串 🔒 two pointer - Array 数组 11. Container With Most Water (Medium) +++++ 2 pointer l++, r-- 121. Best Time to Buy and Sell Stock (Easy) +++++ brute force +++++ 2 pointer 求出最小前数，算数求最大 83. Remove Duplicates from Sorted List 有序链表去重 快慢指针前后走 python 26. Remove Duplicates from Sorted Array 有序数组去重（简单）快慢指针前后走 python 80. Remove Duplicates from Sorted Array II nums[i]!=nums[i-2] FU. Each unique element should appear at most K times 27. Remove Element 移除元素 （简单）快慢指针前后走 python 283. Move Zeroes 移除0 快慢指针前后走 349. Intersection of Two Arrays (Easy) +++++ Hash(num1 had), Hash.remove(num2 has) BEST +++++ sorting, compare, get the same 350. Intersection of Two Arrays II (Easy) 2 pointer Arrays.sort(); 左右指针，Arrays.copyOfRange(nums1,0,k); 1089. Duplicate Zeros (Easy) 1385. Find the Distance Value Between Two Arrays (Easy) brute force Binary Search ??? sort + sliding window BEST 696. Count Binary Substrings (Easy) 找00110011成对项 +++++ Brute Force res+=Math.min(pre, cur); 1346. Check If N and Its Double Exist (Easy) +++++ Bruteforce 放入HashSet，rotate看出现 +++++ BS 33. Search in Rotated Sorted Array !!!!!! 81. Search in Rotated Sorted Array II !!!!!! 154. Find Minimum in Rotated Sorted Array II + FollowUp !!!!!! 🔒 two pointer - 链表 203. Remove Linked List Elements (Easy) +++++ recursive solution 237. Delete Node in a Linked List (Easy) 876. Middle of the Linked List 寻找单链表的中点 2095. Delete the Middle Node of a Linked List (Medium) 寻找单链表的倒数n节点 19. Remove Nth Node From End of List remove倒数n节点 删除倒数n,找倒数n+1 Delete N Nodes After M Nodes of a Linked List ?????????? 160. 判断两个单链表是否相交并找出交点 🔒 two pointer - palindrome 回文 2108. Find First Palindromic String in the Array (Easy) +++++ 2 pointer Check each word +++++ StringBuilder.reverse.equals 832. Flipping an Image (Easy) only same values flip both. 1332. Remove Palindromic Subsequences (Easy) +++++ 只有0，1，2 三种答案，aaabbb最多两下消完 Best reverse logic also 125. Valid Palindrome 判断回文链表String +++++ Brute-Force +++++ 2 pointer + (x &lt;= y &amp;&amp; !Character.isLetterOrDigit(s.charAt(x)) ) best 680. Valid Palindrome II (Easy) 可去掉一个字母查看Palindrome Brute-Force validPalindrome+validSubPalindrome recursive version 判断回文单链表 - 把原始链表反转存入一条新的链表，然后比较 判断回文单链表 - 二叉树后序遍历 判断回文单链表 - 用栈结构倒序处理单链表 判断回文单链表 - 不完全反转链表，仅仅反转部分链表，空间复杂度O(1)。 🔒 two pointer - String 917. Reverse Only Letters (Easy) 只反转字母 2000. Reverse Prefix of Word (Easy) 到s[i]之前反转 +++++ char[] +++++ StringBuilder 557. Reverse Words in a String III (Easy) 一句话单词各自反转 541. Reverse String II (Easy) 2134 6578 k个一组反转 942. DI String Match (Easy) Increase l++; Decrease r-- 905. Sort Array By Parity (Easy) +++++ new int[i] = nums[l/r] +++++ In Place Solution Best 1768. Merge Strings Alternately (Easy) 穿插s,t加字母 +++++ for (int i=0; i&lt;Math.max(s1,s2); i++); +++++ substring 977. Squares of a Sorted Array (Easy) 每个数字操作后排序 +++++ Brute Force Approach +++++ Math.abs(nums[l]) &gt; Math.abs(nums[r]) Best 821. Shortest Distance to a Character (Easy) 到特定字母距离 +++++ ``Math.min(fromLeft, fromRight)` +++++ when s.char==c, j=i-1; j=i+1 +++++ combine 2 BEST 922. Sort Array By Parity II (Easy) 按奇偶排序 +++++ new res, nums[i]%2==0?; res[oddindex] oddindex++, res[evenindex] evenindex++ +++++ for(int i=0;i&lt;n; i+=2) should be even, if (odd), check prev num[odd] BEST 392. Is Subsequence (Easy) abc inside ahbgdc ? 28. Implement strStr() (Easy) ll在hello里 +++++ Brute Force string matching +++++ use haystack.substring(i,i+l2).equals(needle) +++++ KMP solution Backlog 925. Long Pressed Name (Easy) “alex”对比”aaleex” +++++ +++++ 2 pointer iterate 844. Backspace String Compare (Easy) &quot;ab##&quot;==&quot;c#d#&quot;? +++++ 2 pointer, StringBuilder.add StringBuilder.deleteCharAt(i) +++++ 2 pointer, Stack.push / Stack.pop +++++ 2 pointer, Stack.push / Stack.pop 345. Reverse Vowels of a String (Easy) 🔒🔒 bit operation 🔒 bit operation - basic Bit Hack #1. Check if the integer is even or odd. x&amp;1==0? even: odd Bit Hack #2. Test if the n-th bit is set. x &amp; (1&lt;&lt;n) ? Bit Hack #3. Set the n-th bit. x | (1&lt;&lt;n) Bit Hack #4. Unset the n-th bit. x &amp; ~(1&lt;&lt;n) Bit Hack #5. Toggle the n-th bit. x ^ (1&lt;&lt;n) Bit Hack #6. Turn off the rightmost 1-bit. x &amp; (x-1) Bit Hack #7. Isolate the rightmost 1-bit. x &amp; (-x) Bit Hack #8. Right propagate the rightmost 1-bit. x | (x-1) Bit Hack #9. Isolate the rightmost 0-bit. ~x &amp; (x+1) Bit Hack #10. Turn on the rightmost 0-bit. x | (x+1) Bonus stuff 🔒 bit operation - Binary 268. Missing Number (Easy) XOR SUM Binary Search 338. Counting Bits (Easy) +++++ check each, Integar.bitCount(n) +++++ DP + bit operation 191. Number of 1 Bits (Easy) +++++ Brian Kernighan Algorithm +++++ &amp;检查每一个 last 1，然后carry +++++ use Integer.bitCount(n); 371. Sum of Two Integers (Medium) +++++ bit operation carry +++++ Recursive system design game TicTacToe" /><link rel="canonical" href="https://ocholuo.github.io//posts/Labuladong/" /><meta property="og:url" content="https://ocholuo.github.io//posts/Labuladong/" /><meta property="og:site_name" content="Grace" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-11T11:11:11-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Labuladong" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-01-02T18:46:02-05:00","datePublished":"2021-10-11T11:11:11-04:00","description":"Labuladong question to ask helper basic timeline 算法 Algorithm Analysis 算法 一、数据结构的存储方式 二、数据结构的基本操作 数组遍历框架，典型的线性 迭代结构： 链表遍历框架，兼具迭代和递归结构： 二叉树遍历框架，典型的非线性 递归 遍历 结构： 二叉树框架 扩展为 N 叉树的遍历框架 图的遍历 三、算法刷题指南 四、总结几句 前缀和技巧 303. Range Sum Query - Immutable 计算索引区间/list中指定位置的和 preSum[i] = preSum[i - 1] + nums[i - 1]; 560. Subarray Sum Equals K 和为k的子数组 if (preSum[j] == preSum[i] - k) res++; 304. Range Sum Query 2D - Immutable 二维区域和检索 图像块之间相互减 1099.Two-Sum-Less-Than-K (easy) 找Max A[i] + A[j] &lt; K. 差分 差分数组 increment(i,j,val)-&gt;{diff[i]+=val; diff[j+1]-=val; 370. 区间加法（中等）Difference df = new Difference(nums); df.increment(i, j, val); 1109. Corporate Flight Bookings 航班预订统计 1094 题「拼车」 LinkedList basicc singly linked list Circularly Linked Lists doubly linked list general method Equivalence Testing Cloning Data Structures 单链表的六大解题套路 合并两个有序链表 Merge 2 Sorted Lists 23. Merge k Sorted Lists 合并 k 个有序链表 Merge k Sorted Lists 递归反转链表 206. Reverse Linked List 递归反转整个链表 递归+pointer +++++ 递归 +++++ 2 pointer 反转链表前 N 个节点 92. Reverse Linked List II 反转链表的一部分 +++++ iterative +++++ recursive 25. Reverse Nodes in k-Group K个一组反转链表 +++++ a,b reverse(), a.next=reverseK(b,k) 143. Reorder List (Medium) +++++ Two pointer, find middle, reverse(), combine(n1,n2) +++++ 2 pointer. list.add(ListNode), reorder list 1721. Swapping Nodes in a Linked List (Medium) 24. Swap Nodes in Pairs (Medium) +++++ 2 pointer and swap +++++ recursive example 870 题「优势洗牌」 链表的环 判断单链表是否包含环 142. Linked List Cycle II 计算链表中环起点 回文链表 Palindromic other 9. Palindrome Number 判断回文Number +++++ reverse half of it Best Elimination Game !!! Perform String Shifts !!! Subtree Removal Game with Fibonacci Tree 排序 快速排序 归并排序 stack 队列 栈 232. Implement Queue using Stacks 用栈实现队列 225. Implement Stack using Queue 用队列实现栈 code Reversing an Array Using a Stack Matching Parentheses/Delimiters Matching Tags in a Markup Language 单调栈 返回等长数组for更大的元素 739. Daily Temperatures 返回等长数组for更大的元素的index 环形数组 单调队列结构 滑动窗口问题 Queue code Simulation: Hot Potato 🔒🔒 Tree 🔒🔒 二叉树 计算一棵二叉树共有几个节点 翻转二叉树 填充二叉树节点的右侧指针 将二叉树展开为链表 构造最大二叉树 通过前序和中序/后序和中序遍历结果构造二叉树(kong) 寻找重复子树(kong) 🔒🔒 层序遍历框架 BST with Hash/Set BFS（广度优先搜索）用Queue和q.size去遍历child + not visited 111. Minimum Depth of Binary Tree 二叉树min层级遍历 +++++ 用Queue和q.size去遍历左右 653. Two Sum IV - Input is a BST (Easy) +++++ recurse solution HashSet +++++ iterative 每个都放到queue里 104. Maximum Depth of Binary Tree 二叉树max层级遍历 +++++ 用Queue和q.size去遍历左右 559. Maximum Depth of N-ary Tree 多叉树的层序遍历框架 +++++ 用Queue和q.size去遍历child 穷举所有可能的密码组合 用Queue和q.size去遍历all 二叉搜索树 BST 判断 BST 的合法性 在 BST 中搜索元素 在 BST 中插入一个数 在 BST 中删除一个数 不同的二叉搜索树 - 穷举问题 不同的二叉搜索树II 二叉树后序遍历 二叉树的序列化与反序列化 二叉树打平到一个字符串 Binary Heap 二叉堆 最大堆和最小堆 Graphy 图的遍历 转换成图 所有可能路径 判断有向图是否存在环 拓扑排序 搜索名人 暴力解法 优化解法 最终解法 UNION-FIND 并查集算法 计算 连通分量 UNION-FIND算法 基本思路 平衡性优化 路径压缩 UNION-FIND算法应用 DFS 的替代方案 判定合法等式 DIJKSTRA 算法 DIJKSTRA 算法 起点 start 到某一个终点 end 的最短路径 网络延迟时间 路径经过的权重最大值 概率最大的路径 设计数据结构 缓存淘汰 LRU 缓存淘汰算法 Least Recently Used 造轮子 LRU 算法 使用 Java 内置的 LinkedHashMap 来实现一遍。 LFU 淘汰算法 Least Frequently Used 最大栈 Maximum Frequency Stack 数据流 Reservoir Sampling 随机 水塘抽样算法 382. Linked List Random Node 无限序列随机抽取1元素 be list, size, random n Reservoir Sampling 无限序列随机抽取 k 个数 398. Random Pick Index (Medium) Reservoir Sampling HashMap 380. Insert Delete GetRandom O(1) 实现随机集合 710. Random Pick with Blacklist 避开黑名单的随机数 blacklist index to good index 528. Random Pick with Weight (Medium) 2 for: [1,2,3] -&gt; [1,2,2,3,3,3] Reservoir Sampling reservoir sampling BEST other 295. Find Median from Data Stream 中位数 DFS and BFS 🔒🔒 BFS 🔒 752. Open the Lock 解开密码锁最少次数 用Queue和q.size去遍历all + visited + deads BFS 双向 BFS 优化 用Queue和q.size去遍历 q1=q2;q2=temp 🔒🔒 DFS backtrack 回溯算法 🔒 46. Permutations 全排列问题 ??????????/ 🔒 51. N-Queens N 皇后问题 ?????????? 78. Subsets 子集（中等） 90. Subsets II 77. Combinations 功能 设计朋友圈时间线 🔒🔒 Map Application Application: Counting Word Frequencies 🔒🔒 动态规划 🔒 动态规划 斐波那契数列 动态规划解法 322. Coin Change 凑零钱 ` for i, for coin, dp[i] = Math.min(dp[i], dp[i-coin]+1);` 暴力解法 best 带备忘录的递归 dp 数组的迭代解法 983. Minimum Cost For Tickets (Medium) bottom-up dp Memoization 64. Minimum Path Sum 最小路径和（中等） 931. Minimum Falling Path Sum 下降路径最小和 174. Dungeon Game 地下城游戏 ???????????? 514. Freedom Trail 自由之路（困难）?????? 加权有向图 最短路径 787. K 站中转内最便宜的航班（中等） 🔒 子序列 🔒 SubArray 152. Maximum Product Subarray (Medium) +++++ record max and min 🔒 子序列 - 一维dp数组 53. Maximum Subarray 最大子序和（Easy) +++++ int[] dp, max = Math.max(max, dp[i]) +++++ 状态压缩 dp[i] 仅仅和 dp[i-1] 的状态有关 217. Contains Duplicate (Easy) +++++ hash 记住出现过的数字 +++++ Sort the array better 300. Longest Increasing Subsequence 最长递增子序列 1143. Longest Common Subsequence 最长公共子序列 583. Delete Operation for Two Strings 两个字符串的删除操作 712. Minimum ASCII Delete Sum for Two Strings 最小 ASCII 删除和 5. Longest Palindromic Substring 最长回文子序列 516. Longest Palindromic Subsequence 最长回文子序列长度 494. Target Sum 目标和 回溯思路 消除重叠子问题 72. Edit Distance 编辑距离（困难） 354. Russian Doll Envelopes 俄罗斯套娃信封问题（困难） 背包类型问题 子集背包问题 416. Partition Equal Subset Sum 分割等和子集（中等） 698. Partition to K Equal Sum Subsets 215. Kth Largest Element in an Array 🔒🔒 Hash 🔒 Hash - Array int[] 1. Two Sum (Easy) 找两个数sum=target +++++ brute force 穷举 +++++ two pointer +++++ HashMap 15. 3 sum (Medium) ++++++ i + 2 sum(Hash+Set) ++++++ best: 2 pointer 🔒🔒 Prefix Sum 🔒 Prefix Sum - Array 数组 167. Two Sum II - Input Array Is Sorted +++++ BinarySearch +++++ HashMap +++++ Two pointers start from 2 sides 653. Two Sum IV - Input is a BST (Easy) 238. Product of Array Except Self (Medium) +++++ 左乘 右乘 result[i] = left[i] * right[i]; +++++ 右边数字先计算 再参与计算 +++++ ??????? 724. Find Pivot Index (Easy) ++++++ Brute Force approach for i: adding left, adding right ++++++ 2 pointer, left - nums[i] - right ++++++ prefix sum. for i: sum[i] - nums[i] == sum[n-1]-sum[i] 747. Largest Number At Least Twice of Others (Easy) 🔒🔒 One-pointer 左右指针 one pointer oreo count 🔒🔒 Two-pointer 左右指针 two pointer + BS - 二分查找 / 在有序数组中搜索指定元素 153. Find Minimum in Rotated Sorted Array Medium +++++ 2 pointer + BS, l,m,r -&gt; nums[m]&lt;nums[m-1] return nums[m] 寻找右侧边界的二分查找 33. Search in Rotated Sorted Array (Medium) ++++++ BS chop 34. Find First and Last Position of Element in Sorted Array (Medium) 寻找左右边界的二分搜索 +++++ BS: find first + find last 704. Binary Search 寻找一个数（基本的二分搜索） 寻找左侧边界的二分搜索 278. First Bad Version 二分搜索算法运用 875. Koko Eating Bananas 运送货物？？？？？？？？？？？？？？ https://labuladong.github.io/algo/2/21/59/ ？？？？ 344. Reverse String 反转数组 滑动窗口技巧 right++, missing==0, left++ 76. Minimum Window Substring 最小覆盖子串 567. Permutation in String 字符串排列 438. Find All Anagrams in a String 找所有字母异位词 3. Longest Substring Without Repeating Characters 最长无重复子串 🔒 two pointer - Array 数组 11. Container With Most Water (Medium) +++++ 2 pointer l++, r-- 121. Best Time to Buy and Sell Stock (Easy) +++++ brute force +++++ 2 pointer 求出最小前数，算数求最大 83. Remove Duplicates from Sorted List 有序链表去重 快慢指针前后走 python 26. Remove Duplicates from Sorted Array 有序数组去重（简单）快慢指针前后走 python 80. Remove Duplicates from Sorted Array II nums[i]!=nums[i-2] FU. Each unique element should appear at most K times 27. Remove Element 移除元素 （简单）快慢指针前后走 python 283. Move Zeroes 移除0 快慢指针前后走 349. Intersection of Two Arrays (Easy) +++++ Hash(num1 had), Hash.remove(num2 has) BEST +++++ sorting, compare, get the same 350. Intersection of Two Arrays II (Easy) 2 pointer Arrays.sort(); 左右指针，Arrays.copyOfRange(nums1,0,k); 1089. Duplicate Zeros (Easy) 1385. Find the Distance Value Between Two Arrays (Easy) brute force Binary Search ??? sort + sliding window BEST 696. Count Binary Substrings (Easy) 找00110011成对项 +++++ Brute Force res+=Math.min(pre, cur); 1346. Check If N and Its Double Exist (Easy) +++++ Bruteforce 放入HashSet，rotate看出现 +++++ BS 33. Search in Rotated Sorted Array !!!!!! 81. Search in Rotated Sorted Array II !!!!!! 154. Find Minimum in Rotated Sorted Array II + FollowUp !!!!!! 🔒 two pointer - 链表 203. Remove Linked List Elements (Easy) +++++ recursive solution 237. Delete Node in a Linked List (Easy) 876. Middle of the Linked List 寻找单链表的中点 2095. Delete the Middle Node of a Linked List (Medium) 寻找单链表的倒数n节点 19. Remove Nth Node From End of List remove倒数n节点 删除倒数n,找倒数n+1 Delete N Nodes After M Nodes of a Linked List ?????????? 160. 判断两个单链表是否相交并找出交点 🔒 two pointer - palindrome 回文 2108. Find First Palindromic String in the Array (Easy) +++++ 2 pointer Check each word +++++ StringBuilder.reverse.equals 832. Flipping an Image (Easy) only same values flip both. 1332. Remove Palindromic Subsequences (Easy) +++++ 只有0，1，2 三种答案，aaabbb最多两下消完 Best reverse logic also 125. Valid Palindrome 判断回文链表String +++++ Brute-Force +++++ 2 pointer + (x &lt;= y &amp;&amp; !Character.isLetterOrDigit(s.charAt(x)) ) best 680. Valid Palindrome II (Easy) 可去掉一个字母查看Palindrome Brute-Force validPalindrome+validSubPalindrome recursive version 判断回文单链表 - 把原始链表反转存入一条新的链表，然后比较 判断回文单链表 - 二叉树后序遍历 判断回文单链表 - 用栈结构倒序处理单链表 判断回文单链表 - 不完全反转链表，仅仅反转部分链表，空间复杂度O(1)。 🔒 two pointer - String 917. Reverse Only Letters (Easy) 只反转字母 2000. Reverse Prefix of Word (Easy) 到s[i]之前反转 +++++ char[] +++++ StringBuilder 557. Reverse Words in a String III (Easy) 一句话单词各自反转 541. Reverse String II (Easy) 2134 6578 k个一组反转 942. DI String Match (Easy) Increase l++; Decrease r-- 905. Sort Array By Parity (Easy) +++++ new int[i] = nums[l/r] +++++ In Place Solution Best 1768. Merge Strings Alternately (Easy) 穿插s,t加字母 +++++ for (int i=0; i&lt;Math.max(s1,s2); i++); +++++ substring 977. Squares of a Sorted Array (Easy) 每个数字操作后排序 +++++ Brute Force Approach +++++ Math.abs(nums[l]) &gt; Math.abs(nums[r]) Best 821. Shortest Distance to a Character (Easy) 到特定字母距离 +++++ ``Math.min(fromLeft, fromRight)` +++++ when s.char==c, j=i-1; j=i+1 +++++ combine 2 BEST 922. Sort Array By Parity II (Easy) 按奇偶排序 +++++ new res, nums[i]%2==0?; res[oddindex] oddindex++, res[evenindex] evenindex++ +++++ for(int i=0;i&lt;n; i+=2) should be even, if (odd), check prev num[odd] BEST 392. Is Subsequence (Easy) abc inside ahbgdc ? 28. Implement strStr() (Easy) ll在hello里 +++++ Brute Force string matching +++++ use haystack.substring(i,i+l2).equals(needle) +++++ KMP solution Backlog 925. Long Pressed Name (Easy) “alex”对比”aaleex” +++++ +++++ 2 pointer iterate 844. Backspace String Compare (Easy) &quot;ab##&quot;==&quot;c#d#&quot;? +++++ 2 pointer, StringBuilder.add StringBuilder.deleteCharAt(i) +++++ 2 pointer, Stack.push / Stack.pop +++++ 2 pointer, Stack.push / Stack.pop 345. Reverse Vowels of a String (Easy) 🔒🔒 bit operation 🔒 bit operation - basic Bit Hack #1. Check if the integer is even or odd. x&amp;1==0? even: odd Bit Hack #2. Test if the n-th bit is set. x &amp; (1&lt;&lt;n) ? Bit Hack #3. Set the n-th bit. x | (1&lt;&lt;n) Bit Hack #4. Unset the n-th bit. x &amp; ~(1&lt;&lt;n) Bit Hack #5. Toggle the n-th bit. x ^ (1&lt;&lt;n) Bit Hack #6. Turn off the rightmost 1-bit. x &amp; (x-1) Bit Hack #7. Isolate the rightmost 1-bit. x &amp; (-x) Bit Hack #8. Right propagate the rightmost 1-bit. x | (x-1) Bit Hack #9. Isolate the rightmost 0-bit. ~x &amp; (x+1) Bit Hack #10. Turn on the rightmost 0-bit. x | (x+1) Bonus stuff 🔒 bit operation - Binary 268. Missing Number (Easy) XOR SUM Binary Search 338. Counting Bits (Easy) +++++ check each, Integar.bitCount(n) +++++ DP + bit operation 191. Number of 1 Bits (Easy) +++++ Brian Kernighan Algorithm +++++ &amp;检查每一个 last 1，然后carry +++++ use Integer.bitCount(n); 371. Sum of Two Integers (Medium) +++++ bit operation carry +++++ Recursive system design game TicTacToe","headline":"Labuladong","mainEntityOfPage":{"@type":"WebPage","@id":"https://ocholuo.github.io//posts/Labuladong/"},"url":"https://ocholuo.github.io//posts/Labuladong/"}</script><title>Labuladong | Grace</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Grace"><meta name="application-name" content="Grace"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://myochosite-291718.appspot.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://myochosite-291718.appspot.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/huoye.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Grace</a></div><div class="site-subtitle font-italic">2023 Mar 14 updated</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ocholuo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Labuladong</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Labuladong</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Grace JyL </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Oct 11, 2021, 11:11 AM -0400" >Oct 11, 2021<i class="unloaded">2021-10-11T11:11:11-04:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Jan 2, 2023, 3:46 PM -0800" >Jan 2<i class="unloaded">2023-01-02T18:46:02-05:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="90981 words">505 min read</span> <span id="pv" class="pageviews"> <i class="fas fa-spinner fa-spin fa-fw"></i> </span> views</div></div><div class="post-content"><ul><li><a href="#labuladong">Labuladong</a><ul><li><a href="#question-to-ask">question to ask</a><li><a href="#helper">helper</a><li><a href="#basic">basic</a><li><a href="#timeline">timeline</a></ul><li><a href="#算法">算法</a><ul><li><a href="#algorithm-analysis">Algorithm Analysis</a><li><a href="#算法-1">算法</a><ul><li><a href="#一数据结构的存储方式">一、数据结构的存储方式</a><li><a href="#二数据结构的基本操作">二、数据结构的基本操作</a><ul><li><a href="#数组遍历框架典型的线性-迭代结构"><strong>数组遍历框架</strong>，典型的<code class="language-plaintext highlighter-rouge">线性 迭代</code>结构：</a><li><a href="#链表遍历框架兼具迭代和递归结构"><strong>链表遍历框架</strong>，兼具<code class="language-plaintext highlighter-rouge">迭代</code>和<code class="language-plaintext highlighter-rouge">递归</code>结构：</a><li><a href="#二叉树遍历框架典型的非线性-递归-遍历-结构"><strong>二叉树遍历框架</strong>，典型的<code class="language-plaintext highlighter-rouge">非线性 递归 遍历</code> 结构：</a><li><a href="#二叉树框架-扩展为-n-叉树的遍历框架">二叉树框架 扩展为 <strong>N 叉树的遍历框架</strong></a><li><a href="#图的遍历"><strong>图的遍历</strong></a></ul><li><a href="#三算法刷题指南">三、算法刷题指南</a><li><a href="#四总结几句">四、总结几句</a></ul><li><a href="#前缀和技巧">前缀和技巧</a><ul><li><a href="#303-range-sum-query---immutable-计算索引区间list中指定位置的和-presumi--presumi---1--numsi---1">303. Range Sum Query - Immutable 计算索引区间/list中指定位置的和 <code class="language-plaintext highlighter-rouge">preSum[i] = preSum[i - 1] + nums[i - 1];</code></a><li><a href="#560-subarray-sum-equals-k-和为k的子数组-if-presumj--presumi---k-res">560. Subarray Sum Equals K 和为k的子数组 <code class="language-plaintext highlighter-rouge">if (preSum[j] == preSum[i] - k) res++;</code></a><li><a href="#304-range-sum-query-2d---immutable-二维区域和检索-图像块之间相互减">304. Range Sum Query 2D - Immutable 二维区域和检索 <code class="language-plaintext highlighter-rouge">图像块之间相互减</code></a><li><a href="#1099two-sum-less-than-k-easy-找max-ai--aj--k">1099.Two-Sum-Less-Than-K (easy) 找Max A[i] + A[j] &lt; K.</a></ul><li><a href="#差分">差分</a><ul><li><a href="#差分数组-incrementijval-diffival-diffj1-val">差分数组 <code class="language-plaintext highlighter-rouge">increment(i,j,val)-&gt;{diff[i]+=val; diff[j+1]-=val;</code></a><li><a href="#370-区间加法中等difference-df--new-differencenums-dfincrementi-j-val">370. 区间加法（中等）<code class="language-plaintext highlighter-rouge">Difference df = new Difference(nums); df.increment(i, j, val);</code></a><li><a href="#1109-corporate-flight-bookings-航班预订统计">1109. Corporate Flight Bookings 航班预订统计</a><li><a href="#1094-题拼车">1094 题「拼车」</a></ul></ul><li><a href="#linkedlist">LinkedList</a><ul><li><a href="#basicc">basicc</a><ul><li><a href="#singly-linked-list">singly linked list</a><li><a href="#circularly-linked-lists">Circularly Linked Lists</a><li><a href="#doubly-linked-list">doubly linked list</a></ul><li><a href="#general-method">general method</a><ul><li><a href="#equivalence-testing">Equivalence Testing</a><li><a href="#cloning-data-structures">Cloning Data Structures</a></ul><li><a href="#单链表的六大解题套路">单链表的六大解题套路</a><ul><li><a href="#合并两个有序链表-merge-2-sorted-lists">合并两个有序链表 Merge 2 Sorted Lists</a><li><a href="#23-merge-k-sorted-lists-合并-k-个有序链表-merge-k-sorted-lists">23. Merge k Sorted Lists 合并 k 个有序链表 Merge k Sorted Lists</a></ul><li><a href="#递归反转链表">递归反转链表</a><ul><li><a href="#206-reverse-linked-list-递归反转整个链表-递归pointer">206. Reverse Linked List 递归反转整个链表 <code class="language-plaintext highlighter-rouge">递归+pointer</code></a><ul><li><a href="#-递归">+++++ 递归</a><li><a href="#-2-pointer">+++++ 2 pointer</a></ul><li><a href="#反转链表前-n-个节点">反转链表前 N 个节点</a><li><a href="#92-reverse-linked-list-ii-反转链表的一部分">92. Reverse Linked List II 反转链表的一部分</a><ul><li><a href="#-iterative">+++++ iterative</a><li><a href="#-recursive">+++++ recursive</a></ul><li><a href="#25-reverse-nodes-in-k-group-k个一组反转链表">25. Reverse Nodes in k-Group K个一组反转链表</a><ul><li><a href="#-ab-reverse-anextreversekbk">+++++ <code class="language-plaintext highlighter-rouge">a,b reverse(), a.next=reverseK(b,k)</code></a></ul><li><a href="#143-reorder-list-medium">143. Reorder List (Medium)</a><ul><li><a href="#-two-pointer-find-middle-reverse-combinen1n2">+++++ <code class="language-plaintext highlighter-rouge">Two pointer, find middle, reverse(), combine(n1,n2)</code></a><li><a href="#-2-pointer-listaddlistnode-reorder-list">+++++ <code class="language-plaintext highlighter-rouge">2 pointer. list.add(ListNode), reorder list</code></a></ul><li><a href="#1721-swapping-nodes-in-a-linked-list-medium">1721. Swapping Nodes in a Linked List (Medium)</a><li><a href="#24-swap-nodes-in-pairs-medium">24. Swap Nodes in Pairs (Medium)</a><ul><li><a href="#-2-pointer-and-swap">+++++ <code class="language-plaintext highlighter-rouge">2 pointer and swap</code></a><li><a href="#-recursive-1">+++++ <code class="language-plaintext highlighter-rouge">recursive</code></a></ul><li><a href="#example">example</a><ul><li><a href="#870-题优势洗牌">870 题「优势洗牌」</a></ul></ul><li><a href="#链表的环">链表的环</a><ul><li><a href="#判断单链表是否包含环">判断单链表是否包含环</a><li><a href="#142-linked-list-cycle-ii-计算链表中环起点">142. Linked List Cycle II 计算链表中环起点</a></ul></ul><li><a href="#回文链表-palindromic">回文链表 Palindromic</a><ul><li><a href="#other">other</a><ul><li><a href="#9-palindrome-number-判断回文number">9. Palindrome Number 判断回文Number</a><ul><li><a href="#-reverse-half-of-it-best">+++++ reverse half of it <strong>Best</strong></a></ul><li><a href="#elimination-game--perform-string-shifts--subtree-removal-game-with-fibonacci-tree">Elimination Game !!! Perform String Shifts !!! Subtree Removal Game with Fibonacci Tree</a></ul><li><a href="#排序">排序</a><ul><li><a href="#快速排序">快速排序</a><li><a href="#归并排序">归并排序</a></ul></ul><li><a href="#stack">stack</a><ul><li><a href="#队列-栈">队列 栈</a><ul><li><a href="#232-implement-queue-using-stacks-用栈实现队列">232. Implement Queue using Stacks 用栈实现队列</a><li><a href="#225-implement-stack-using-queue-用队列实现栈">225. Implement Stack using Queue 用队列实现栈</a></ul><li><a href="#code">code</a><ul><li><a href="#reversing-an-array-using-a-stack">Reversing an Array Using a Stack</a><li><a href="#matching-parenthesesdelimiters">Matching Parentheses/Delimiters</a><li><a href="#matching-tags-in-a-markup-language">Matching Tags in a Markup Language</a></ul><li><a href="#单调栈">单调栈</a><ul><li><a href="#返回等长数组for更大的元素">返回等长数组for更大的元素</a><li><a href="#739-daily-temperatures-返回等长数组for更大的元素的index">739. Daily Temperatures 返回等长数组for更大的元素的index</a><li><a href="#环形数组">环形数组</a></ul><li><a href="#单调队列结构">单调队列结构</a><ul><li><a href="#滑动窗口问题">滑动窗口问题</a></ul></ul><li><a href="#queue">Queue</a><ul><li><a href="#code-1">code</a><ul><li><a href="#simulation-hot-potato">Simulation: Hot Potato</a></ul></ul><li><a href="#-tree">🔒🔒 Tree</a><li><a href="#-二叉树">🔒🔒 二叉树</a><ul><li><a href="#计算一棵二叉树共有几个节点">计算一棵二叉树共有几个节点</a><li><a href="#翻转二叉树">翻转二叉树</a><li><a href="#填充二叉树节点的右侧指针">填充二叉树节点的右侧指针</a><li><a href="#将二叉树展开为链表">将二叉树展开为链表</a><li><a href="#构造最大二叉树">构造最大二叉树</a><li><a href="#通过前序和中序后序和中序遍历结果构造二叉树kong">通过前序和中序/后序和中序遍历结果构造二叉树(kong)</a><li><a href="#寻找重复子树kong">寻找重复子树(kong)</a><li><a href="#-层序遍历框架-bst-with-hashset">🔒🔒 层序遍历框架 BST with Hash/Set</a><ul><li><a href="#bfs广度优先搜索用queue和qsize去遍历child--not-visited">BFS（广度优先搜索）用Queue和q.size去遍历child + not visited</a><li><a href="#111-minimum-depth-of-binary-tree-二叉树min层级遍历">111. Minimum Depth of Binary Tree 二叉树min层级遍历</a><ul><li><a href="#-用queue和qsize去遍历左右">+++++ 用Queue和q.size去遍历左右</a></ul><li><a href="#653-two-sum-iv---input-is-a-bst-easy">653. Two Sum IV - Input is a BST (Easy)</a><ul><li><a href="#-recurse-solution-hashset">+++++ recurse solution HashSet</a><li><a href="#-iterative-每个都放到queue里">+++++ iterative 每个都放到queue里</a></ul><li><a href="#104-maximum-depth-of-binary-tree-二叉树max层级遍历">104. Maximum Depth of Binary Tree 二叉树max层级遍历</a><ul><li><a href="#-用queue和qsize去遍历左右-1">+++++ 用Queue和q.size去遍历左右</a></ul><li><a href="#559-maximum-depth-of-n-ary-tree-多叉树的层序遍历框架">559. Maximum Depth of N-ary Tree 多叉树的层序遍历框架</a><ul><li><a href="#-用queue和qsize去遍历child">+++++ 用Queue和q.size去遍历child</a></ul><li><a href="#穷举所有可能的密码组合-用queue和qsize去遍历all">穷举所有可能的密码组合 用Queue和q.size去遍历all</a></ul><li><a href="#二叉搜索树-bst">二叉搜索树 BST</a><ul><li><a href="#判断-bst-的合法性">判断 BST 的合法性</a><li><a href="#在-bst-中搜索元素">在 BST 中搜索元素</a><li><a href="#在-bst-中插入一个数">在 BST 中插入一个数</a><li><a href="#在-bst-中删除一个数">在 BST 中删除一个数</a><li><a href="#不同的二叉搜索树---穷举问题">不同的二叉搜索树 - 穷举问题</a><li><a href="#不同的二叉搜索树ii">不同的二叉搜索树II</a><li><a href="#二叉树后序遍历">二叉树后序遍历</a><li><a href="#二叉树的序列化与反序列化">二叉树的序列化与反序列化</a><li><a href="#二叉树打平到一个字符串">二叉树打平到一个字符串</a></ul></ul><li><a href="#binary-heap-二叉堆">Binary Heap 二叉堆</a><ul><li><a href="#最大堆和最小堆">最大堆和最小堆</a></ul><li><a href="#graphy">Graphy</a><ul><li><a href="#图的遍历-1">图的遍历</a><ul><li><a href="#转换成图">转换成图</a><li><a href="#所有可能路径">所有可能路径</a><li><a href="#判断有向图是否存在环">判断有向图是否存在环</a><li><a href="#拓扑排序">拓扑排序</a></ul><li><a href="#搜索名人">搜索名人</a><ul><li><a href="#暴力解法">暴力解法</a><li><a href="#优化解法">优化解法</a><li><a href="#最终解法">最终解法</a></ul><li><a href="#union-find-并查集算法-计算-连通分量">UNION-FIND 并查集算法 计算 连通分量</a><ul><li><a href="#union-find算法">UNION-FIND算法</a><ul><li><a href="#基本思路">基本思路</a><li><a href="#平衡性优化">平衡性优化</a><li><a href="#路径压缩">路径压缩</a></ul></ul><li><a href="#union-find算法应用">UNION-FIND算法应用</a><ul><li><a href="#dfs-的替代方案">DFS 的替代方案</a><li><a href="#判定合法等式">判定合法等式</a></ul><li><a href="#dijkstra-算法">DIJKSTRA 算法</a><li><a href="#dijkstra-算法-起点-start-到某一个终点-end-的最短路径">DIJKSTRA 算法 起点 start 到某一个终点 end 的最短路径</a><ul><li><a href="#网络延迟时间">网络延迟时间</a><li><a href="#路径经过的权重最大值">路径经过的权重最大值</a><li><a href="#概率最大的路径">概率最大的路径</a></ul></ul><li><a href="#设计数据结构">设计数据结构</a><ul><li><a href="#缓存淘汰">缓存淘汰</a><ul><li><a href="#lru-缓存淘汰算法-least-recently-used">LRU 缓存淘汰算法 Least Recently Used</a><ul><li><a href="#造轮子-lru-算法">造轮子 LRU 算法</a><li><a href="#使用-java-内置的-linkedhashmap-来实现一遍">使用 Java 内置的 LinkedHashMap 来实现一遍。</a></ul><li><a href="#lfu-淘汰算法-least-frequently-used">LFU 淘汰算法 Least Frequently Used</a></ul><li><a href="#最大栈-maximum-frequency-stack">最大栈 Maximum Frequency Stack</a></ul><li><a href="#数据流">数据流</a><ul><li><a href="#reservoir-sampling-随机-水塘抽样算法">Reservoir Sampling 随机 水塘抽样算法</a><ul><li><a href="#382-linked-list-random-node-无限序列随机抽取1元素">382. Linked List Random Node 无限序列随机抽取1元素</a><ul><li><a href="#be-list-size-random-n">be list, size, random n</a><li><a href="#reservoir-sampling">Reservoir Sampling</a></ul><li><a href="#无限序列随机抽取-k-个数">无限序列随机抽取 k 个数</a><li><a href="#398-random-pick-index-medium">398. Random Pick Index (Medium)</a><ul><li><a href="#reservoir-sampling-1">Reservoir Sampling</a><li><a href="#hashmap">HashMap</a></ul><li><a href="#380-insert-delete-getrandom-o1-实现随机集合">380. Insert Delete GetRandom O(1) 实现随机集合</a><li><a href="#710-random-pick-with-blacklist-避开黑名单的随机数-blacklist-index-to-good-index">710. Random Pick with Blacklist 避开黑名单的随机数 <code class="language-plaintext highlighter-rouge">blacklist index to good index</code></a><li><a href="#528-random-pick-with-weight-medium">528. Random Pick with Weight (Medium)</a><ul><li><a href="#2-for-123---122333"><code class="language-plaintext highlighter-rouge">2 for: [1,2,3] -&gt; [1,2,2,3,3,3]</code></a><li><a href="#reservoir-sampling-2">Reservoir Sampling</a><li><a href="#reservoir-sampling-best">reservoir sampling <strong>BEST</strong></a></ul></ul><li><a href="#other-1">other</a><ul><li><a href="#295-find-median-from-data-stream-中位数">295. Find Median from Data Stream 中位数</a></ul></ul><li><a href="#dfs-and-bfs">DFS and BFS</a><ul><li><a href="#-bfs">🔒🔒 BFS</a><ul><li><a href="#-752-open-the-lock-解开密码锁最少次数-用queue和qsize去遍历all--visited--deads">🔒 752. Open the Lock 解开密码锁最少次数 <code class="language-plaintext highlighter-rouge">用Queue和q.size去遍历all + visited + deads</code></a><ul><li><a href="#bfs">BFS</a><li><a href="#双向-bfs-优化-用queue和qsize去遍历-q1q2q2temp">双向 BFS 优化 <code class="language-plaintext highlighter-rouge">用Queue和q.size去遍历 q1=q2;q2=temp</code></a></ul></ul><li><a href="#-dfs-backtrack-回溯算法">🔒🔒 DFS backtrack 回溯算法</a><ul><li><a href="#-46-permutations-全排列问题-">🔒 46. Permutations 全排列问题 ??????????/</a><li><a href="#-51-n-queens-n-皇后问题-">🔒 51. N-Queens N 皇后问题 ??????????</a><li><a href="#78-subsets-子集中等">78. Subsets 子集（中等）</a><li><a href="#90-subsets-ii">90. Subsets II</a><li><a href="#77-combinations">77. Combinations</a></ul></ul><li><a href="#功能">功能</a><ul><li><a href="#设计朋友圈时间线">设计朋友圈时间线</a></ul><li><a href="#-map">🔒🔒 Map</a><ul><li><a href="#application">Application</a><ul><li><a href="#application-counting-word-frequencies">Application: Counting Word Frequencies</a></ul></ul><li><a href="#-动态规划">🔒🔒 动态规划</a><ul><li><a href="#-动态规划-1">🔒 动态规划</a><ul><li><a href="#斐波那契数列">斐波那契数列</a></ul><li><a href="#动态规划解法">动态规划解法</a><ul><li><a href="#322-coin-change-凑零钱--for-i-for-coin-dpi--mathmindpi-dpi-coin1">322. Coin Change 凑零钱 ` for i, for coin, dp[i] = Math.min(dp[i], dp[i-coin]+1);`</a><ul><li><a href="#暴力解法-1">暴力解法</a><li><a href="#best-带备忘录的递归">best 带备忘录的递归</a><li><a href="#dp-数组的迭代解法">dp 数组的迭代解法</a><li><a href="#983-minimum-cost-for-tickets-medium">983. Minimum Cost For Tickets (Medium)</a><li><a href="#bottom-up-dp">bottom-up dp</a><li><a href="#memoization">Memoization</a></ul><li><a href="#64-minimum-path-sum-最小路径和中等">64. Minimum Path Sum 最小路径和（中等）</a><li><a href="#931-minimum-falling-path-sum-下降路径最小和">931. Minimum Falling Path Sum 下降路径最小和</a><li><a href="#174-dungeon-game-地下城游戏-">174. Dungeon Game 地下城游戏 ????????????</a><li><a href="#514-freedom-trail-自由之路困难">514. Freedom Trail 自由之路（困难）??????</a></ul><li><a href="#加权有向图-最短路径">加权有向图 最短路径</a><ul><li><a href="#787-k-站中转内最便宜的航班中等">787. K 站中转内最便宜的航班（中等）</a></ul><li><a href="#-子序列">🔒 子序列</a><li><a href="#-subarray">🔒 SubArray</a><ul><li><a href="#152-maximum-product-subarray-medium">152. Maximum Product Subarray (Medium)</a><ul><li><a href="#-record-max-and-min">+++++ <code class="language-plaintext highlighter-rouge">record max and min</code></a></ul></ul><li><a href="#-子序列---一维dp数组">🔒 子序列 - 一维dp数组</a><ul><li><a href="#53-maximum-subarray-最大子序和easy">53. Maximum Subarray 最大子序和（Easy)</a><ul><li><a href="#-int-dp-max--mathmaxmax-dpi">+++++ <code class="language-plaintext highlighter-rouge">int[] dp, max = Math.max(max, dp[i])</code></a><li><a href="#-状态压缩-dpi-仅仅和-dpi-1-的状态有关">+++++ 状态压缩 <code class="language-plaintext highlighter-rouge">dp[i] 仅仅和 dp[i-1] 的状态有关</code></a></ul><li><a href="#217-contains-duplicate-easy">217. Contains Duplicate (Easy)</a><ul><li><a href="#-hash-记住出现过的数字">+++++ <code class="language-plaintext highlighter-rouge">hash 记住出现过的数字</code></a><li><a href="#-sort-the-array-better">+++++ <code class="language-plaintext highlighter-rouge">Sort the array</code> better</a></ul><li><a href="#300-longest-increasing-subsequence-最长递增子序列">300. Longest Increasing Subsequence 最长递增子序列</a><li><a href="#1143-longest-common-subsequence-最长公共子序列">1143. Longest Common Subsequence 最长公共子序列</a><li><a href="#583-delete-operation-for-two-strings-两个字符串的删除操作">583. Delete Operation for Two Strings 两个字符串的删除操作</a><li><a href="#712-minimum-ascii-delete-sum-for-two-strings-最小-ascii-删除和">712. Minimum ASCII Delete Sum for Two Strings 最小 ASCII 删除和</a><li><a href="#5-longest-palindromic-substring-最长回文子序列">5. Longest Palindromic Substring 最长回文子序列</a><li><a href="#516-longest-palindromic-subsequence-最长回文子序列长度">516. Longest Palindromic Subsequence 最长回文子序列长度</a><li><a href="#494-target-sum-目标和">494. Target Sum 目标和</a><ul><li><a href="#回溯思路">回溯思路</a><li><a href="#消除重叠子问题">消除重叠子问题</a></ul><li><a href="#72-edit-distance-编辑距离困难">72. Edit Distance 编辑距离（困难）</a><li><a href="#354-russian-doll-envelopes-俄罗斯套娃信封问题困难">354. Russian Doll Envelopes 俄罗斯套娃信封问题（困难）</a></ul><li><a href="#背包类型问题">背包类型问题</a><ul><li><a href="#子集背包问题">子集背包问题</a><ul><li><a href="#416-partition-equal-subset-sum-分割等和子集中等">416. Partition Equal Subset Sum 分割等和子集（中等）</a><li><a href="#698-partition-to-k-equal-sum-subsets">698. Partition to K Equal Sum Subsets</a><li><a href="#215-kth-largest-element-in-an-array">215. Kth Largest Element in an Array</a></ul></ul></ul><li><a href="#-hash">🔒🔒 Hash</a><ul><li><a href="#-hash---array-int">🔒 Hash - Array int[]</a><ul><li><a href="#1-two-sum-easy-找两个数sumtarget">1. Two Sum (Easy) <code class="language-plaintext highlighter-rouge">找两个数sum=target</code></a><ul><li><a href="#-brute-force-穷举">+++++ brute force 穷举</a><li><a href="#-two-pointer">+++++ two pointer</a><li><a href="#-hashmap">+++++ HashMap</a></ul><li><a href="#15-3-sum-medium">15. 3 sum (Medium)</a><ul><li><a href="#-i--2-sumhashset">++++++ <code class="language-plaintext highlighter-rouge">i + 2 sum(Hash+Set)</code></a><ul><li><a href="#-best-2-pointer">++++++ <code class="language-plaintext highlighter-rouge">best: 2 pointer</code></a></ul></ul></ul></ul><li><a href="#-prefix-sum">🔒🔒 Prefix Sum</a><ul><li><a href="#-prefix-sum---array-数组">🔒 Prefix Sum - Array 数组</a><ul><li><a href="#167-two-sum-ii---input-array-is-sorted">167. Two Sum II - Input Array Is Sorted</a><ul><li><a href="#-binarysearch">+++++ BinarySearch</a><li><a href="#-hashmap-1">+++++ HashMap</a><li><a href="#-two-pointers-start-from-2-sides">+++++ Two pointers <code class="language-plaintext highlighter-rouge">start from 2 sides</code></a></ul><li><a href="#653-two-sum-iv---input-is-a-bst-easy-1">653. Two Sum IV - Input is a BST (Easy)</a><li><a href="#238-product-of-array-except-self-medium">238. Product of Array Except Self (Medium)</a><ul><li><a href="#-左乘-右乘-resulti--lefti--righti">+++++ <code class="language-plaintext highlighter-rouge">左乘 右乘 result[i] = left[i] * right[i];</code></a><li><a href="#-右边数字先计算-再参与计算">+++++ <code class="language-plaintext highlighter-rouge">右边数字先计算 再参与计算</code></a><li><a href="#-">+++++ ???????</a></ul><li><a href="#724-find-pivot-index-easy">724. Find Pivot Index (Easy)</a><ul><li><a href="#-brute-force-approach-for-i-adding-left-adding-right">++++++ Brute Force approach <code class="language-plaintext highlighter-rouge">for i: adding left, adding right</code></a><li><a href="#-2-pointer-left---numsi---right">++++++ <code class="language-plaintext highlighter-rouge">2 pointer, left - nums[i] - right</code></a><li><a href="#-prefix-sum-for-i-sumi---numsi--sumn-1-sumi">++++++ <code class="language-plaintext highlighter-rouge">prefix sum. for i: sum[i] - nums[i] == sum[n-1]-sum[i]</code></a></ul></ul><li><a href="#747-largest-number-at-least-twice-of-others-easy">747. Largest Number At Least Twice of Others (Easy)</a></ul><li><a href="#-one-pointer-左右指针">🔒🔒 One-pointer 左右指针</a><ul><li><a href="#one-pointer">one pointer</a><ul><li><a href="#oreo-count">oreo count</a></ul></ul><li><a href="#-two-pointer-左右指针">🔒🔒 Two-pointer 左右指针</a><ul><li><a href="#two-pointer--bs---二分查找--在有序数组中搜索指定元素">two pointer + BS - 二分查找 / 在有序数组中搜索指定元素</a><ul><li><a href="#153-find-minimum-in-rotated-sorted-array-medium">153. Find Minimum in Rotated Sorted Array Medium</a><ul><li><a href="#-2-pointer--bs-lmr---numsmnumsm-1-return-numsm">+++++ <code class="language-plaintext highlighter-rouge">2 pointer + BS, l,m,r -&gt; nums[m]&lt;nums[m-1] return nums[m]</code></a></ul><li><a href="#寻找右侧边界的二分查找">寻找右侧边界的二分查找</a><li><a href="#33-search-in-rotated-sorted-array-medium">33. Search in Rotated Sorted Array (Medium)</a><ul><li><a href="#-bs-chop">++++++ <code class="language-plaintext highlighter-rouge">BS chop</code></a></ul><li><a href="#34-find-first-and-last-position-of-element-in-sorted-array-medium-寻找左右边界的二分搜索">34. Find First and Last Position of Element in Sorted Array (Medium) 寻找左右边界的二分搜索</a><ul><li><a href="#-bs-find-first--find-last">+++++ <code class="language-plaintext highlighter-rouge">BS: find first + find last</code></a></ul><li><a href="#704-binary-search-寻找一个数基本的二分搜索">704. Binary Search 寻找一个数（基本的二分搜索）</a><li><a href="#寻找左侧边界的二分搜索">寻找左侧边界的二分搜索</a><li><a href="#278-first-bad-version">278. First Bad Version</a><li><a href="#二分搜索算法运用">二分搜索算法运用</a><li><a href="#875-koko-eating-bananas">875. Koko Eating Bananas</a><li><a href="#运送货物">运送货物？？？？？？？？？？？？？？</a><li><a href="#httpslabuladonggithubioalgo22159-">https://labuladong.github.io/algo/2/21/59/ ？？？？</a><li><a href="#344-reverse-string-反转数组">344. Reverse String 反转数组</a><li><a href="#滑动窗口技巧-right-missing0-left">滑动窗口技巧 <code class="language-plaintext highlighter-rouge">right++, missing==0, left++</code></a><li><a href="#76-minimum-window-substring-最小覆盖子串">76. Minimum Window Substring 最小覆盖子串</a><li><a href="#567-permutation-in-string-字符串排列">567. Permutation in String 字符串排列</a><li><a href="#438-find-all-anagrams-in-a-string-找所有字母异位词">438. Find All Anagrams in a String 找所有字母异位词</a><li><a href="#3-longest-substring-without-repeating-characters-最长无重复子串">3. Longest Substring Without Repeating Characters 最长无重复子串</a></ul><li><a href="#-two-pointer---array-数组">🔒 two pointer - Array 数组</a><ul><li><a href="#11-container-with-most-water-medium">11. Container With Most Water (Medium)</a><ul><li><a href="#-2-pointer-l-r--">+++++ 2 pointer <code class="language-plaintext highlighter-rouge">l++, r--</code></a></ul><li><a href="#121-best-time-to-buy-and-sell-stock-easy">121. Best Time to Buy and Sell Stock (Easy)</a><ul><li><a href="#-brute-force">+++++ brute force</a><li><a href="#-2-pointer-求出最小前数算数求最大">+++++ <code class="language-plaintext highlighter-rouge">2 pointer 求出最小前数，算数求最大</code></a></ul><li><a href="#83-remove-duplicates-from-sorted-list-有序链表去重-快慢指针前后走">83. Remove Duplicates from Sorted List 有序链表去重 <code class="language-plaintext highlighter-rouge">快慢指针前后走</code></a><ul><li><a href="#python">python</a></ul><li><a href="#26-remove-duplicates-from-sorted-array-有序数组去重简单快慢指针前后走">26. Remove Duplicates from Sorted Array 有序数组去重（简单）<code class="language-plaintext highlighter-rouge">快慢指针前后走</code></a><ul><li><a href="#python-1">python</a></ul><li><a href="#80-remove-duplicates-from-sorted-array-ii-numsinumsi-2">80. Remove Duplicates from Sorted Array II <code class="language-plaintext highlighter-rouge">nums[i]!=nums[i-2]</code></a><li><a href="#fu-each-unique-element-should-appear-at-most-k-times">FU. Each unique element should appear at most K times</a><li><a href="#27-remove-element-移除元素-简单快慢指针前后走">27. Remove Element 移除元素 （简单）<code class="language-plaintext highlighter-rouge">快慢指针前后走</code></a><ul><li><a href="#python-2">python</a></ul><li><a href="#283-move-zeroes-移除0-快慢指针前后走">283. Move Zeroes 移除0 <code class="language-plaintext highlighter-rouge">快慢指针前后走</code></a><li><a href="#349-intersection-of-two-arrays-easy">349. Intersection of Two Arrays (Easy)</a><ul><li><a href="#-hashnum1-had-hashremovenum2-has-best">+++++ <code class="language-plaintext highlighter-rouge">Hash(num1 had), Hash.remove(num2 has)</code> BEST</a><li><a href="#-sorting-compare-get-the-same">+++++ <code class="language-plaintext highlighter-rouge">sorting, compare, get the same</code></a></ul><li><a href="#350-intersection-of-two-arrays-ii-easy">350. Intersection of Two Arrays II (Easy)</a><ul><li><a href="#2-pointer-arrayssort-左右指针arrayscopyofrangenums10k">2 pointer <code class="language-plaintext highlighter-rouge">Arrays.sort(); 左右指针，Arrays.copyOfRange(nums1,0,k);</code></a></ul><li><a href="#1089-duplicate-zeros-easy">1089. Duplicate Zeros (Easy)</a><li><a href="#1385-find-the-distance-value-between-two-arrays-easy">1385. Find the Distance Value Between Two Arrays (Easy)</a><ul><li><a href="#brute-force">brute force</a><li><a href="#binary-search">Binary Search</a><li><a href="#">???</a><li><a href="#sort--sliding-window-best"><code class="language-plaintext highlighter-rouge">sort + sliding window</code> BEST</a></ul><li><a href="#696-count-binary-substrings-easy-找00110011成对项">696. Count Binary Substrings (Easy) 找00110011成对项</a><ul><li><a href="#-brute-force-resmathminpre-cur">+++++ Brute Force <code class="language-plaintext highlighter-rouge">res+=Math.min(pre, cur);</code></a></ul><li><a href="#1346-check-if-n-and-its-double-exist-easy">1346. Check If N and Its Double Exist (Easy)</a><ul><li><a href="#-bruteforce-放入hashsetrotate看出现">+++++ Bruteforce <code class="language-plaintext highlighter-rouge">放入HashSet，rotate看出现</code></a><li><a href="#-bs">+++++ BS</a></ul><li><a href="#33-search-in-rotated-sorted-array-">33. Search in Rotated Sorted Array !!!!!!</a><li><a href="#81-search-in-rotated-sorted-array-ii-">81. Search in Rotated Sorted Array II !!!!!!</a><li><a href="#154-find-minimum-in-rotated-sorted-array-ii--followup-">154. Find Minimum in Rotated Sorted Array II + FollowUp !!!!!!</a></ul><li><a href="#-two-pointer---链表">🔒 two pointer - 链表</a><ul><li><a href="#203-remove-linked-list-elements-easy">203. Remove Linked List Elements (Easy)</a><ul><li><a href="#-recursive-solution">+++++ recursive solution</a></ul><li><a href="#237-delete-node-in-a-linked-list-easy">237. Delete Node in a Linked List (Easy)</a><li><a href="#876-middle-of-the-linked-list-寻找单链表的中点">876. Middle of the Linked List 寻找单链表的中点</a><li><a href="#2095-delete-the-middle-node-of-a-linked-list-medium">2095. Delete the Middle Node of a Linked List (Medium)</a><li><a href="#寻找单链表的倒数n节点">寻找单链表的倒数n节点</a><li><a href="#19-remove-nth-node-from-end-of-list-remove倒数n节点-删除倒数n找倒数n1">19. Remove Nth Node From End of List remove倒数n节点 <code class="language-plaintext highlighter-rouge">删除倒数n,找倒数n+1</code></a><li><a href="#delete-n-nodes-after-m-nodes-of-a-linked-list-">Delete N Nodes After M Nodes of a Linked List ??????????</a><li><a href="#160-判断两个单链表是否相交并找出交点">160. 判断两个单链表是否相交并找出交点</a></ul><li><a href="#-two-pointer---palindrome-回文">🔒 two pointer - palindrome 回文</a><ul><li><a href="#2108-find-first-palindromic-string-in-the-array-easy">2108. Find First Palindromic String in the Array (Easy)</a><ul><li><a href="#-2-pointer-check-each-word">+++++ 2 pointer Check each word</a><li><a href="#-stringbuilderreverseequals">+++++ StringBuilder.reverse.equals</a></ul><li><a href="#832-flipping-an-image-easy-only-same-values-flip-both">832. Flipping an Image (Easy) <code class="language-plaintext highlighter-rouge">only same values flip both.</code></a><li><a href="#1332-remove-palindromic-subsequences-easy">1332. Remove Palindromic Subsequences (Easy)</a><ul><li><a href="#-只有012-三种答案aaabbb最多两下消完-best">+++++ <code class="language-plaintext highlighter-rouge">只有0，1，2 三种答案，aaabbb最多两下消完</code> Best</a><li><a href="#reverse-logic-also">reverse logic also</a></ul><li><a href="#125-valid-palindrome-判断回文链表string">125. Valid Palindrome 判断回文链表String</a><ul><li><a href="#-brute-force-1">+++++ Brute-Force</a><li><a href="#-2-pointer--x--y--characterisletterordigitscharatx--best">+++++ <code class="language-plaintext highlighter-rouge">2 pointer + (x &lt;= y &amp;&amp; !Character.isLetterOrDigit(s.charAt(x)) )</code> best</a></ul><li><a href="#680-valid-palindrome-ii-easy-可去掉一个字母查看palindrome">680. Valid Palindrome II (Easy) 可去掉一个字母查看Palindrome</a><ul><li><a href="#brute-force-validpalindromevalidsubpalindrome">Brute-Force <code class="language-plaintext highlighter-rouge">validPalindrome+validSubPalindrome</code></a><li><a href="#recursive-version">recursive version</a><li><a href="#判断回文单链表---把原始链表反转存入一条新的链表然后比较">判断回文单链表 - 把原始链表反转存入一条新的链表，然后比较</a><li><a href="#判断回文单链表---二叉树后序遍历">判断回文单链表 - 二叉树后序遍历</a><li><a href="#判断回文单链表---用栈结构倒序处理单链表">判断回文单链表 - 用栈结构倒序处理单链表</a><li><a href="#判断回文单链表---不完全反转链表仅仅反转部分链表空间复杂度o1">判断回文单链表 - 不完全反转链表，仅仅反转部分链表，空间复杂度O(1)。</a></ul></ul><li><a href="#-two-pointer---string">🔒 two pointer - String</a><ul><li><a href="#917-reverse-only-letters-easy-只反转字母">917. Reverse Only Letters (Easy) 只反转字母</a><li><a href="#2000-reverse-prefix-of-word-easy-到si之前反转">2000. Reverse Prefix of Word (Easy) 到s[i]之前反转</a><ul><li><a href="#-char">+++++ <code class="language-plaintext highlighter-rouge">char[]</code></a><li><a href="#-stringbuilder">+++++ <code class="language-plaintext highlighter-rouge">StringBuilder</code></a></ul><li><a href="#557-reverse-words-in-a-string-iii-easy-一句话单词各自反转">557. Reverse Words in a String III (Easy) 一句话单词各自反转</a><li><a href="#541-reverse-string-ii-easy-2134-6578-k个一组反转">541. Reverse String II (Easy) <code class="language-plaintext highlighter-rouge">2134 6578</code> k个一组反转</a><li><a href="#942-di-string-match-easy-increase-l-decrease-r--">942. DI String Match (Easy) <code class="language-plaintext highlighter-rouge">Increase l++; Decrease r--</code></a><li><a href="#905-sort-array-by-parity-easy">905. Sort Array By Parity (Easy)</a><ul><li><a href="#-new-inti--numslr">+++++ <code class="language-plaintext highlighter-rouge">new int[i] = nums[l/r]</code></a><li><a href="#-in-place-solution-best">+++++ In Place Solution Best</a></ul><li><a href="#1768-merge-strings-alternately-easy-穿插st加字母">1768. Merge Strings Alternately (Easy) 穿插s,t加字母</a><ul><li><a href="#-for-int-i0-imathmaxs1s2-i-">+++++ <code class="language-plaintext highlighter-rouge">for (int i=0; i&lt;Math.max(s1,s2); i++); </code></a><li><a href="#-substring">+++++ substring</a></ul><li><a href="#977-squares-of-a-sorted-array-easy-每个数字操作后排序">977. Squares of a Sorted Array (Easy) 每个数字操作后排序</a><ul><li><a href="#-brute-force-approach">+++++ Brute Force Approach</a><li><a href="#-mathabsnumsl--mathabsnumsr-best">+++++ <code class="language-plaintext highlighter-rouge">Math.abs(nums[l]) &gt; Math.abs(nums[r])</code> Best</a></ul><li><a href="#821-shortest-distance-to-a-character-easy-到特定字母距离">821. Shortest Distance to a Character (Easy) 到特定字母距离</a><ul><li><a href="#-mathminfromleft-fromright">+++++ ``Math.min(fromLeft, fromRight)`</a><li><a href="#-when-scharc-ji-1-ji1">+++++ <code class="language-plaintext highlighter-rouge">when s.char==c, j=i-1; j=i+1</code></a><li><a href="#-combine-2-best">+++++ <code class="language-plaintext highlighter-rouge">combine 2</code> BEST</a></ul><li><a href="#922-sort-array-by-parity-ii-easy-按奇偶排序">922. Sort Array By Parity II (Easy) 按奇偶排序</a><ul><li><a href="#-new-res-numsi20-resoddindex-oddindex-resevenindex-evenindex">+++++ <code class="language-plaintext highlighter-rouge">new res, nums[i]%2==0?; res[oddindex] oddindex++, res[evenindex] evenindex++</code></a><li><a href="#-forint-i0in-i2-should-be-even-if-odd-check-prev-numodd-best">+++++ <code class="language-plaintext highlighter-rouge">for(int i=0;i&lt;n; i+=2) should be even, if (odd), check prev num[odd]</code> BEST</a></ul><li><a href="#392-is-subsequence-easy-abc-inside-ahbgdc-">392. Is Subsequence (Easy) <code class="language-plaintext highlighter-rouge">abc inside ahbgdc ?</code></a><li><a href="#28-implement-strstr-easy-ll在hello里">28. Implement strStr() (Easy) ll在hello里</a><ul><li><a href="#-brute-force-string-matching">+++++ Brute Force string matching</a><li><a href="#-use-haystacksubstringiil2equalsneedle">+++++ <code class="language-plaintext highlighter-rouge">use haystack.substring(i,i+l2).equals(needle)</code></a><li><a href="#-kmp-solution-backlog">+++++ KMP solution <code class="language-plaintext highlighter-rouge">Backlog</code></a></ul><li><a href="#925-long-pressed-name-easy-alex对比aaleex">925. Long Pressed Name (Easy) “alex”对比”aaleex”</a><ul><li><a href="#-1">+++++</a><li><a href="#-2-pointer-iterate">+++++ 2 pointer iterate</a></ul><li><a href="#844-backspace-string-compare-easy-abcd">844. Backspace String Compare (Easy) <code class="language-plaintext highlighter-rouge">"ab##"=="c#d#"?</code></a><ul><li><a href="#-2-pointer-stringbuilderadd-stringbuilderdeletecharati">+++++ <code class="language-plaintext highlighter-rouge">2 pointer, StringBuilder.add StringBuilder.deleteCharAt(i)</code></a><li><a href="#-2-pointer-stackpush--stackpop">+++++ <code class="language-plaintext highlighter-rouge">2 pointer, Stack.push / Stack.pop</code></a><li><a href="#-2-pointer-stackpush--stackpop-1">+++++ <code class="language-plaintext highlighter-rouge">2 pointer, Stack.push / Stack.pop</code></a></ul><li><a href="#345-reverse-vowels-of-a-string-easy">345. Reverse Vowels of a String (Easy)</a></ul></ul><li><a href="#-bit-operation">🔒🔒 bit operation</a><ul><li><a href="#-bit-operation---basic">🔒 bit operation - basic</a><ul><li><a href="#bit-hack-1-check-if-the-integer-is-even-or-odd-x10-even-odd"><strong>Bit Hack #1. Check if the integer is even or odd.</strong> <code class="language-plaintext highlighter-rouge">x&amp;1==0? even: odd</code></a><li><a href="#bit-hack-2-test-if-the-n-th-bit-is-set-x--1n-"><strong>Bit Hack #2. Test if the n-th bit is set.</strong> <code class="language-plaintext highlighter-rouge">x &amp; (1&lt;&lt;n) ?</code></a><li><a href="#bit-hack-3-set-the-n-th-bit-x--1n"><strong>Bit Hack #3. Set the n-th bit.</strong> <code class="language-plaintext highlighter-rouge">x | (1&lt;&lt;n)</code></a><li><a href="#bit-hack-4-unset-the-n-th-bit-x--1n"><strong>Bit Hack #4. Unset the n-th bit.</strong> <code class="language-plaintext highlighter-rouge">x &amp; ~(1&lt;&lt;n)</code></a><li><a href="#bit-hack-5-toggle-the-n-th-bit-x--1n"><strong>Bit Hack #5. Toggle the n-th bit.</strong> <code class="language-plaintext highlighter-rouge">x ^ (1&lt;&lt;n)</code></a><li><a href="#bit-hack-6-turn-off-the-rightmost-1-bit-x--x-1"><strong>Bit Hack #6. Turn off the rightmost 1-bit.</strong> <code class="language-plaintext highlighter-rouge">x &amp; (x-1)</code></a><li><a href="#bit-hack-7-isolate-the-rightmost-1-bit-x---x"><strong>Bit Hack #7. Isolate the rightmost 1-bit.</strong> <code class="language-plaintext highlighter-rouge">x &amp; (-x)</code></a><li><a href="#bit-hack-8-right-propagate-the-rightmost-1-bit-x--x-1"><strong>Bit Hack #8. Right propagate the rightmost 1-bit.</strong> <code class="language-plaintext highlighter-rouge">x | (x-1)</code></a><li><a href="#bit-hack-9-isolate-the-rightmost-0-bit-x--x1"><strong>Bit Hack #9. Isolate the rightmost 0-bit.</strong> <code class="language-plaintext highlighter-rouge">~x &amp; (x+1)</code></a><li><a href="#bit-hack-10-turn-on-the-rightmost-0-bit-x--x1"><strong>Bit Hack #10. Turn on the rightmost 0-bit.</strong> <code class="language-plaintext highlighter-rouge">x | (x+1)</code></a><li><a href="#bonus-stuff">Bonus stuff</a></ul><li><a href="#-bit-operation---binary">🔒 bit operation - Binary</a><ul><li><a href="#268-missing-number-easy">268. Missing Number (Easy)</a><ul><li><a href="#xor">XOR</a><li><a href="#sum">SUM</a><li><a href="#binary-search-1">Binary Search</a></ul><li><a href="#338-counting-bits-easy">338. Counting Bits (Easy)</a><ul><li><a href="#-check-each-integarbitcountn">+++++ <code class="language-plaintext highlighter-rouge">check each, Integar.bitCount(n)</code></a><li><a href="#-dp--bit-operation">+++++ <code class="language-plaintext highlighter-rouge">DP + bit operation</code></a></ul><li><a href="#191-number-of-1-bits-easy">191. Number of 1 Bits (Easy)</a><ul><li><a href="#-brian-kernighan-algorithm">+++++ <strong>Brian Kernighan Algorithm</strong></a><li><a href="#-检查每一个-last-1然后carry">+++++ <code class="language-plaintext highlighter-rouge">&amp;检查每一个 last 1，然后carry</code></a><li><a href="#-use-integerbitcountn">+++++ <code class="language-plaintext highlighter-rouge">use Integer.bitCount(n);</code></a></ul><li><a href="#371-sum-of-two-integers-medium">371. Sum of Two Integers (Medium)</a><ul><li><a href="#-bit-operation-carry">+++++ <code class="language-plaintext highlighter-rouge">bit operation carry</code></a><li><a href="#-recursive-2">+++++ Recursive</a></ul></ul></ul><li><a href="#system-design">system design</a><li><a href="#game">game</a><ul><li><a href="#tictactoe">TicTacToe</a></ul></ul><hr /><h1 id="labuladong">Labuladong</h1><ul><li>Problem Solving with Algorithms and Data Structures using Python 3<li>Data Structures and Algorithms in Java, 6th Edition.pdf<li>https://github.com/labuladong/fucking-algorithm<li>https://labuladong.github.io</ul><hr /><h2 id="question-to-ask">question to ask</h2><ol><li>can the values in the array be negative.<li>can square of values can exceed Integer.MAX_VALUE.<li>values are in long or Integer.<li>is given array sorted.(even if the example are sorted) this helped me in google interview interviewer told me that this is nice question. (I was not asked this question but a question where sample cases where sorted )</ol><hr /><h2 id="helper">helper</h2><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Input array is null"</span><span class="o">);</span>



<span class="c1">// reverse with stack</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="no">E</span><span class="o">[]</span> <span class="n">a</span><span class="o">){</span>
    <span class="nc">Statck</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayStack</span><span class="o">&lt;&gt;(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="k">for</span><span class="o">(</span><span class="no">E</span> <span class="nl">data:</span> <span class="n">a</span><span class="o">)</span> <span class="n">buffer</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
<span class="o">}</span>
<span class="n">reverse</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>




<span class="c1">// ======================== Swap ========================</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">str</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">str</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="n">str</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">str</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
    <span class="n">str</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
        <span class="n">i</span><span class="o">++;</span>
        <span class="n">j</span><span class="o">--;</span>
    <span class="o">}</span>
<span class="o">}</span>






<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isVowel</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">vowels</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span><span class="sc">'a'</span><span class="o">,</span> <span class="sc">'e'</span><span class="o">,</span> <span class="sc">'i'</span><span class="o">,</span> <span class="sc">'o'</span><span class="o">,</span> <span class="sc">'u'</span><span class="o">,</span> <span class="sc">'A'</span><span class="o">,</span> <span class="sc">'E'</span><span class="o">,</span> <span class="sc">'I'</span><span class="o">,</span> <span class="sc">'O'</span><span class="o">,</span> <span class="sc">'U'</span><span class="o">};</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">vow</span> <span class="o">:</span> <span class="n">vowels</span><span class="o">)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">vow</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>



<span class="c1">// fast be the last one, slow in the middle.</span>
<span class="k">while</span><span class="o">(</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// Palindrome</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isValid</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">lo</span><span class="o">)))</span> <span class="n">lo</span><span class="o">++;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isValid</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">hi</span><span class="o">)))</span> <span class="n">hi</span><span class="o">--;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span> <span class="o">&amp;&amp;</span> <span class="n">isCharDiff</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">lo</span><span class="o">),</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">hi</span><span class="o">)))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">lo</span><span class="o">++;</span> <span class="n">hi</span><span class="o">--;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Character</span><span class="o">.</span><span class="na">isLetterOrDigit</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isCharDiff</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch1</span><span class="o">,</span> <span class="kt">char</span> <span class="n">ch2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Character</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">(</span><span class="n">ch1</span><span class="o">)</span> <span class="o">!=</span> <span class="nc">Character</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">(</span><span class="n">ch2</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">validSubPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">i</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">checkPalindrome</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">++)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">--))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>


<span class="c1">// find something</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">check_binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">start</span><span class="o">&lt;=</span><span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// return index, for find 01*2 in [0,0]</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>


<span class="c1">// find nums*nums in int[] 二分查找</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">p:</span><span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">p</span><span class="o">);</span>
        <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">p</span><span class="o">-</span><span class="n">min</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
<span class="o">}</span>



<span class="c1">// find duplicate using set</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Input array is null"</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">nums</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">num</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>


<span class="c1">// find x in both a,b,c</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">disjoint2</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span> <span class="o">]</span> <span class="n">groupA</span><span class="o">,</span> <span class="kt">int</span><span class="o">[</span> <span class="o">]</span> <span class="n">groupB</span><span class="o">,</span> <span class="kt">int</span><span class="o">[</span> <span class="o">]</span> <span class="n">groupC</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">:</span> <span class="n">groupA</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">:</span> <span class="n">groupB</span><span class="o">){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">){</span>  <span class="c1">// n times</span>
                    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">:</span> <span class="n">groupC</span><span class="o">)</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">c</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>


<span class="c1">// ListNode deleteDuplicates</span>
<span class="nc">ListNode</span>  <span class="nf">deleteDuplicates</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fast</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">slow</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">fast</span><span class="o">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">slow</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
<span class="o">}</span>


<span class="c1">//  deplicate something</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">duplicateZeros</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]==</span><span class="mi">0</span><span class="o">){</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">index</span><span class="o">++)</span> <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
<span class="o">}</span>




<span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeElements</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">val</span><span class="o">==</span><span class="n">val</span><span class="o">)</span> <span class="k">return</span> <span class="n">removeElements</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">,</span>  <span class="n">val</span><span class="o">);</span>
    <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">val</span><span class="o">)</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">else</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="basic">basic</h2><ol><li>Two pointers<li><p>HashMap</p><li>String<li>StringBuilder<li>Arrays<li>ArrayList</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
</pre><td class="rouge-code"><pre><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="o">);</span>
<span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
<span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
<span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALU</span>
<span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALU</span>


<span class="c1">// Random</span>
<span class="nc">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
<span class="n">rand</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span> <span class="c1">// use current time as a seed</span>
<span class="kt">int</span> <span class="n">ran</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">n</span><span class="o">);</span> <span class="c1">// from 0 up to but not including n.</span>
<span class="kt">int</span> <span class="n">ran</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
<span class="kt">int</span> <span class="n">ran</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">();</span> <span class="c1">// between 0.0 and 1.0.</span>
<span class="kt">int</span> <span class="n">ran</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextBoolean</span><span class="o">();</span>


<span class="c1">// Char</span>
<span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">97</span><span class="o">);</span>
<span class="nc">Character</span><span class="o">.</span><span class="na">getNumericValue</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
<span class="nc">Character</span><span class="o">.</span><span class="na">isLowerCase</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
<span class="nc">Character</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
<span class="nc">Character</span><span class="o">.</span><span class="na">isWhitespace</span><span class="o">();</span>
<span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span><span class="n">cs</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
<span class="nc">Character</span><span class="o">.</span><span class="na">isLetterOrDigit</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>



<span class="c1">// String</span>
<span class="nc">String</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">""</span>
<span class="nc">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"Welcome to Tutorialspoint.com"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span><span class="o">);</span>
<span class="n">str1</span> <span class="o">+=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)(</span><span class="n">cipherMatrix</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">65</span><span class="o">);</span>
<span class="n">str1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span>
<span class="n">str1</span><span class="o">.</span><span class="na">charAt</span><span class="o">()</span>
<span class="n">str1</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
<span class="n">str1</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"h"</span><span class="o">);</span>
<span class="n">str1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">str2</span><span class="o">);</span>
<span class="n">str1</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"[^A-Za-z0-9]"</span><span class="o">,</span> <span class="s">""</span><span class="o">).</span><span class="na">toLowerCase</span><span class="o">();</span>
<span class="n">str1</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"/"</span><span class="o">)</span>

<span class="nc">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="n">str1</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">lo</span><span class="o">,</span> <span class="n">lo</span><span class="o">+</span><span class="n">maxLen</span><span class="o">)</span>
<span class="nc">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">" "</span><span class="o">,</span> <span class="n">array</span><span class="o">);</span>

<span class="nc">String</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="n">str1</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
<span class="kt">char</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="n">str1</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>


<span class="nc">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span><span class="o">);</span>





<span class="c1">// StringBuilder</span>
<span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
<span class="nc">StringBuffer</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">(</span><span class="n">str1</span><span class="o">);</span>
<span class="n">sb</span><span class="o">.</span><span class="na">setCharAt</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="nc">Char</span><span class="o">);</span>
<span class="n">sbr</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="n">sb</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="err">'</span><span class="n">hi</span><span class="err">'</span><span class="o">);</span>
<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="err">'</span><span class="n">hi</span><span class="err">'</span><span class="o">);</span>
<span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">()</span>
<span class="n">sb</span><span class="o">.</span><span class="na">reverse</span><span class="o">();</span>



<span class="c1">// Array</span>
<span class="nc">Type</span><span class="o">[]</span> <span class="n">arrayName</span> <span class="o">=</span> <span class="o">{</span><span class="n">initialValue0</span><span class="o">,</span> <span class="n">initialValue1</span><span class="o">,</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="o">,</span> <span class="n">initialValueN</span><span class="err">−</span><span class="mi">1</span><span class="o">};</span>
<span class="nc">Type</span><span class="o">[]</span> <span class="n">arrayName</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Type</span><span class="o">[</span><span class="n">length</span><span class="o">]</span>

<span class="nc">Type</span> <span class="n">myArray</span><span class="o">[];</span>
<span class="nc">Type</span><span class="o">[]</span> <span class="n">myArray</span><span class="o">;</span>

<span class="kt">int</span><span class="o">[]</span> <span class="n">a0</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">a1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
<span class="n">a0</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="n">a1</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
<span class="n">a1</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>

<span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="no">A</span><span class="o">,</span> <span class="no">B</span><span class="o">)</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="no">A</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">a0</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="no">A</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span>
<span class="c1">// Returns an array of size n such that the first k elements of this array are copied from A, where k = min{n, A.length}. If n &gt; A.length, then the last n − A.length elements in this array will be padded with default values, e.g., 0 for an array of int and null for an array of objects.</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="no">A</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span>  <span class="c1">// order from A[s] to A[t − 1]</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="no">A</span><span class="o">)</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">binarySearch</span><span class="o">(</span><span class="no">A</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>

<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span>
    <span class="n">envelopes</span><span class="o">,</span>
    <span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;()</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">?</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">:</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">);</span>



<span class="c1">// ArrayList</span>
<span class="nc">ArrayList</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;();</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">v0</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">array1</span><span class="o">));</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">v1</span><span class="o">;</span>  <span class="c1">// another reference to v1, modify v2 will actually modify v1</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">v3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">v1</span><span class="o">);</span>     <span class="c1">// make an actual copy of v1, not changing v1</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">vowels</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="sc">'a'</span><span class="o">,</span><span class="sc">'e'</span><span class="o">,</span><span class="sc">'i'</span><span class="o">,</span><span class="sc">'o'</span><span class="o">,</span><span class="sc">'u'</span><span class="o">,</span><span class="sc">'A'</span><span class="o">,</span><span class="sc">'E'</span><span class="o">,</span><span class="sc">'I'</span><span class="o">,</span><span class="sc">'O'</span><span class="o">,</span><span class="sc">'U'</span><span class="o">);</span>

<span class="n">v1</span><span class="o">.</span><span class="na">size</span><span class="o">()</span>
<span class="n">v1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
<span class="n">v1</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">)</span>
<span class="n">v2</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span> <span class="c1">// 0 1 2 3 4 -&gt; change -&gt; 5 1 2 3 4</span>
<span class="n">v1</span><span class="o">.</span><span class="na">add</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
<span class="n">v1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">);</span> <span class="c1">// 1 2 3 4 5 -&gt; insert -&gt; 1 6 2 3 4 5</span>
<span class="n">v1</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">index</span><span class="o">)</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">v1</span><span class="o">);</span>
<span class="n">v1</span><span class="o">.</span><span class="na">first</span><span class="o">();</span>
<span class="n">vq</span><span class="o">.</span><span class="na">last</span><span class="o">();</span>
<span class="n">v1</span><span class="o">.</span><span class="na">before</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
<span class="n">v1</span><span class="o">.</span><span class="na">after</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
<span class="n">v1</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
<span class="n">v1</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
<span class="n">v1</span><span class="o">.</span><span class="na">addBefore</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
<span class="n">v1</span><span class="o">.</span><span class="na">addAfter</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>



<span class="c1">// LinkedList</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;[]</span> <span class="n">ll</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
<span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">ll</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">();</span>

<span class="n">ll</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
<span class="n">ll</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>

<span class="n">ll</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
<span class="n">ll</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

<span class="n">ll</span><span class="o">.</span><span class="na">first</span><span class="o">();</span>
<span class="n">ll</span><span class="o">.</span><span class="na">last</span><span class="o">();</span>

<span class="n">ll</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="sc">'k'</span><span class="o">);</span>
<span class="n">ll</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="sc">'k'</span><span class="o">);</span>
<span class="n">ll</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
<span class="n">ll</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
<span class="n">ll</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
<span class="n">ll</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
<span class="n">ll</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>

<span class="nc">Iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">linkedlist</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
<span class="n">iter</span><span class="o">.</span><span class="na">hashNext</span><span class="o">();</span>
<span class="n">iter</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>



<span class="c1">// Stack</span>
<span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
<span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">();</span>
<span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
<span class="n">st</span><span class="o">.</span><span class="na">top</span><span class="o">();</span>
<span class="n">st</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
<span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span> <span class="c1">// Access element from top of Stack</span>
<span class="n">st</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
<span class="n">st</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="n">st</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">stack2</span><span class="o">);</span>








<span class="nc">Vector</span> <span class="n">myVect</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Vector</span><span class="o">();</span>
<span class="n">myVect</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="err">'</span><span class="n">one</span><span class="err">'</span><span class="o">);</span>
<span class="n">myVect</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>


<span class="nc">ListNode</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">&lt;&gt;();</span>
<span class="nc">ListNode</span><span class="o">.</span>

<span class="nc">Queue</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="n">q</span><span class="o">.</span><span class="na">push</span><span class="o">();</span>
<span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
<span class="n">q</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
<span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>


<span class="nc">LinkedHashSet</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;();</span>
<span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"kkk"</span><span class="o">);</span>
<span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
<span class="n">iter</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span>
<span class="n">iter</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>


<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">deads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;();</span>
<span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
<span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
<span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
<span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
<span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

<span class="nc">TreeSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">&lt;&gt;();</span>
<span class="n">tree</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">subSet</span><span class="o">(</span><span class="n">leftValue</span><span class="o">,</span> <span class="n">rightValue</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>


<span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
<span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
<span class="n">hm</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
<span class="n">hm</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
<span class="n">hm</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;());</span>
<span class="n">hm</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="n">hm</span><span class="o">.</span><span class="na">keySet</span><span class="o">();</span>



<span class="nc">LinkedHashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">keyList</span> <span class="o">=</span> <span class="o">;</span>
<span class="nc">LinkedHashSet</span><span class="o">.</span><span class="na">iterator</span><span class="o">().</span><span class="na">next</span><span class="o">();</span>
<span class="nc">LinkedHashSet</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="nc">Key</span><span class="o">);</span>


<span class="nc">BinaryHeap</span> <span class="n">bh</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BinaryHeap</span><span class="o">();</span>
<span class="n">bh</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
<span class="n">bh</span><span class="o">.</span><span class="na">findMin</span><span class="o">();</span>
<span class="n">bh</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span>
<span class="n">bh</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
<span class="n">bh</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
<span class="n">bh</span><span class="o">.</span><span class="na">buildHeap</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>

</pre></table></code></div></div><hr /><h2 id="timeline">timeline</h2><p>10/24: 11/8:61 11/9:63 11/10:64 11/11:65 11/12:66 11/14:67 11/15:70 11/16:? 11/17:79 11/18: 11/19: 11/20: 11/21:87 11/22: 11/23: 11/24:94 11/25: 2/14: 150</p><hr /><h1 id="算法">算法</h1><hr /><h2 id="algorithm-analysis">Algorithm Analysis</h2><hr /><h2 id="算法-1">算法</h2><hr /><h3 id="一数据结构的存储方式">一、数据结构的存储方式</h3><p>数据结构的存储方式只有两种：<code class="language-plaintext highlighter-rouge">数组</code>（顺序存储）和<code class="language-plaintext highlighter-rouge">链表</code>（链式存储）。</p><ul><li>散列表、栈、队列、堆、树、图等等各种数据结构都属于「上层建筑」，而数组和链表才是「结构基础」。<li>因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API 不同而已。</ul><p>「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。</p><ul><li>用数组实现，就要处理扩容缩容的问题；<li>用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。</ul><p>「图」的两种表示方法，</p><ul><li>邻接表就是链表，邻接矩阵就是二维数组。<li>邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。<li>邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。</ul><p>「散列表」就是通过<code class="language-plaintext highlighter-rouge">散列函数</code>把<code class="language-plaintext highlighter-rouge">键</code>映射到一个大<code class="language-plaintext highlighter-rouge">数组</code>里。</p><ul><li>而且对于解决<code class="language-plaintext highlighter-rouge">散列冲突</code>的方法，<li><code class="language-plaintext highlighter-rouge">拉链法</code>需要链表特性，操作简单，但需要额外的空间存储指针；<li><code class="language-plaintext highlighter-rouge">线性探查法</code>就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。</ul><p>「树」</p><ul><li>用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；<li>用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。<ul><li>为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，<li>比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。</ul></ul><blockquote><p>example: Redis 数据库 Redis 提供列表、字符串、集合等等几种常用数据结构， 但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。</p></blockquote><p>综上，<strong>数据结构</strong>种类很多，但是底层存储无非<code class="language-plaintext highlighter-rouge">数组</code>或者<code class="language-plaintext highlighter-rouge">链表</code>，二者的优缺点如下：</p><p><strong>数组</strong></p><ul><li>由于是<code class="language-plaintext highlighter-rouge">紧凑连续存储</code>,可以随机访问，通过<code class="language-plaintext highlighter-rouge">索引</code>快速找到对应元素，而且相对节约存储空间。<li>但正因为连续存储，内存空间必须一次性分配够，<li>数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；<li>数组如果想在中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。</ul><p><strong>链表</strong></p><ul><li>因为<code class="language-plaintext highlighter-rouge">元素不连续</code>，而是靠<code class="language-plaintext highlighter-rouge">指针</code>指向下一个元素的位置，所以不存在数组的扩容问题；<li>如果知道某一元素的<code class="language-plaintext highlighter-rouge">前驱</code>和<code class="language-plaintext highlighter-rouge">后驱</code>，<code class="language-plaintext highlighter-rouge">操作指针</code>即可删除该元素或者插入新元素，时间复杂度 O(1)。<li>但是正因为存储空间不连续，无法根据一个<code class="language-plaintext highlighter-rouge">索引</code>算出对应元素的地址，所以<code class="language-plaintext highlighter-rouge">不能随机访问</code>；<li>而且由于每个元素必须存储指向<code class="language-plaintext highlighter-rouge">前后元素位置的指针</code>，会消耗相对更多的储存空间。</ul><hr /><h3 id="二数据结构的基本操作">二、数据结构的基本操作</h3><p>对于任何数据结构，其基本操作无非 <code class="language-plaintext highlighter-rouge">遍历 + 访问</code>，再具体一点就是：<code class="language-plaintext highlighter-rouge">增删查改</code>。</p><ul><li>数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。 -&gt; 数据结构的使命</ul><p>遍历 + 访问</p><ul><li>各种数据结构的遍历 + 访问无非两种形式：<code class="language-plaintext highlighter-rouge">线性</code>的和<code class="language-plaintext highlighter-rouge">非线性</code>的。<li><strong>线性</strong>就是 <code class="language-plaintext highlighter-rouge">for/while</code> 迭代为代表，<li><strong>非线性</strong>就是<code class="language-plaintext highlighter-rouge">递归</code>为代表。</ul><p>再具体一步，无非以下几种框架：</p><h4 id="数组遍历框架典型的线性-迭代结构"><strong>数组遍历框架</strong>，典型的<code class="language-plaintext highlighter-rouge">线性 迭代</code>结构：</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">// 迭代访问 arr[i]</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="链表遍历框架兼具迭代和递归结构"><strong>链表遍历框架</strong>，兼具<code class="language-plaintext highlighter-rouge">迭代</code>和<code class="language-plaintext highlighter-rouge">递归</code>结构：</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cm">/* 基本的单链表节点 */</span>
<span class="kd">class</span> <span class="nc">ListNode</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">next</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">ListNode</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 迭代访问 p.val</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 递归访问 head.val</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="二叉树遍历框架典型的非线性-递归-遍历-结构"><strong>二叉树遍历框架</strong>，典型的<code class="language-plaintext highlighter-rouge">非线性 递归 遍历</code> 结构：</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cm">/* 基本的二叉树节点 */</span>
<span class="kd">class</span> <span class="nc">TreeNode</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">TreeNode</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>你看二叉树的<code class="language-plaintext highlighter-rouge">递归遍历</code>方式和链表的<code class="language-plaintext highlighter-rouge">递归遍历</code>方式，相似不？</p><ul><li>再看看二叉树结构和单链表结构，相似不？<li>如果再多几条叉，N 叉树你会不会遍历？</ul><h4 id="二叉树框架-扩展为-n-叉树的遍历框架">二叉树框架 扩展为 <strong>N 叉树的遍历框架</strong></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cm">/* 基本的 N 叉树节点 */</span>
<span class="kd">class</span> <span class="nc">TreeNode</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">TreeNode</span><span class="o">[]</span> <span class="n">children</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span> <span class="n">child</span> <span class="o">:</span> <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">traverse</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="图的遍历"><strong>图的遍历</strong></h4><ul><li>N 叉树的遍历又可以扩展为图的遍历，因为图就是好几 N 叉棵树的结合体。<li>你说图是可能出现环的？这个很好办，用个布尔数组 visited 做标记就行了，这里就不写代码了。</ul><p>所谓框架，就是套路。</p><ul><li>不管增删查改，这些代码都是永远无法脱离的结构，<li>你可以把这个结构作为大纲，根据具体问题在框架上添加代码就行了</ul><hr /><h3 id="三算法刷题指南">三、算法刷题指南</h3><p>首先要明确的是，数据结构是工具，算法是通过合适的工具解决特定问题的方法。</p><ul><li>也就是说，学习算法之前，最起码得了解那些常用的数据结构，了解它们的特性和缺陷。</ul><p>先刷二叉树，先刷二叉树，先刷二叉树！</p><p>刷二叉树看到题目没思路, 没有理解我们说的「框架」是什么。</p><p>不要小看这几行破代码，几乎所有二叉树的题目都是一套这个框架就出来了：</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 前序遍历代码位置</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span>
    <span class="c1">// 中序遍历代码位置</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">)</span>
    <span class="c1">// 后序遍历代码位置</span>
<span class="o">}</span>
</pre></table></code></div></div><p>比如说我随便拿几道题的解法出来，不用管具体的代码逻辑，只要看看框架在其中是如何发挥作用的就行。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// LeetCode 124 题，难度 Hard，</span>
<span class="c1">// 求二叉树中最大路径和，主要代码如下：</span>

<span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="no">INT_MIN</span><span class="o">;</span>
<span class="kt">int</span> <span class="nf">oneSideMax</span><span class="o">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">nullptr</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">oneSideMax</span><span class="o">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">));</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">oneSideMax</span><span class="o">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">));</span>

    <span class="c1">// 后序遍历代码位置</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">);</span>
    <span class="k">return</span> <span class="nf">max</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>注意递归函数的位置，这就是个后序遍历嘛，无非就是把 traverse 函数名字改成 oneSideMax 了。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// LeetCode 105 题，难度 Medium，</span>
<span class="c1">// 根据前序遍历和中序遍历的结果还原一棵二叉树，很经典的问题吧，主要代码如下：</span>

<span class="nc">TreeNode</span> <span class="nf">buildTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">preStart</span><span class="o">,</span> <span class="kt">int</span> <span class="n">preEnd</span><span class="o">,</span>
                    <span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">inStart</span><span class="o">,</span> <span class="kt">int</span> <span class="n">inEnd</span><span class="o">,</span>
                    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">inMap</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span><span class="o">(</span><span class="n">preStart</span> <span class="o">&gt;</span> <span class="n">preEnd</span> <span class="o">||</span> <span class="n">inStart</span> <span class="o">&gt;</span> <span class="n">inEnd</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

    <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">preStart</span><span class="o">]);</span>
    <span class="kt">int</span> <span class="n">inRoot</span> <span class="o">=</span> <span class="n">inMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">numsLeft</span> <span class="o">=</span> <span class="n">inRoot</span> <span class="o">-</span> <span class="n">inStart</span><span class="o">;</span>

    <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">buildTree</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="n">numsLeft</span><span class="o">,</span>
                          <span class="n">inorder</span><span class="o">,</span> <span class="n">inStart</span><span class="o">,</span> <span class="n">inRoot</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span>
                          <span class="n">inMap</span><span class="o">);</span>
    <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">buildTree</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="n">numsLeft</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">preEnd</span><span class="o">,</span>
                           <span class="n">inorder</span><span class="o">,</span> <span class="n">inRoot</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">inEnd</span><span class="o">,</span>
                           <span class="n">inMap</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>不要看这个函数的参数很多，只是为了控制数组索引而已。</p><ul><li>注意找递归函数的位置，本质上该算法也就是一个<code class="language-plaintext highlighter-rouge">前序遍历</code>，因为它在前序遍历的位置加了一坨代码。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// LeetCode 99 题，难度 Hard</span>
<span class="c1">// 恢复一棵 BST，主要代码如下：</span>
<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">node</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="no">NULL</span><span class="o">)</span> <span class="o">?</span> <span class="n">prev</span> <span class="o">:</span> <span class="n">s</span><span class="o">;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>这不就是个中序遍历嘛，对于一棵 BST 中序遍历意味着什么，应该不需要解释了吧。</p><p>你看，Hard 难度的题目不过如此，而且还这么有规律可循，只要把框架写出来，然后往相应的位置加东西就行了，这不就是思路吗。</p><p>对于一个理解二叉树的人来说，刷一道二叉树的题目花不了多长时间。</p><ul><li>那么如果你对刷题无从下手或者有畏惧心理，不妨从二叉树下手，<li>前 10 道也许有点难受；结合框架再做 20 道，也许你就有点自己的理解了；<li>刷完整个专题，再去做什么回溯动规分治专题，你就会发现只要涉及递归的问题，都是树的问题。</ul><p>再举例吧，说几道我们之前文章写过的问题。</p><p>动态规划详解说过凑零钱问题，暴力解法就是遍历一棵 N 叉树：</p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">coinChange</span><span class="p">(</span><span class="n">coins</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dp</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="s">'INF'</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">coin</span> <span class="ow">in</span> <span class="n">coins</span><span class="p">:</span>
            <span class="n">subproblem</span> <span class="o">=</span> <span class="nf">dp</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">coin</span><span class="p">)</span>
            <span class="c1"># 子问题无解，跳过
</span>            <span class="k">if</span> <span class="n">subproblem</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">subproblem</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span> <span class="k">if</span> <span class="n">res</span> <span class="o">!=</span> <span class="nf">float</span><span class="p">(</span><span class="s">'INF'</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="nf">dp</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
<span class="c1"># 这么多代码看不懂咋办？直接提取出框架，就能看出核心思路了：
</span>
<span class="c1"># 不过是一个 N 叉树的遍历问题而已
</span><span class="k">def</span> <span class="nf">dp</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">coin</span> <span class="ow">in</span> <span class="n">coins</span><span class="p">:</span>
        <span class="nf">dp</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">coin</span><span class="p">)</span>
</pre></table></code></div></div><p>其实很多动态规划问题就是在遍历一棵树，</p><ul><li>你如果对树的遍历操作烂熟于心，起码知道怎么把思路转化成代码，也知道如何提取别人解法的核心思路。</ul><p>再看看回溯算法</p><ul><li><code class="language-plaintext highlighter-rouge">回溯算法</code>就是个 N 叉树的<code class="language-plaintext highlighter-rouge">前后序遍历</code>问题，没有例外。</ul><p>比如全排列问题吧，本质上全排列就是在遍历下面这棵树，到叶子节点的路径就是一个全排列：</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// 全排列算法的主要代码如下：</span>

<span class="c1">// void backtrack(int[] nums, LinkedList&lt;Integer&gt; track) {</span>
<span class="c1">//     if (track.size() == nums.length) {</span>
<span class="c1">//         res.add(new LinkedList(track));</span>
<span class="c1">//         return;</span>
<span class="c1">//     }</span>
<span class="c1">//</span>
<span class="c1">//     for (int i = 0; i &lt; nums.length; i++) {</span>
<span class="c1">//         if (track.contains(nums[i]))</span>
<span class="c1">//             continue;</span>
<span class="c1">//         track.add(nums[i]);</span>
<span class="c1">//         // 进入下一层决策树</span>
<span class="c1">//         backtrack(nums, track);</span>
<span class="c1">//         track.removeLast();</span>
<span class="c1">//     }</span>

<span class="c1">// /提取出 N 叉树遍历框架/</span>
<span class="c1">// void backtrack(int[] nums, LinkedList&lt;Integer&gt; track) {</span>
<span class="c1">//     for (int i = 0; i &lt; nums.length; i++) {</span>
<span class="c1">//         backtrack(nums, track);</span>
<span class="c1">// }</span>
</pre></table></code></div></div><p>N 叉树的遍历框架</p><ul><li>先刷树的相关题目，试着从框架上看问题，而不要纠结于细节问题。<li>纠结细节问题，就比如纠结 i 到底应该加到 n 还是加到 <code class="language-plaintext highlighter-rouge">n - 1</code>，这个数组的大小到底应该开 n 还是 n + 1？</ul><p>从框架上看问题</p><ul><li>基于框架进行抽取和扩展，既可以在看别人解法时快速理解核心逻辑，也有助于找到我们自己写解法时的思路方向。<li>如果细节出错，你得不到正确的答案，但是只要有框架，你再错也错不到哪去，因为你的方向是对的。<li>没有框架，那根本无法解题，给了你答案，你也不会发现这就是个树的遍历问题。<li>这种思维是很重要的，动态规划详解中总结的找状态转移方程的几步流程，有时候按照流程写出解法，说实话我自己都不知道为啥是对的，反正它就是对了。。。<li>这就是框架的力量，能够保证你在快睡着的时候，依然能写出正确的程序；就算你啥都不会，都能比别人高一个级别。</ul><h3 id="四总结几句">四、总结几句</h3><p>数据结构的</p><ul><li><strong>基本存储方式</strong> 就是<code class="language-plaintext highlighter-rouge">链式</code>和<code class="language-plaintext highlighter-rouge">顺序</code>两种，<ul><li><code class="language-plaintext highlighter-rouge">数组</code>（顺序存储）<li><code class="language-plaintext highlighter-rouge">链表</code>（链式存储）。</ul><li><strong>基本操作</strong> 就是<code class="language-plaintext highlighter-rouge">增删查改</code>，<li><strong>遍历方式</strong> 无非<code class="language-plaintext highlighter-rouge">迭代</code>和<code class="language-plaintext highlighter-rouge">递归</code>。</ul><hr /><h2 id="前缀和技巧">前缀和技巧</h2><h3 id="303-range-sum-query---immutable-计算索引区间list中指定位置的和-presumi--presumi---1--numsi---1">303. Range Sum Query - Immutable 计算索引区间/list中指定位置的和 <code class="language-plaintext highlighter-rouge">preSum[i] = preSum[i - 1] + nums[i - 1];</code></h3><p><a href="https://leetcode.com/problems/range-sum-query-immutable/">303. Range Sum Query - Immutable</a></p><ul><li><p>Given an integer array nums, handle multiple queries of the following type:</p><li>Calculate the sum of the elements of nums between indices left and right inclusive where left &lt;= right.<li><p>Implement the NumArray class:</p><li><code class="language-plaintext highlighter-rouge">NumArray(int[] nums)</code> Initializes the object with the integer array nums.<li><code class="language-plaintext highlighter-rouge">int sumRange(int left, int right)</code> Returns the sum of the elements of nums between indices left and right inclusive (i.e. <code class="language-plaintext highlighter-rouge">nums[left] + nums[left + 1] + ... + nums[right]</code>).</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 63 ms, faster than 18.70% of Java online submissions for Range Sum Query - Immutable.</span>
<span class="c1">// Memory Usage: 41.8 MB, less than 91.48% of Java online submissions for Range Sum Query - Immutable.</span>
<span class="kd">class</span> <span class="nc">NumArray</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">NumArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">res</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 可以达到效果，但是效率很差，</span>
<span class="c1">// 因为 sumRange 的时间复杂度是 O(N)，其中 N 代表 nums 数组的长度。</span>
<span class="c1">// 这道题的最优解法是使用前缀和技巧，将 sumRange 函数的时间复杂度降为 O(1)。</span>

<span class="c1">// 时间复杂度就是代码在最坏情况下的执行次数。</span>
<span class="c1">// 如果调用方输入 left = 0, right = 0，那相当于没有循环，时间复杂度是 O(1)；</span>
<span class="c1">// 如果调用方输入 left = 0, right = nums.length-1，for 循环相当于遍历了整个 nums 数组，时间复杂度是 O(N)，其中 N 代表 nums 数组的长度。</span>



<span class="c1">// solution2</span>
<span class="c1">// 说白了就是不要在 sumRange 里面用 for 循环</span>
<span class="c1">// Runtime: 7 ms, faster than 57.01% of Java online submissions for Range Sum Query - Immutable.</span>
<span class="c1">// Memory Usage: 43.6 MB, less than 59.62% of Java online submissions for Range Sum Query - Immutable.</span>

<span class="kd">class</span> <span class="nc">NumArray</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">preSum</span><span class="o">;</span>   <span class="c1">// 前缀和数组</span>

    <span class="cm">/* 输入一个数组，构造前缀和 */</span>
    <span class="kd">public</span> <span class="nf">NumArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">preSum</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="c1">// 计算 nums 的累加和</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">preSum</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">preSum</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* 查询闭区间 [left, right] 的累加和 */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">preSum</span><span class="o">[</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="https://i.imgur.com/9FGiMm1.png" alt="Screen Shot 2021-10-11 at 10.18.11 PM" /></p><ul><li>求索引区间 <code class="language-plaintext highlighter-rouge">[1, 4]</code> 内的所有元素之和，就可以通过 <code class="language-plaintext highlighter-rouge">preSum[5] - preSum[1]</code> 得出。<li>sumRange 函数仅仅需要做一次减法运算，避免for循环，最坏时间复杂度为常数 O(1)。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// 存储着所有同学的分数</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">scores</span><span class="o">;</span>
<span class="c1">// 试卷满分 100 分</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span>
<span class="c1">// 记录每个分数有几个同学</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">score</span> <span class="o">:</span> <span class="n">scores</span><span class="o">)</span>
    <span class="n">count</span><span class="o">[</span><span class="n">score</span><span class="o">]++</span>
<span class="c1">// 构造前缀和</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>

<span class="c1">// 利用 count 这个前缀和数组进行分数段查询</span>
</pre></table></code></div></div><hr /><h3 id="560-subarray-sum-equals-k-和为k的子数组-if-presumj--presumi---k-res">560. Subarray Sum Equals K 和为k的子数组 <code class="language-plaintext highlighter-rouge">if (preSum[j] == preSum[i] - k) res++;</code></h3><p><a href="https://leetcode.com/problems/subarray-sum-equals-k/">560. Subarray Sum Equals K</a></p><ul><li>Given an array of integers nums and an integer k,<li>return the total number of continuous subarrays whose sum equals to k.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="c1">// 时间复杂度 O(N^2) 空间复杂度 O(N)</span>
<span class="kt">int</span> <span class="nf">subarraySum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 构造前缀和</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">preSum</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="n">preSum</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">preSum</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// 穷举所有子数组</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
            <span class="c1">// 子数组 nums[j..i-1] 的元素和</span>
            <span class="c1">// if (preSum[i] - preSum[j] == k) res++;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">preSum</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">preSum</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">k</span><span class="o">)</span> <span class="n">res</span><span class="o">++;</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>


<span class="c1">// 用哈希表，在记录前缀和的同时记录该前缀和出现的次数。</span>
<span class="c1">// Runtime: 19 ms, faster than 53.05% of Java online submissions for Subarray Sum Equals K.</span>
<span class="nc">Memory</span> <span class="nl">Usage:</span> <span class="mf">41.6</span> <span class="no">MB</span><span class="o">,</span> <span class="n">less</span> <span class="n">than</span> <span class="mf">58.42</span><span class="o">%</span> <span class="n">of</span> <span class="nc">Java</span> <span class="n">online</span> <span class="n">submissions</span> <span class="k">for</span> <span class="nc">Subarray</span> <span class="nc">Sum</span> <span class="nc">Equals</span> <span class="no">K</span><span class="o">.</span>
<span class="kt">int</span> <span class="nf">subarraySum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="c1">// map：前缀和 -&gt; 该前缀和出现的次数</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">preSum</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// base case</span>
    <span class="n">preSum</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>

    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">sum0_i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">sum0_i</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="c1">// 这是我们想找的前缀和 nums[0..j]</span>
        <span class="kt">int</span> <span class="n">sum0_j</span> <span class="o">=</span> <span class="n">sum0_i</span> <span class="o">-</span> <span class="n">k</span><span class="o">;</span>
        <span class="c1">// 如果前面有这个前缀和，则直接更新答案</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">preSum</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">sum0_j</span><span class="o">))</span> <span class="n">res</span> <span class="o">+=</span> <span class="n">preSum</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">sum0_j</span><span class="o">);</span>
        <span class="c1">// 把前缀和 nums[0..i] 加入并记录出现次数</span>
        <span class="n">preSum</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">sum0_i</span><span class="o">,</span> <span class="n">preSum</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">sum0_i</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

</pre></table></code></div></div><hr /><h3 id="304-range-sum-query-2d---immutable-二维区域和检索-图像块之间相互减">304. Range Sum Query 2D - Immutable 二维区域和检索 <code class="language-plaintext highlighter-rouge">图像块之间相互减</code></h3><p><a href="https://www.youtube.com/watch?v=PwDqpOMwg6U">youtube</a></p><p><img data-proofer-ignore data-src="https://i.imgur.com/f55K6B4.png" alt="Screen Shot 2021-10-13 at 11.35.52 PM" /></p><p><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/">304. Range Sum Query 2D - Immutable</a></p><ul><li><p>Given a 2D matrix matrix, handle multiple queries of the following type:</p><li><p>Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). Implement the NumMatrix class:</p><li>NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.<li>int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 107 ms, faster than 74.69% of Java online submissions for Range Sum Query 2D - Immutable.</span>
<span class="c1">// Memory Usage: 66.8 MB, less than 65.71% of Java online submissions for Range Sum Query 2D - Immutable.</span>
<span class="c1">// O(1)</span>
<span class="kd">class</span> <span class="nc">NumMatrix</span> <span class="o">{</span>

    <span class="kt">int</span><span class="o">[][]</span> <span class="n">preSum</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">NumMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">m</span><span class="o">==</span><span class="mi">0</span><span class="o">|</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

        <span class="n">preSum</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">m</span><span class="o">;</span> <span class="n">x</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">y</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span> <span class="n">y</span><span class="o">++){</span>
                <span class="c1">// 计算每个矩阵 [0, 0, i, j] 的元素和</span>
                <span class="n">preSum</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">preSum</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">preSum</span><span class="o">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="o">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRegion</span><span class="o">(</span><span class="kt">int</span> <span class="n">row1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">preSum</span><span class="o">[</span><span class="n">row2</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">col2</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="o">[</span><span class="n">row1</span><span class="o">][</span><span class="n">col2</span><span class="o">+</span><span class="mi">1</span><span class="o">]-</span> <span class="n">preSum</span><span class="o">[</span><span class="n">row2</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">col1</span><span class="o">]</span> <span class="o">+</span> <span class="n">preSum</span><span class="o">[</span><span class="n">row1</span><span class="o">][</span><span class="n">col1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><hr /><h3 id="1099two-sum-less-than-k-easy-找max-ai--aj--k">1099.Two-Sum-Less-Than-K (easy) 找Max A[i] + A[j] &lt; K.</h3><p><a href="https://leetcode.com/accounts/login/?next=/problems/two-sum-less-than-k/">1099.Two-Sum-Less-Than-K (easy)</a></p><p>Given an array A of integers and integer K, return the maximum S such that there exists i &lt; j with A[i] + A[j] = S and S &lt; K. If no i, j exist satisfying this equation, return -1.</p><p>Example 1:</p><p>Input: A = [34,23,1,24,75,33,54,8], K = 60 Output: 58 Explanation: We can use 34 and 24 to sum 58 which is less than 60. Example 2:</p><p>Input: A = [10,20,30], K = 15 Output: -1 Explanation: In this case its not possible to get a pair sum less that 15.</p><p>Note:</p><p>1 &lt;= A.length &lt;= 100 1 &lt;= A[i] &lt;= 1000 1 &lt;= K &lt;= 2000</p><p>Two Point</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">twoSumLessThanK</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">,</span> <span class="kt">int</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="no">A</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="no">A</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="no">A</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="差分">差分</h2><h3 id="差分数组-incrementijval-diffival-diffj1-val">差分数组 <code class="language-plaintext highlighter-rouge">increment(i,j,val)-&gt;{diff[i]+=val; diff[j+1]-=val;</code></h3><p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。</p><ul><li>输入一个数组 nums，然后又要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，再给…<li>最后 nums 数组的值是什么？<li>常规的思路, for 循环给它们都加上, 时间复杂度是 O(N)，</ul><p>用preSum，修改的区域改变preSum，从preSum推原list</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">// 差分数组工具类</span>
<span class="kd">class</span> <span class="nc">Difference</span> <span class="o">{</span>

    <span class="c1">// 差分数组</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">diff</span><span class="o">;</span>

    <span class="cm">/* 输入一个初始数组，区间操作将在这个数组上进行 */</span>
    <span class="kd">public</span> <span class="nf">Difference</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// 根据初始数组构造差分数组</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="cm">/* 给闭区间 [i,j] 增加 val（可以是负数）*/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">val</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">diff</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="n">diff</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-=</span> <span class="n">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 返回结果数组 */</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">result</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">diff</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="c1">// 根据差分数组构造结果数组</span>
        <span class="n">res</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">diff</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="370-区间加法中等difference-df--new-differencenums-dfincrementi-j-val">370. 区间加法（中等）<code class="language-plaintext highlighter-rouge">Difference df = new Difference(nums); df.increment(i, j, val);</code></h3><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[]</span> <span class="nf">getModifiedArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">length</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">updates</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// nums 初始化为全 0</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">length</span><span class="o">];</span>
    <span class="c1">// 构造差分解法</span>
    <span class="nc">Difference</span> <span class="n">df</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Difference</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">update</span> <span class="o">:</span> <span class="n">updates</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">update</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">update</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">update</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">df</span><span class="o">.</span><span class="na">increment</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="na">result</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="1109-corporate-flight-bookings-航班预订统计">1109. Corporate Flight Bookings 航班预订统计</h3><p><a href="https://leetcode.com/problems/corporate-flight-bookings/">1109. Corporate Flight Bookings</a></p><ul><li><p>There are n flights that are labeled from 1 to n.</p><li><p>You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.</p><li><p>Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i.</p></ul><div class="language-plaintext highlighter-rouge"><div class="code-header" text-data="plaintext"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>Example 1:
Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
Output: [10,55,45,25,25]
Explanation:
Flight labels:        1   2   3   4   5
Booking 1 reserved:  10  10
Booking 2 reserved:      20  20
Booking 3 reserved:      25  25  25  25
Total seats:         10  55  45  25  25
Hence, answer = [10,55,45,25,25]
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 5 ms, faster than 43.51% of Java online submissions for Corporate Flight Bookings.</span>
<span class="c1">// Memory Usage: 54.6 MB, less than 54.64% of Java online submissions for Corporate Flight Bookings.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="nf">corpFlightBookings</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">bookings</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// nums 初始化为全 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">// 构造差分解法</span>
        <span class="nc">Difference</span> <span class="n">df</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Difference</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">booking</span> <span class="o">:</span> <span class="n">bookings</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 注意转成数组索引要减一哦</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">booking</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">booking</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">booking</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
            <span class="c1">// 对区间 nums[i..j] 增加 val</span>
            <span class="n">df</span><span class="o">.</span><span class="na">increment</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// 返回最终的结果数组</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="na">result</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Difference</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">diff</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Difference</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
        <span class="k">assert</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="n">diff</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">+=</span> <span class="n">k</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">diff</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="n">diff</span><span class="o">[</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">-=</span><span class="n">k</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">result</span><span class="o">(){</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">diff</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="n">res</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">diff</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="1094-题拼车">1094 题「拼车」</h3><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre>
<span class="c1">// Runtime: 3 ms, faster than 70.75% of Java online submissions for Car Pooling.</span>
<span class="c1">// Memory Usage: 38.9 MB, less than 52.80% of Java online submissions for Car Pooling.</span>

<span class="kt">boolean</span> <span class="nf">carPooling</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">trips</span><span class="o">,</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 最多有 1000 个车站</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">1001</span><span class="o">];</span>
    <span class="c1">// 构造差分解法</span>
    <span class="nc">Difference</span> <span class="n">df</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Difference</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">trip</span> <span class="o">:</span> <span class="n">trips</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 乘客数量</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">trip</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">// 第 trip[1] 站乘客上车</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">trip</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="c1">// 第 trip[2] 站乘客已经下车，</span>
        <span class="c1">// 即乘客在车上的区间是 [trip[1], trip[2] - 1]</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">trip</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// 进行区间操作</span>
        <span class="n">df</span><span class="o">.</span><span class="na">increment</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="na">result</span><span class="o">();</span>
    <span class="c1">// 客车自始至终都不应该超载</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">res</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">capacity</span> <span class="o">&lt;</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>


<span class="kd">class</span> <span class="nc">Difference</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">diff</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Difference</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
        <span class="k">assert</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="n">diff</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">+=</span><span class="n">k</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">diff</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="n">diff</span><span class="o">[</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">-=</span><span class="n">k</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">result</span><span class="o">(){</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">diff</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="n">res</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">diff</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h1 id="linkedlist">LinkedList</h1><ul><li><p>an alternative to an array-based structure.</p><li><p>A linked list, in its simplest form, is a collection of nodes that collectively form a linear sequence.</p><li><p>An important property of a linked list is that <code class="language-plaintext highlighter-rouge">it does not have a predetermined fixed size</code>; it uses space proportional to its current number of elements.</p></ul><hr /><h2 id="basicc">basicc</h2><h3 id="singly-linked-list">singly linked list</h3><ul><li>In a <strong>singly linked list</strong>,<ul><li>each node stores a reference to an object that is an element of the sequence,<li>as well as a reference to the next node of the list</ul><li><code class="language-plaintext highlighter-rouge">head</code><ul><li>Minimally, the linked list instance must keep a reference to the first node of the list<li>Without an <code class="language-plaintext highlighter-rouge">explicit reference</code> to the head, there would be no way to locate that node (or indirectly, any others).</ul><li><code class="language-plaintext highlighter-rouge">tail</code><ul><li>The last node of the list<li>can be found by traversing the linked list—starting at the head and moving from one node to another by following each node’s next reference. <strong>link/pointer hopping</strong><li>identify the tail as the node having null as its next reference.<li>storing an <code class="language-plaintext highlighter-rouge">explicit reference</code> to the tail node is a common efficiency to avoid such a traversal. In similar regard, it is common for a linked list instance to keep a count of the total number of nodes that comprise the list (also known as the size of the list), to avoid traversing the list to count the nodes.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/t0PStKi.png" alt="Screen Shot 2022-03-03 at 21.26.04" /></p><p><strong>Inserting an Element at the Head of a Singly Linked List</strong></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nc">Algorithm</span> <span class="nf">addFirst</span><span class="o">(</span><span class="n">e</span><span class="o">):</span>
<span class="n">newest</span><span class="o">=</span><span class="nc">Node</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
<span class="n">newest</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
<span class="n">head</span> <span class="o">=</span> <span class="n">newest</span><span class="o">;</span>
<span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</pre></table></code></div></div><p><strong>Inserting an Element at the Tail of a Singly Linked List</strong></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nc">Algorithm</span> <span class="nf">addLast</span><span class="o">(</span><span class="n">e</span><span class="o">):</span>
<span class="n">newest</span><span class="o">=</span><span class="nc">Node</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
<span class="n">newest</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="n">tail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newest</span><span class="o">;</span>
<span class="n">tail</span> <span class="o">=</span> <span class="n">newest</span><span class="o">;</span>
<span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</pre></table></code></div></div><p><strong>Removing an Element from a Singly Linked List</strong></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nc">Algorithm</span> <span class="nf">removeFirst</span><span class="o">():</span>
<span class="k">if</span> <span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">:</span>
    <span class="n">the</span> <span class="n">list</span> <span class="n">is</span> <span class="n">empty</span><span class="o">;</span>
<span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
</pre></table></code></div></div><p><strong>other</strong></p><ul><li>Unfortunately, we cannot easily delete the last node of a singly linked list.<li>we must be able to access the node before the last node in order to remove the last node.<li>The only way to access this node is to start from the head of the list and search all the way through the list.<li>to support such an operation efficiently, we will need to make our list <strong>doubly linked</strong></ul><hr /><h3 id="circularly-linked-lists">Circularly Linked Lists</h3><ul><li><p>there are many applications in which data can be more naturally viewed as having a cyclic order, with well-defined neighboring relationships, but no fixed beginning or end.</p><li><p>essentially a singularly linked list, the <code class="language-plaintext highlighter-rouge">next reference of the tail node</code> is set to refer back to the head of the list (rather than null),</p></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/4tzqpWi.png" alt="Screen Shot 2022-03-03 at 22.17.09" /></p><p><strong>Round-Robin Scheduling</strong></p><ul><li>One of the most important roles of an operating system is in managing the many processes that are currently active on a computer, including the scheduling of those processes on one or more central processing units (CPUs).<li>In order to support the responsiveness of an arbitrary number of concurrent processes, most operating systems allow processes to effectively share use of the CPUs, using some form of an algorithm known as <code class="language-plaintext highlighter-rouge">round-robin scheduling</code>.<ul><li>A process is given a short turn to execute, known as a <code class="language-plaintext highlighter-rouge">time slice</code>,<li>it is interrupted when the slice ends, even if its job is not yet complete.<li>Each active process is given its own time slice, taking turns in a cyclic order.<li>New processes can be added to the system, and processes that complete their work can be removed.</ul></ul><ol><li>traditional linked list<ol><li>by repeatedly performing the following steps on linked list L<ol><li>process p = L.removeFirst( )<li>Give a time slice to process p<li>L.addLast(p)</ol><li>drawbacks: unnecessarily inefficient to repeatedly throw away a node from one end of the list, only to create a new node for the same element when reinserting it, not to mention the various updates that are performed to decrement and increment the list’s size and to unlink and relink nodes.</ol><li>Circularly Linked List<ol><li>on a circularly linked list C:<ol><li>Give a time slice to process C.first()<li>C.rotate()</ol><li>Implementing the new rotate method is quite trivial.<ol><li>do not move any nodes or elements<li>simply advance the tail reference to point to the node that follows it (the implicit head of the list).</ol></ol></ol><hr /><h3 id="doubly-linked-list">doubly linked list</h3><ul><li>there are limitations that stem from the asymmetry of a singly linked list.<ul><li>can efficiently insert a node at either end of a singly linked list, and can delete a node at the head of a list,<li>cannot efficiently delete a node at the tail of the list.<li>cannot efficiently delete an arbitrary node from an interior position of the list if only given a reference to that node, because we cannot determine the node that immediately precedes the node to be deleted (yet, that node needs to have its next reference updated).</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/dzUHpQI.png" alt="Screen Shot 2022-03-04 at 09.56.42" /></p><p><strong>doubly linked list</strong></p><ul><li>a linked list, each node keeps an explicit reference to the node before it and a reference to the node after it.<li>These lists allow a greater variety of O(1)-time update operations, including insertions and deletions at arbitrary positions within the list.<li>We continue to use the term “next” for the reference to the node that follows another, and we introduce the term “prev” for the reference to the node that precedes it.</ul><p><strong>Header and Trailer Sentinels</strong></p><ul><li>to avoid some special cases when operating near the boundaries of a doubly linked list, it helps to add special nodes at both ends of the list: a <code class="language-plaintext highlighter-rouge">header</code> node at the beginning of the list, and a <code class="language-plaintext highlighter-rouge">trailer</code> node at the end of the list.<li>These “dummy” nodes are known as <code class="language-plaintext highlighter-rouge">sentinels/guards</code>, and they do not store elements of the primary sequence.<li>When using sentinel nodes, an empty list is initialized so that the <code class="language-plaintext highlighter-rouge">next field of the header points to the trailer</code>, and the <code class="language-plaintext highlighter-rouge">prev field of the trailer points to the header</code>; the remaining fields of the sentinels are irrelevant (presumably null, in Java).<li>For a nonempty list, the header’s next will refer to a node containing the first real element of a sequence, just as the trailer’s prev references the node containing the last element of a sequence.</ul><p><strong>Advantage of Using Sentinels</strong></p><ul><li>Although we could implement a doubly linked list without sentinel nodes, slight extra memory devoted to the <code class="language-plaintext highlighter-rouge">sentinels greatly simplifies the logic of the operations</code>.<ul><li>the header and trailer nodes never change — only the nodes between them change.<li>treat all insertions in a unified manner, because a new node will always be placed between a pair of existing nodes.<li>every element that is to be deleted is guaranteed to be stored in a node that has neighbors on each side.</ul><li>contrast<ul><li>SinglyLinkedList implementation addLast method required a conditional to manage the special case of inserting into an empty list.<li>In the general case, the new node was linked after the existing tail.<li>But when adding to an empty list, there is no existing tail; instead it is necessary to reassign head to reference the new node.<li>The use of a sentinel node in that implementation would eliminate the special case, as there would always be an existing node (possibly the header) before a new node.</ul></ul><h2 id="general-method">general method</h2><h3 id="equivalence-testing">Equivalence Testing</h3><ul><li>At the lowest level, if a and b are reference variables, then<code class="language-plaintext highlighter-rouge"> expression a == b tests whether a and b refer to the same object</code> (or if both are set to the null value).<li>higher-level notion of two variables being considered “equivalent” even if they do not actually refer to the same instance of the class. For example, we typically want to consider two String instances to be equivalent to each other if they represent the identical sequence of characters.<li>To support a broader notion of equivalence, all object types support a method named equals.<li><p>The author of each class has a responsibility to provide an implementation of the equals method, which overrides the one inherited from Object, if there is a more relevant definition for the equivalence of two instances</p><li>Great care must be taken when overriding the notion of equality, as the consistency of Java’s libraries depends upon the <strong>equals method defining</strong> what is known as an <strong>equivalence relation</strong> in mathematics, satisfying the following properties:<ul><li><code class="language-plaintext highlighter-rouge">Treatment of null</code>:<ul><li>For any nonnull reference variable x, <code class="language-plaintext highlighter-rouge">x.equals(null) == false</code> (nothing equals null except null).</ul><li><code class="language-plaintext highlighter-rouge">Reflexivity</code>:<ul><li>For any nonnull reference variablex, <code class="language-plaintext highlighter-rouge">x.equals(x) == true</code> (object should equal itself).</ul><li><code class="language-plaintext highlighter-rouge">Symmetry</code>:<ul><li>For any nonnull reference variablesxandy, <code class="language-plaintext highlighter-rouge">x.equals(y) == y.equals(x)</code>, should return the same value.</ul><li><code class="language-plaintext highlighter-rouge">Transitivity</code>:<ul><li>For any nonnull reference variables x, y, and z, if <code class="language-plaintext highlighter-rouge">x.equals(y) == y.equals(z) == true</code>, then <code class="language-plaintext highlighter-rouge">x.equals(z) == true</code> as well.</ul></ul><li>Equivalence Testing with Arrays<ul><li>a == b:<ul><li>Tests if a and b refer to the same underlying array instance.</ul><li>a.equals(b):<ul><li>identical to a == b. Arrays are not a true class type and do not override the Object.equals method.</ul><li>Arrays.equals(a,b):<ul><li>This provides a more intuitive notion of equivalence, <strong>returning true if the arrays have the same length and all pairs of corresponding elements are “equal” to each other</strong>.<li>More specifically, if the array elements are primitives, then it uses the standard == to compare values.<li>If elements of the arrays are a reference type, then it makes pairwise <code class="language-plaintext highlighter-rouge">comparisons a[k].equals(b[k])</code> in evaluating the equivalence.</ul></ul><li>compound objects<ul><li>two-dimensional arrays in Java are really one-dimensional arrays nested inside a common one-dimensional array raises an interesting issue with respect to how we think about compound objects<li>two-dimensional array, b, that has the same entries as a<ul><li>But the one-dimensional arrays, <strong>the rows of a and b are stored in different memory locations</strong>, even though they have the same internal content.<li>Therefore<ul><li><code class="language-plaintext highlighter-rouge">java.util.Arrays.equals(a,b) == false</code><li><code class="language-plaintext highlighter-rouge">Arrays.deepEquals(a,b) == true</code></ul></ul></ul></ul><hr /><h3 id="cloning-data-structures">Cloning Data Structures</h3><ul><li><strong>abstraction</strong> allows for a data structure to be treated as a single object, even though the encapsulated implementation of the structure might rely on a more complex combination of many objects.<li><p>each class in Java is responsible for defining whether its instances can be copied, and if so, precisely how the copy is constructed.</p><li>The universal <code class="language-plaintext highlighter-rouge">Object superclass</code> defines a method named <code class="language-plaintext highlighter-rouge">clone</code><ul><li>can be used to produce shallow copy of an object.<li>This uses the standard assignment semantics to assign the value of <code class="language-plaintext highlighter-rouge">each field of the new object</code> equal to the <code class="language-plaintext highlighter-rouge">corresponding field of the existing object</code> that is being copied.<li>The reason this is known as a shallow copy is because if the field is a reference type, then an initialization of the form <code class="language-plaintext highlighter-rouge">duplicate.field = original.field</code> causes the field of the new object to refer to the same underlying instance as the field of the original object.</ul><li>A <code class="language-plaintext highlighter-rouge">shallow copy</code> is not always appropriate for all classes<ul><li>therefore, Java intentionally <strong>disables use of the clone() method</strong> by<ul><li>declaring it as protected,<li>having it throw a CloneNotSupportedException when called.</ul><li>The author of a class must explicitly declare support for cloning by<ul><li>formally declaring that the class implements the <code class="language-plaintext highlighter-rouge">Cloneable interface</code>,<li>and by declaring a public version of the clone() method.</ul><li>That public method can simply call the protected one to do the field-by-field assignment that results in a shallow copy, if appropriate. However, for many classes, the class may choose to implement a deeper version of cloning, in which some of the referenced objects are themselves cloned.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/5l3YSL1.png" alt="Screen Shot 2022-03-04 at 11.13.02" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/gUZfkkP.png" alt="Screen Shot 2022-03-04 at 11.13.41" /></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[</span> <span class="o">]</span> <span class="n">data</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">17</span><span class="o">,</span> <span class="mi">19</span><span class="o">};</span>
<span class="kt">int</span><span class="o">[</span> <span class="o">]</span> <span class="n">backup</span><span class="o">;</span>

<span class="n">backup</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span> <span class="c1">// warning; not a copy</span>
<span class="n">backup</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>  <span class="c1">// copy</span>
</pre></table></code></div></div><p><strong>shallow copy</strong></p><ul><li>considerations when copying an array that stores <code class="language-plaintext highlighter-rouge">reference types</code> rather than <code class="language-plaintext highlighter-rouge">primitive types</code>.<ul><li>The <code class="language-plaintext highlighter-rouge">clone()</code> method produces a shallow copy of the array<li>producing a new array whose cells refer to the same objects referenced by the first array.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/jzdkcuy.png" alt="Screen Shot 2022-03-04 at 11.16.26" /></p><p><strong>deep copy</strong></p><ul><li>A <strong>deep copy</strong> of the contact list can be created by iteratively cloning the individual elements, as follows, but only if the Person class is declared as Cloneable.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">Person</span><span class="o">[</span> <span class="o">]</span> <span class="n">guests</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">[</span><span class="n">contacts</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">contacts</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
    <span class="n">guests</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Person</span><span class="o">)</span> <span class="n">contacts</span><span class="o">[</span><span class="n">k</span><span class="o">].</span><span class="na">clone</span><span class="o">();</span> <span class="c1">// returns Object type</span>
</pre></table></code></div></div><p><strong>clone on 2D Arrays</strong></p><ul><li>two-dimensional array is really a one-dimensional array storing other one-dimensional arrays, the same distinction between a shallow and deep copy exists.<li>Unfortunately, the java.util.Arrays class does not provide any “deepClone” method.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// A method for creating a deep copy of a two-dimensional array of integers.</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">deepClone</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">original</span><span class="o">){</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">backup</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">original</span><span class="o">.</span><span class="na">length</span><span class="o">][];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">original</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">k</span><span class="o">++){</span>
        <span class="n">backup</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">original</span><span class="o">[</span><span class="n">k</span><span class="o">].</span><span class="na">clone</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">backup</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Cloning Linked Lists</strong></p><ul><li>to making a class cloneable in Java<ul><li>declaring that it <code class="language-plaintext highlighter-rouge">implements the Cloneable interface</code>.<li>implementing a <code class="language-plaintext highlighter-rouge">public version of the clone() method</code> of the class<li>By convention, that method should begin by creating a new instance using a call to <code class="language-plaintext highlighter-rouge">super.clone()</code>, which in our case invokes the method from the Object class</ul></ul><blockquote><p>While the assignment of the size variable is correct, we cannot allow the new list to share the same head value (unless it is null). For a nonempty list to have an independent state, it must have an entirely new chain of nodes, each storing a reference to the corresponding element from the original list. We therefore create a new head node, and then perform a walk through the remainder of the original list while creating and linking new nodes for the new list.</p></blockquote><hr /><h2 id="单链表的六大解题套路">单链表的六大解题套路</h2><hr /><h3 id="合并两个有序链表-merge-2-sorted-lists">合并两个有序链表 Merge 2 Sorted Lists</h3><blockquote><p>21 题合并两个有序链表</p></blockquote><p>两个有序链表，合并成一个新的有序链表</p><p>Solution:「拉拉链」，l1, l2 类似于拉链两侧的锯齿，指针 p 就好像拉链的拉索，将两个有序链表合并。</p><ul><li>链表的算法题中是很常见的「虚拟头结点」技巧，<code class="language-plaintext highlighter-rouge">dummy</code> 节点。<ul><li>如果不使用 dummy 虚拟节点，代码会复杂很多，<li>而有了 dummy 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。<li>比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。<li>但有了我们虚拟节点 dummy 的存在，就避免了这个问题，能够对这种情况进行正确的删除。</ul></ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="c1">// Definition for singly-linked list.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ListNode</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">next</span><span class="o">;</span>
    <span class="nc">ListNode</span><span class="o">(){}</span>
    <span class="nc">ListNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">){</span><span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;}</span>
    <span class="nc">ListNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span> <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;}</span>
<span class="o">}</span>

<span class="c1">// O(n)</span>
<span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Merge Two Sorted Lists.</span>
<span class="c1">// Memory Usage: 38.4 MB, less than 75.55% of Java online submissions for Merge Two Sorted Lists.</span>
<span class="nc">ListNode</span> <span class="nf">mergeTwoLists</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">l1</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">l2</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">l2</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">l1</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
    <span class="nc">ListNode</span> <span class="n">p</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">l1</span><span class="o">!=</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">l2</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">l1</span><span class="o">.</span><span class="na">val</span><span class="o">&lt;</span><span class="n">l2</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
            <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l1</span><span class="o">;</span>
            <span class="n">l1</span><span class="o">=</span><span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l2</span><span class="o">;</span>
            <span class="n">l2</span><span class="o">=</span><span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">l1</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l2</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">l2</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">l1</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// recursion</span>
<span class="c1">// won't use recursion for a O(n) solution.</span>
<span class="c1">// This solution will result into Stack overflow error with some-thousand elements input.</span>
<span class="c1">// It's nice but impractical.</span>
<span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Merge Two Sorted Lists.</span>
<span class="c1">// Memory Usage: 38.3 MB, less than 75.55% of Java online submissions for Merge Two Sorted Lists.</span>
<span class="nc">ListNode</span> <span class="nf">mergeTwoLists</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">l1</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">l2</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">l2</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">l1</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">l1</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
        <span class="n">l1</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">mergeTwoLists</span><span class="o">(</span><span class="n">l1</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">l2</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">l1</span>
    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
        <span class="n">l2</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">mergeTwoLists</span><span class="o">(</span><span class="n">l2</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">l1</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">l2</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># iteratively
</span>    <span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
        <span class="c1"># while
</span>        <span class="n">dummy</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">dummy</span>
        <span class="k">while</span> <span class="n">l1</span> <span class="ow">and</span> <span class="n">l2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l1</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">p</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">l1</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">l2</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">p</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">l1</span> <span class="ow">or</span> <span class="n">l2</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>

    <span class="c1"># recursively
</span>    <span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">l1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">l2</span><span class="p">:</span>
             <span class="k">return</span> <span class="n">l1</span> <span class="ow">or</span> <span class="n">l2</span>
        <span class="k">if</span> <span class="n">l1</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">l1</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">mergeTwoLists</span><span class="p">(</span><span class="n">l1</span><span class="p">.</span><span class="nb">next</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">l1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l2</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">mergeTwoLists</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">.</span><span class="nb">next</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">l2</span>

    <span class="c1"># recursively
</span>    <span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
            <span class="n">a</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">mergeTwoLists</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="nb">next</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span> <span class="ow">or</span> <span class="n">b</span>

    <span class="c1"># in-place, iteratively
</span>    <span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">None</span> <span class="ow">in</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">l1</span> <span class="ow">or</span> <span class="n">l2</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">l1</span>
        <span class="k">while</span> <span class="n">l1</span> <span class="ow">and</span> <span class="n">l2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l1</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nxt</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
                <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">l2</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">l2</span><span class="p">.</span><span class="nb">next</span>
                <span class="n">l2</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">nxt</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">l1</span> <span class="ow">or</span> <span class="n">l2</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="nb">next</span>
</pre></table></code></div></div><hr /><h3 id="23-merge-k-sorted-lists-合并-k-个有序链表-merge-k-sorted-lists">23. Merge k Sorted Lists 合并 k 个有序链表 Merge k Sorted Lists</h3><p>[23. Merge k Sorted Lists]</p><p>合并 k 个有序链表的逻辑类似合并两个有序链表</p><p>point: 如何快速得到 k 个节点中的最小节点，接到结果链表上？</p><ul><li>用到 优先级队列（二叉堆） 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 k 个节点中的最小节点：</ul><p>时间复杂度:</p><ul><li>优先队列 pq 中的元素个数最多是 k，<li>所以一次 poll 或者 add 方法的时间复杂度是 O(logk)；<li>所有的链表节点都会被加入和弹出 pq，所以算法整体的时间复杂度是 O(Nlogk)，<li>其中 k 是链表的条数，N 是这些链表的节点总数。</ul><ol><li>Brute-Force<ol><li>It is okay if N is not too large.<li>Traverse all the linked lists and collect the values of the nodes into an array. - O(N)<li>Sort the array. - O(Nlog{N})<li>Traverse the array and make the linked list. - O(N)<li>Time: O(Nlog{N}) where N is the total number of nodes.<li>Space: O(N) since we need an array and a new linked list.</ol><li>Compare One-By-One</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">mergeKLists</span><span class="o">(</span><span class="nc">ListNode</span><span class="o">[]</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">lists</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
  <span class="nc">ListNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>

  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">minNode</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">minIdx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

    <span class="c1">// Iterate over lists</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lists</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">ListNode</span> <span class="n">currList</span> <span class="o">=</span> <span class="n">lists</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">currList</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">minNode</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">currList</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">minNode</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">minNode</span> <span class="o">=</span> <span class="n">currList</span><span class="o">;</span>
        <span class="n">minIdx</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// check if finished</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">minNode</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>

    <span class="c1">// link</span>
    <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">minNode</span><span class="o">;</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

    <span class="c1">// delete</span>
    <span class="n">lists</span><span class="o">[</span><span class="n">minIdx</span><span class="o">]</span> <span class="o">=</span> <span class="n">minNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="c1">// may be null</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>Compare One-By-One (minPQ)</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="nc">ListNode</span> <span class="nf">mergeKLists</span><span class="o">(</span><span class="nc">ListNode</span><span class="o">[]</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lists</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">// 虚拟头结点</span>
    <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
    <span class="nc">ListNode</span> <span class="n">p</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
    <span class="c1">// 优先级队列，最小堆</span>
    <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">ListNode</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span>
        <span class="n">lists</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)-&gt;(</span><span class="n">a</span><span class="o">.</span><span class="na">val</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">val</span><span class="o">)</span>
    <span class="o">);</span>
    <span class="c1">// 将 k 个链表的头结点加入最小堆</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span> <span class="o">:</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// 获取最小节点，接到结果链表中</span>
        <span class="nc">ListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// p 指针不断前进</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>时间复杂度</p><ul><li>优先队列 pq 中的元素个数最多是 k，<li>所以一次 poll 或者 add 方法的时间复杂度是 <code class="language-plaintext highlighter-rouge">O(logk)</code>；<li>所有的链表节点都会被加入和弹出 pq，所以算法整体的时间复杂度是 <code class="language-plaintext highlighter-rouge">O(Nlogk)</code>，其中 k 是链表的条数，N 是这些链表的节点总数。</ul><hr /><h2 id="递归反转链表">递归反转链表</h2><hr /><h3 id="206-reverse-linked-list-递归反转整个链表-递归pointer">206. Reverse Linked List 递归反转整个链表 <code class="language-plaintext highlighter-rouge">递归+pointer</code></h3><p><a href="https://leetcode.com/problems/reverse-linked-list/">206. Reverse Linked List</a></p><ul><li>Given the head of a singly linked list, reverse the list, and return the reversed list.<li>Input: head = [1,2,3,4,5]<li>Output: [5,4,3,2,1]</ul><h4 id="-递归">+++++ 递归</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// recursion</span>
<span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List.</span>
<span class="c1">// Memory Usage: 39.3 MB, less than 38.00% of Java online submissions for Reverse Linked List.</span>
<span class="nc">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">==</span><span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">last</span> <span class="o">=</span> <span class="n">reverseList</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
    <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-2-pointer">+++++ 2 pointer</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List.</span>
<span class="c1">// Memory Usage: 39 MB, less than 51.90% of Java online submissions for Reverse Linked List.</span>
<span class="nc">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">pre</span><span class="o">,</span> <span class="n">cur</span><span class="o">,</span> <span class="n">nxt</span><span class="o">;</span>
    <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span> <span class="n">nxt</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">nxt</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="c1">// 逐个结点反转</span>
        <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
        <span class="c1">// 更新指针位置</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">nxt</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 返回反转后的头结点</span>
    <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="反转链表前-n-个节点">反转链表前 N 个节点</h3><p>具体的区别：</p><ol><li>base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。<li>刚才我们直接把 head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。<ol><li>但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。</ol></ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="nc">ListNode</span> <span class="n">successor</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 后驱节点</span>

<span class="c1">// 反转以 head 为起点的 n 个节点，返回新的头结点</span>
<span class="nc">ListNode</span> <span class="nf">reverseN</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 记录第 n + 1 个节点</span>
        <span class="n">successor</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 以 head.next 为起点，需要反转前 n - 1 个节点</span>
    <span class="nc">ListNode</span> <span class="n">last</span> <span class="o">=</span> <span class="n">reverseN</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="c1">// 让反转之后的 head 节点和后面的节点连起来</span>
    <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">successor</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="92-reverse-linked-list-ii-反转链表的一部分">92. Reverse Linked List II 反转链表的一部分</h3><p><a href="https://leetcode.com/problems/reverse-linked-list-ii/">92. Reverse Linked List II</a></p><ul><li><p>Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.</p><li>Input: head = [1,2,3,4,5], left = 2, right = 4<li>Output: [1,4,3,2,5]</ul><h4 id="-iterative">+++++ iterative</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List II.</span>
<span class="c1">// Memory Usage: 36.6 MB, less than 58.03% of Java online submissions for Reverse Linked List II.</span>
<span class="c1">// O(1) space</span>
<span class="c1">// O(n) Solution</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reverseBetween</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span><span class="o">==</span><span class="kc">null</span> <span class="o">||</span> <span class="n">left</span><span class="o">==</span><span class="n">right</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">head</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">left</span><span class="o">){</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="c1">// flow of execution in each iteration (for the 2nd input):</span>
        <span class="c1">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7 |</span>
        <span class="c1">// 1-&gt;2-&gt;4-&gt;3-&gt;5-&gt;6-&gt;7 |</span>
        <span class="c1">// 1-&gt;2-&gt;5-&gt;4-&gt;3-&gt;6-&gt;7 |</span>
        <span class="c1">// 1-&gt;2-&gt;6-&gt;5-&gt;4-&gt;3-&gt;7 |</span>
        <span class="c1">// 1-&gt;2-&gt;7-&gt;6-&gt;5-&gt;4-&gt;3</span>
        <span class="nc">ListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">right</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-recursive">+++++ recursive</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List II.</span>
<span class="c1">// Memory Usage: 36.6 MB, less than 75.28% of Java online submissions for Reverse Linked List II.</span>
<span class="nc">ListNode</span> <span class="nf">reverseBetween</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">reverseN</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
    <span class="c1">// 前进到反转的起点触发 base case</span>
    <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">reverseBetween</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 反转以 head 为起点的 n 个节点，返回新的头结点</span>
<span class="nc">ListNode</span> <span class="nf">reverseN</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="nc">ListNode</span> <span class="n">successor</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 后驱节点</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 记录第 n + 1 个节点</span>
        <span class="n">successor</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 以 head.next 为起点，需要反转前 n - 1 个节点</span>
    <span class="nc">ListNode</span> <span class="n">last</span> <span class="o">=</span> <span class="n">reverseN</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="c1">// 让反转之后的 head 节点和后面的节点连起来</span>
    <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">successor</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="25-reverse-nodes-in-k-group-k个一组反转链表">25. Reverse Nodes in k-Group K个一组反转链表</h3><p><a href="">25. Reverse Nodes in k-Group</a></p><ul><li>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.<li>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.<li>You may not alter the values in the list’s nodes, only nodes themselves may be changed.<li>Input:<li>head = [1,2,3,4,5], k = 2<li>Output: [2,1,4,3,5]</ul><h4 id="-ab-reverse-anextreversekbk">+++++ <code class="language-plaintext highlighter-rouge">a,b reverse(), a.next=reverseK(b,k)</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Nodes in k-Group.</span>
<span class="c1">// Memory Usage: 39.4 MB, less than 60.83% of Java online submissions for Reverse Nodes in k-Group.</span>

<span class="nc">ListNode</span> <span class="nf">reverseKGroup</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">// 区间 [a, b) 包含 k 个待反转元素</span>
    <span class="c1">// 1,2,3,4,5,6</span>
    <span class="nc">ListNode</span> <span class="n">a</span><span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">b</span><span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">// 不足 k 个，不需要反转，base case</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 3,2,1,   4,5,6</span>
    <span class="c1">// 反转前 k 个元素</span>
    <span class="nc">ListNode</span> <span class="n">newHead</span> <span class="o">=</span> <span class="n">reverse</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
    <span class="c1">// 递归反转后续链表并连接起来</span>
    <span class="n">a</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">reverseKGroup</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">newHead</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/** 反转区间 [a, b) 的元素，注意是左闭右开 */</span>
<span class="nc">ListNode</span> <span class="nf">reverse</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">a</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">pre</span><span class="o">,</span> <span class="n">cur</span><span class="o">,</span> <span class="n">nxt</span><span class="o">;</span>
    <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span> <span class="n">nxt</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="c1">// while 终止的条件改一下就行了</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">nxt</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">nxt</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 返回反转后的头结点</span>
    <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>–</p><h3 id="143-reorder-list-medium">143. Reorder List (Medium)</h3><p>You are given the head of a singly linked-list. The list can be represented as:</p><p>L0 → L1 → … → Ln - 1 → Ln Reorder the list to be on the following form:</p><p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … You may not modify the values in the list’s nodes. Only nodes themselves may be changed.</p><h4 id="-two-pointer-find-middle-reverse-combinen1n2">+++++ <code class="language-plaintext highlighter-rouge">Two pointer, find middle, reverse(), combine(n1,n2)</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 99.86% of Java online submissions for Reorder List.</span>
<span class="c1">// Memory Usage: 42 MB, less than 45.07% of Java online submissions for Reorder List.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reorderList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//Find the middle of the list</span>
        <span class="nc">ListNode</span> <span class="n">fast</span><span class="o">=</span><span class="n">head</span><span class="o">,</span> <span class="n">slow</span><span class="o">=</span><span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">!=</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// reverse</span>
        <span class="nc">ListNode</span> <span class="n">second</span> <span class="o">=</span> <span class="n">reverse</span><span class="o">(</span><span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
        <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
        <span class="c1">// merge</span>
        <span class="n">combine</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">second</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reverse</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">pre</span><span class="o">=</span><span class="kc">null</span><span class="o">,</span> <span class="n">cur</span><span class="o">=</span><span class="n">head</span><span class="o">,</span> <span class="n">nxt</span><span class="o">=</span><span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">nxt</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">=</span><span class="n">pre</span><span class="o">;</span>
            <span class="n">pre</span><span class="o">=</span><span class="n">cur</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">=</span><span class="n">nxt</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">combine</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">n1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">n2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="n">n2</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">f_temp</span> <span class="o">=</span> <span class="n">n1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="nc">ListNode</span> <span class="n">s_temp</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">n1</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">n2</span><span class="o">;</span>
            <span class="n">n2</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">f_temp</span><span class="o">;</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">s_temp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-2-pointer-listaddlistnode-reorder-list">+++++ <code class="language-plaintext highlighter-rouge">2 pointer. list.add(ListNode), reorder list</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 51.01% of Java online submissions for Reorder List.</span>
<span class="c1">// Memory Usage: 41.5 MB, less than 85.84% of Java online submissions for Reorder List.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reorderList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ListNode</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">dummy</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">dummy</span><span class="o">);</span>
            <span class="n">dummy</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">left</span><span class="o">++);</span>
            <span class="k">else</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">right</span><span class="o">--);</span>
            <span class="n">dummy</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="1721-swapping-nodes-in-a-linked-list-medium">1721. Swapping Nodes in a Linked List (Medium)</h3><p><a href="https://leetcode.com/problems/swapping-nodes-in-a-linked-list/">1721. Swapping Nodes in a Linked List</a></p><p>You are given the head of a linked list, and an integer k.</p><p>Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).</p><p>Example 1: Input: head = [1,2,3,4,5], k = 2 Output: [1,4,3,2,5]</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 100.00% of Java online submissions for Swapping Nodes in a Linked List.</span>
<span class="c1">// Memory Usage: 53.9 MB, less than 96.45% of Java online submissions for Swapping Nodes in a Linked List.</span>
<span class="c1">// traverse the list only once, time complexity is O(n)</span>
<span class="c1">// store only 4 pointers for every list; the space complexity is constant: O(1)</span>
<span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">swapNodes</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">fast</span><span class="o">=</span><span class="n">head</span><span class="o">,</span> <span class="n">slow</span><span class="o">=</span><span class="n">head</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">first</span><span class="o">=</span><span class="n">fast</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="n">first</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="n">slow</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="24-swap-nodes-in-pairs-medium">24. Swap Nodes in Pairs (Medium)</h3><p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)</p><p>Example 1: Input: head = [1,2,3,4] Output: [2,1,4,3]</p><h4 id="-2-pointer-and-swap">+++++ <code class="language-plaintext highlighter-rouge">2 pointer and swap</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">swapPairs</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">newHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">ListNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

            <span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>

            <span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">newHead</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-recursive-1">+++++ <code class="language-plaintext highlighter-rouge">recursive</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Swap Nodes in Pairs.</span>
<span class="c1">// Memory Usage: 36.2 MB, less than 97.27% of Java online submissions for Swap Nodes in Pairs.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">swapPairs</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">p1</span><span class="o">=</span><span class="n">head</span><span class="o">,</span> <span class="n">p2</span><span class="o">=</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">p3</span><span class="o">=</span><span class="n">p2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">p2</span><span class="o">.</span><span class="na">next</span><span class="o">=</span><span class="n">p1</span><span class="o">;</span>
        <span class="n">p1</span><span class="o">.</span><span class="na">next</span><span class="o">=</span><span class="n">p3</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">p3</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">p1</span><span class="o">.</span><span class="na">next</span><span class="o">=</span><span class="n">swapPairs</span><span class="o">(</span><span class="n">p3</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">p2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="example">example</h3><hr /><h4 id="870-题优势洗牌">870 题「优势洗牌」</h4><p><a href="https://leetcode.com/problems/advantage-shuffle/">870. Advantage Shuffle</a></p><ul><li>You are given two integer arrays nums1 and nums2 both of the same length.<li>The advantage of nums1 with respect to nums2 is the number of indices i for which <code class="language-plaintext highlighter-rouge">nums1[i] &gt; nums2[i]</code>.<li>Return any permutation of nums1 that maximizes its advantage with respect to nums2.</ul><p>Example 1: Input: nums1 = [2,7,11,15], nums2 = [1,10,4,11] Output: [2,11,7,15]</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 67 ms, faster than 74.91% of Java online submissions for Advantage Shuffle.</span>
<span class="c1">// Memory Usage: 59.7 MB, less than 43.82% of Java online submissions for Advantage Shuffle.</span>

<span class="kt">int</span><span class="o">[]</span> <span class="nf">advantageCount</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

    <span class="c1">// 给 nums2 降序排序</span>
    <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">maxpq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span>
        <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">pair1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">pair2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span><span class="k">return</span> <span class="n">pair2</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">pair1</span><span class="o">[</span><span class="mi">1</span><span class="o">];}</span>
    <span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">maxpq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]});</span>

    <span class="c1">// 给 nums1 升序排序</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>

    <span class="c1">// nums1[left] 是最小值，nums1[right] 是最大值</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

    <span class="k">while</span> <span class="o">(!</span><span class="n">maxpq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">pair</span> <span class="o">=</span> <span class="n">maxpq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="c1">// maxval 是 nums2 中的最大值，i 是对应索引</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pair</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">maxval</span> <span class="o">=</span> <span class="n">pair</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="c1">// 如果 nums1[right] 能胜过 maxval，那就自己上</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">maxval</span> <span class="o">&lt;</span> <span class="n">nums1</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
            <span class="n">right</span><span class="o">--;</span>
        <span class="c1">// 否则用最小值混一下，养精蓄锐</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
            <span class="n">left</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="链表的环">链表的环</h2><p>–</p><h3 id="判断单链表是否包含环">判断单链表是否包含环</h3><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a></p><ul><li><p>Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><li><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.</p><li><p>Do not modify the linked list.</p></ul><p>solution:</p><ul><li>每当慢指针 slow 前进一步，快指针 fast 就前进两步。<li>如果 fast 最终遇到空指针，说明链表中没有环；<li>如果 fast 最终和 slow 相遇，那肯定是 fast 超过了 slow 一圈，说明链表中含有环。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 快慢指针初始化指向 head</span>
    <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="c1">// 快指针走到末尾时停止</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 慢指针走一步，快指针走两步</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="c1">// 快慢指针相遇，说明含有环</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 不包含环</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="142-linked-list-cycle-ii-计算链表中环起点">142. Linked List Cycle II 计算链表中环起点</h3><p>快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步：</p><ul><li>fast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的「整数倍」。<li>假设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。<li>如果从相遇点继续前进 k - m 步，也恰好到达环起点。<ul><li>因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了</ul><li>所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后一定会相遇，相遇之处就是环的起点了。</ul><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a></p><p>Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.</p><p>Do not modify the linked list.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Linked List Cycle II.</span>
<span class="c1">// Memory Usage: 39.1 MB, less than 62.77% of Java online submissions for Linked List Cycle II.</span>
<span class="nc">ListNode</span> <span class="nf">detectCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">fast</span><span class="o">,</span> <span class="n">slow</span><span class="o">;</span>
    <span class="n">fast</span> <span class="o">=</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="n">slow</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 上面的代码类似 hasCycle 函数</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// fast 遇到空指针说明没有环</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 重新指向头结点</span>
    <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="c1">// 快慢指针同步前进，相交点就是环起点</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><hr /><h1 id="回文链表-palindromic">回文链表 Palindromic</h1><ul><li>寻找回文串是从中间向两端扩展，<li>判断回文串是从两端向中间收缩。</ul><p>对于单链表</p><ul><li>无法直接倒序遍历，可以造一条新的反转链表，<li>可以利用链表的后序遍历，也可以用栈结构倒序处理单链表。</ul><hr /><hr /><h2 id="other">other</h2><h3 id="9-palindrome-number-判断回文number">9. Palindrome Number 判断回文Number</h3><p><a href="https://leetcode.com/problems/palindrome-number/">9. Palindrome Number</a></p><ul><li>Given an integer x, return true if x is palindrome integer.<li>An integer is a palindrome when it reads the same backward as forward.<li>For example, 121 is palindrome while 123 is not.</ul><h4 id="-reverse-half-of-it-best">+++++ reverse half of it <strong>Best</strong></h4><p>O(1) space solution</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Reverse Half &amp; Compare
 *
 * Time Complexity: O((log10 N) / 2)
 *
 * Space Complexity: O(1)
 *
 * N = Number of digits in input number.
 */</span>
<span class="c1">//  Runtime: 6 ms, faster than 99.94% of Java online submissions for Palindrome Number.</span>
<span class="c1">// Memory Usage: 38.2 MB, less than 89.24% of Java online submissions for Palindrome Number.</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="o">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">%</span><span class="mi">10</span><span class="o">==</span><span class="mi">0</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">%</span><span class="mi">10</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">100</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">%</span><span class="mi">11</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">1000</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">x</span><span class="o">/</span><span class="mi">100</span><span class="o">)*</span><span class="mi">10</span><span class="o">+</span><span class="n">x</span><span class="o">%</span><span class="mi">10</span><span class="o">)%</span><span class="mi">11</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="c1">// 12321</span>
    <span class="c1">// 1232 1</span>
    <span class="c1">// 123 12</span>
    <span class="c1">// 12 123</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">x</span><span class="o">&gt;</span><span class="n">res</span><span class="o">){</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">x</span><span class="o">%</span><span class="mi">10</span><span class="o">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="mi">10</span><span class="o">;</span>
       <span class="o">}</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="n">res</span> <span class="o">||</span> <span class="n">x</span><span class="o">==</span><span class="n">res</span><span class="o">/</span><span class="mi">10</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">reversed</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">)</span> <span class="n">reversed</span> <span class="o">=</span> <span class="n">reversed</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">reversed</span> <span class="o">==</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="elimination-game--perform-string-shifts--subtree-removal-game-with-fibonacci-tree">Elimination Game !!! Perform String Shifts !!! Subtree Removal Game with Fibonacci Tree</h3><hr /><hr /><h2 id="排序">排序</h2><ul><li>快速排序就是个二叉树的前序遍历，<li>归并排序就是个二叉树的后序遍历</ul><h3 id="快速排序">快速排序</h3><p>快速排序的逻辑是，</p><ul><li>对 nums[lo..hi] 进行排序，我们先找一个分界点 p，通过交换元素使得 nums[lo..p-1] 都小于等于 nums[p]，且 nums[p+1..hi] 都大于 nums[p]，<li>然后递归地去 nums[lo..p-1] 和 nums[p+1..hi] 中寻找新的分界点，<li>最后整个数组就被排序了。</ul><p>先构造分界点，然后去左右子数组构造分界点，</p><ul><li>就是一个二叉树的前序遍历</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
    <span class="cm">/****** 前序遍历位置 ******/</span>
    <span class="c1">// 通过交换元素构建分界点 p</span>
    <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
    <span class="cm">/************************/</span>

    <span class="n">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="n">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="归并排序">归并排序</h3><p>归并排序的逻辑，</p><ul><li>要对 nums[lo..hi] 进行排序，我们先对 nums[lo..mid] 排序，再对 nums[mid+1..hi] 排序，最后把这两个有序的子数组合并，整个数组就排好序了。</ul><p>二叉树的后序遍历框架</p><ul><li>先对左右子数组排序，然后合并（类似合并有序链表的逻辑）</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
    <span class="n">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
    <span class="n">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
    <span class="cm">/****** 后序遍历位置 ******/</span>
    <span class="c1">// 合并两个排好序的子数组</span>
    <span class="n">merge</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
    <span class="cm">/************************/</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h1 id="stack">stack</h1><p>栈（stack）是很简单的一种数据结构，先进后出的逻辑顺序，符合某些问题的特点，比如说函数调用栈。</p><hr /><h2 id="队列-栈">队列 栈</h2><hr /><h3 id="232-implement-queue-using-stacks-用栈实现队列">232. Implement Queue using Stacks 用栈实现队列</h3><p><a href="https://leetcode.com/problems/implement-queue-using-stacks/">232. Implement Queue using Stacks</a></p><ul><li>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).<li><p>Implement the MyQueue class:</p><li>void push(int x) Pushes element x to the back of the queue.<li>int pop() Removes the element from the front of the queue and returns it.<li>int peek() Returns the element at the front of the queue.<li>boolean empty() Returns true if the queue is empty, false otherwise.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Implement Queue using Stacks.</span>
<span class="c1">// Memory Usage: 36.7 MB, less than 89.99% of Java online submissions for Implement Queue using Stacks</span>

<span class="kd">class</span> <span class="nc">MyQueue</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyQueue</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>

    <span class="cm">/** 添加元素到队尾 */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
        <span class="n">s1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
    <span class="o">};</span>

    <span class="cm">/** 删除队头的元素并返回 */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">(){</span>
        <span class="c1">// 先调用 peek 保证 s2 非空</span>
        <span class="n">peek</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">s2</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
    <span class="o">};</span>

    <span class="cm">/** 返回队头元素 */</span>
    <span class="c1">// 触发 while 循环，这样的话时间复杂度是 O(N)</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
            <span class="c1">// 把 s1 元素压入 s2</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">s1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
                <span class="n">s2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">s2</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/** 判断队列是否为空 */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">s1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
    <span class="o">};</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="225-implement-stack-using-queue-用队列实现栈">225. Implement Stack using Queue 用队列实现栈</h3><p><a href="https://leetcode.com/problems/implement-stack-using-queues/">225. Implement Stack using Queues</a></p><ul><li>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).<li>Implement the MyStack class:<li>void push(int x) Pushes element x to the top of the stack.<li>int pop() Removes the element on the top of the stack and returns it.<li>int top() Returns the element on the top of the stack.<li>boolean empty() Returns true if the stack is empty, false otherwise.</ul><p>pop 操作时间复杂度是 O(N)，其他操作都是 O(1) 。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Implement Stack using Queues.</span>
<span class="c1">// Memory Usage: 37.2 MB, less than 35.03% of Java online submissions for Implement Stack using Queues.</span>

<span class="kd">class</span> <span class="nc">MyStack</span> <span class="o">{</span>

    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="cm">/** 添加元素到栈顶 */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">};</span>

    <span class="cm">/** 删除栈顶的元素并返回 */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">(){</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
            <span class="n">size</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">()</span>
    <span class="o">};</span>


    <span class="cm">/** 返回栈顶元素 */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">top</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">top</span><span class="o">;</span>
    <span class="o">};</span>

    <span class="cm">/** 判断栈是否为空 */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
    <span class="o">};</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="code">code</h2><h3 id="reversing-an-array-using-a-stack">Reversing an Array Using a Stack</h3><ul><li>As a consequence of the LIFO protocol, a stack can be used as a general toll to reverse a data sequence.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="no">E</span><span class="o">[]</span> <span class="n">a</span><span class="o">){</span>
    <span class="nc">Statck</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayStack</span><span class="o">&lt;&gt;(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="k">for</span><span class="o">(</span><span class="no">E</span> <span class="nl">data:</span> <span class="n">a</span><span class="o">){</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
<span class="o">}</span>
<span class="n">reverse</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
</pre></table></code></div></div><hr /><h3 id="matching-parenthesesdelimiters">Matching Parentheses/Delimiters</h3><ul><li>We can use a stack to perform this task with a single left-to-right scan of the original string.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isMatched</span><span class="o">(</span><span class="nc">String</span> <span class="n">expression</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">String</span> <span class="n">opening</span> <span class="o">=</span> <span class="s">"({["</span><span class="o">;</span> <span class="c1">// opening delimiters</span>
    <span class="kd">final</span> <span class="nc">String</span> <span class="n">closing</span> <span class="o">=</span> <span class="s">")}]"</span><span class="o">;</span> <span class="c1">// closing delimiters</span>
    <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedStack</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span><span class="o">(</span><span class="nc">Char</span> <span class="nl">c:</span> <span class="n">expression</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">()){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">opening</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">c</span><span class="o">)!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">buffer</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">closing</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">c</span><span class="o">)!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span>
            <span class="nf">if</span><span class="o">(</span><span class="n">closing</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">!=</span> <span class="n">opening</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">pop</span><span class="o">()))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">buffer</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="matching-tags-in-a-markup-language">Matching Tags in a Markup Language</h3><ul><li>Ideally, an HTML document should have matching tags, although most browsers tolerate a certain number of mismatching tags.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isHTMLMatched</span><span class="o">(</span><span class="nc">String</span> <span class="n">html</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">String</span> <span class="n">opening</span> <span class="o">=</span> <span class="s">"({["</span><span class="o">;</span> <span class="c1">// opening delimiters</span>
    <span class="kd">final</span> <span class="nc">String</span> <span class="n">closing</span> <span class="o">=</span> <span class="s">")}]"</span><span class="o">;</span> <span class="c1">// closing delimiters</span>

    <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedStack</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">html</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="sc">'&lt;'</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">!=</span> <span class="err">−</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">html</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">"&gt;"</span><span class="o">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span><span class="o">==-</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">html</span><span class="o">.</span><span class="na">subSting</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">tag</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"/"</span><span class="o">))</span> <span class="n">buffer</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">tag</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">tag</span><span class="o">.</span><span class="na">subString</span><span class="o">[</span><span class="mi">1</span><span class="o">:].</span><span class="na">equals</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">pop</span><span class="o">()))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">html</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="sc">'&lt;'</span><span class="o">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">buffer</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
<span class="o">}</span>


</pre></table></code></div></div><hr /><h2 id="单调栈">单调栈</h2><ul><li>单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。<li>有点像堆（heap）？不是的，单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。</ul><h3 id="返回等长数组for更大的元素">返回等长数组for更大的元素</h3><p>给你一个数组 nums，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">nextGreaterElement</span><span class="o">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">res</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">());</span> <span class="c1">// 存放答案的数组</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">;</span>
    <span class="c1">// 倒着往栈里放</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
        <span class="c1">// 判定个子高矮</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">s</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
            <span class="c1">// 矮个起开，反正也被挡着了。。。</span>
            <span class="n">s</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">// nums[i] 身后的 next great number</span>
        <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
        <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="739-daily-temperatures-返回等长数组for更大的元素的index">739. Daily Temperatures 返回等长数组for更大的元素的index</h3><p><a href="https://leetcode.com/problems/daily-temperatures/">739. Daily Temperatures</a></p><ul><li>Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.<li>给你一个数组 T，这个数组存放的是近几天的天气气温，你返回一个等长的数组，计算：对于每一天，你还要至少等多少天才能等到一个更暖和的气温；如果等不到那一天，填 0。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 39 ms, faster than 43.88% of Java online submissions for Daily Temperatures.</span>
<span class="c1">// Memory Usage: 48.4 MB, less than 85.99% of Java online submissions for Daily Temperatures.</span>
<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">dailyTemperatures</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">temperatures</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span><span class="o">(</span><span class="n">temperatures</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">temperatures</span><span class="o">;</span>
    <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span>  <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">temperatures</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">temperatures</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">s</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">temperatures</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">()]</span> <span class="o">&lt;=</span> <span class="n">temperatures</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="n">s</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">()-</span><span class="n">i</span><span class="o">;</span>
        <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="环形数组">环形数组</h3><p>对于这种需求，常用套路就是将数组长度翻倍：</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">nextGreaterElements</span><span class="o">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">res</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">;</span>
    <span class="c1">// 假装这个数组长度翻倍了</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
        <span class="c1">// 索引要求模，其他的和模板一样</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">s</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">peak</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">n</span><span class="o">])</span> <span class="n">s</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="n">res</span><span class="o">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">peak</span><span class="o">();</span>
        <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">n</span><span class="o">]);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="单调队列结构">单调队列结构</h2><p>一个「队列」，队列中的元素全都是单调递增（或递减）的。</p><hr /><h3 id="滑动窗口问题">滑动窗口问题</h3><p>在 O(1) 时间算出每个「窗口」中的最大值</p><p>239 题「滑动窗口最大值」，难度 Hard：</p><ul><li>给你输入一个数组 nums 和一个正整数 k，有一个大小为 k 的窗口在 nums 上从左至右滑动，请你输出每次窗口中 k 个元素的最大值。<li>在一堆数字中，已知最值为 A，如果给这堆数添加一个数 B，那么比较一下 A 和 B 就可以立即算出新的最值；<li>但如果减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 A，就需要遍历所有数重新找新的最值。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 36 ms, faster than 47.84% of Java online submissions for Sliding Window Maximum.</span>
<span class="c1">// Memory Usage: 55.2 MB, less than 45.54% of Java online submissions for Sliding Window Maximum.</span>

<span class="cm">/* 单调队列的实现 */</span>
<span class="kd">class</span> <span class="nc">MonotonicQueue</span> <span class="o">{</span>
    <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 将小于 n 的元素全部删除</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">.</span><span class="na">getLast</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">pollLast</span><span class="o">();</span>
        <span class="c1">// 然后将 n 加入尾部</span>
        <span class="n">q</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">max</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span> <span class="c1">// 队头的元素肯定是最大的</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pop</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">q</span><span class="o">.</span><span class="na">getFirst</span><span class="o">())</span> <span class="n">q</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span> <span class="c1">// 在队头删除元素 n</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/* 解题函数的实现 */</span>
<span class="kt">int</span><span class="o">[]</span> <span class="nf">maxSlidingWindow</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">MonotonicQueue</span> <span class="n">window</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MonotonicQueue</span><span class="o">();</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">//先填满窗口的前 k - 1</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">window</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 窗口向前滑动，加入新数字</span>
            <span class="n">window</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="c1">// 记录当前窗口的最大值</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">window</span><span class="o">.</span><span class="na">max</span><span class="o">());</span>
            <span class="c1">// 移出旧数字</span>
            <span class="n">window</span><span class="o">.</span><span class="na">pop</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 需要转成 int[] 数组再返回</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">arr</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h1 id="queue">Queue</h1><h2 id="code-1">code</h2><h3 id="simulation-hot-potato">Simulation: Hot Potato</h3><p><a href="https://github.com/ocholuo/language/tree/master/0.code/leecode/Algorithms/queue-hot-potato.py">code</a></p><p><img data-proofer-ignore data-src="https://i.imgur.com/VB33sdN.png" alt="hotpotato" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/k57sicw.png" alt="namequeue" /></p><blockquote><p>arranged themselves in a circle. One man was designated as number one, and proceeding clockwise they killed every seventh man.</p></blockquote><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">pythonds.basic</span> <span class="kn">import</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">hotPotato</span><span class="p">(</span><span class="n">namelist</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
    <span class="n">simqueue</span> <span class="o">=</span> <span class="nc">Queue</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">namelist</span><span class="p">:</span>
        <span class="n">simqueue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">simqueue</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="n">simqueue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="n">simqueue</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">())</span>
        <span class="n">simqueue</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">simqueue</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">hotPotato</span><span class="p">([</span><span class="s">"Bill"</span><span class="p">,</span><span class="s">"David"</span><span class="p">,</span><span class="s">"Susan"</span><span class="p">,</span><span class="s">"Jane"</span><span class="p">,</span><span class="s">"Kent"</span><span class="p">,</span><span class="s">"Brad"</span><span class="p">],</span><span class="mi">7</span><span class="p">))</span>
</pre></table></code></div></div><ul><li>a group of n children<li><p>If the leader always uses the strategy of ringing the bell so that every kth person is removed from the circle, for some fixed value k, then determining the winner for a given list of children is known as the Josephus problem</p><li>solve the Josephus problem for a collection of n elements using a <strong>circular queue</strong><ul><li>associating the potato with the element at the front of the queue and storing elements in the queue according to their order around the circle.<li>passing the potato is equivalent to rotating the first element to the back of the queue.<li>After this process has been performed k − 1 times, we remove the front element by dequeuing it from the queue and discarding it.<li>a solution that runs in O(n*k) time.</ul></ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Josephus</span> <span class="o">{</span>

    <span class="c1">// /∗∗ Computes the winner of the Josephus problem using a circular queue. ∗/</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="no">E</span> <span class="nf">Josephus</span> <span class="o">(</span><span class="nc">CircularQueue</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()&gt;</span><span class="mi">2</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">queue</span><span class="o">.</span><span class="na">rotate</span><span class="o">();</span>
            <span class="no">E</span> <span class="n">e</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span> <span class="o">+</span> <span class="n">e</span> <span class="o">+</span> <span class="s">" is out"</span><span class="o">);</span>
            <span class="n">k</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nc">CircularQueue</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">buildQueue</span><span class="o">(</span><span class="no">E</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">CircularQueue</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedCircularQueue</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="no">E</span> <span class="nl">data:</span> <span class="n">a</span><span class="o">)</span> <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">queue</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[</span> <span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">a1</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Alice"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"Cindy"</span><span class="o">,</span> <span class="s">"Doug"</span><span class="o">,</span> <span class="s">"Ed"</span><span class="o">,</span> <span class="s">"Fred"</span><span class="o">};</span>
        <span class="c1">// String[] a1 = {"Alice", "Bob", "Cindy", "Ed", "Fred"};</span>
        <span class="c1">// String[] a1 = {"Bob", "Cindy", "Ed", "Fred"};</span>
        <span class="c1">// String[] a1 = {"Bob", "Ed", "Fred"};</span>
        <span class="c1">// String[] a1 = {"Fred"};</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">a2</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Gene"</span><span class="o">,</span> <span class="s">"Hope"</span><span class="o">,</span> <span class="s">"Irene"</span><span class="o">,</span> <span class="s">"Jack"</span><span class="o">,</span> <span class="s">"Kim"</span><span class="o">,</span> <span class="s">"Lance"</span><span class="o">};</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">a3</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Mike"</span><span class="o">,</span> <span class="s">"Roberto"</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"First winner is "</span> <span class="o">+</span> <span class="nc">Josephus</span><span class="o">(</span><span class="n">buildQueue</span><span class="o">(</span><span class="n">a1</span><span class="o">),</span> <span class="mi">3</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Second winner is "</span> <span class="o">+</span> <span class="nc">Josephus</span><span class="o">(</span><span class="n">buildQueue</span><span class="o">(</span><span class="n">a2</span><span class="o">),</span> <span class="mi">10</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Third winner is "</span> <span class="o">+</span> <span class="nc">Josephus</span><span class="o">(</span><span class="n">buildQueue</span><span class="o">(</span><span class="n">a3</span><span class="o">),</span> <span class="mi">7</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h1 id="-tree">🔒🔒 Tree</h1><hr /><h1 id="-二叉树">🔒🔒 二叉树</h1><p>树的问题就永远逃不开树的递归遍历框架这几行代码：</p><ul><li>二叉树题目的一个难点就是，如何把<code class="language-plaintext highlighter-rouge">题目的要求</code>细化成<code class="language-plaintext highlighter-rouge">每个节点需要做的事情</code>。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cm">/* 二叉树遍历框架 */</span>
<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 前序遍历</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span>
    <span class="c1">// 中序遍历</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">)</span>
    <span class="c1">// 后序遍历</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="计算一棵二叉树共有几个节点">计算一棵二叉树共有几个节点</h3><p><a href="https://leetcode.com/problems/count-complete-tree-nodes/">222. Count Complete Tree Nodes</a></p><ul><li>Given the root of a complete binary tree, return the number of the nodes in the tree.<li>According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.<li>Design an algorithm that runs in less than O(n) time complexity.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Count Complete Tree Nodes.</span>
<span class="c1">// Memory Usage: 41.7 MB, less than 66.40% of Java online submissions for Count Complete Tree Nodes.</span>

<span class="c1">// 定义：count(root) 返回以 root 为根的树有多少节点</span>
<span class="c1">// 时间复杂度 O(N)：</span>
<span class="kt">int</span> <span class="nf">count</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// 自己加上子树的节点数就是整棵树的节点数</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">count</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 一棵满二叉树，节点总数就和树的高度呈指数关系：</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">countNodes</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// 计算树的高度</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="n">h</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="c1">// 节点总数就是 2^h - 1</span>
    <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">h</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 完全二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，</span>
<span class="c1">// 计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版，先看代码：</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">countNodes</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">TreeNode</span> <span class="n">l</span> <span class="o">=</span> <span class="n">root</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="c1">// 记录左、右子树的高度</span>
    <span class="kt">int</span> <span class="n">hl</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">hr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">l</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="n">hl</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">r</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="n">hr</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="c1">// 如果左右子树的高度相同，则是一棵满二叉树</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">hl</span> <span class="o">==</span> <span class="n">hr</span><span class="o">)</span> <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">hl</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="c1">// 如果左右高度不同，则按照普通二叉树的逻辑计算</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">countNodes</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">countNodes</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="翻转二叉树">翻转二叉树</h3><p><a href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a></p><ul><li>Given the root of a binary tree, invert the tree, and return its root.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Invert Binary Tree.</span>
<span class="c1">// Memory Usage: 36.7 MB, less than 57.60% of Java online submissions for Invert Binary Tree.</span>
<span class="c1">// 将整棵树的节点翻转</span>
<span class="nc">TreeNode</span> <span class="nf">invertTree</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="cm">/**** 前序遍历位置 ****/</span>
    <span class="c1">// root 节点需要交换它的左右子节点</span>
    <span class="nc">TreeNode</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
    <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
    <span class="c1">// 让左右子节点继续翻转它们的子节点</span>
    <span class="n">invertTree</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="n">invertTree</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="填充二叉树节点的右侧指针">填充二叉树节点的右侧指针</h3><p><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">116. Populating Next Right Pointers in Each Node</a></p><ul><li><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">struct</span> <span class="nc">Node</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
  <span class="nc">Node</span> <span class="o">*</span><span class="n">left</span><span class="o">;</span>
  <span class="nc">Node</span> <span class="o">*</span><span class="n">right</span><span class="o">;</span>
  <span class="nc">Node</span> <span class="o">*</span><span class="n">next</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><li>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.<li>Initially, all next pointers are set to NULL.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/35aMwHI.png" alt="116_sample" /></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 52.34% of Java online submissions for Populating Next Right Pointers in Each Node.</span>
<span class="c1">// Memory Usage: 39.3 MB, less than 69.08% of Java online submissions for Populating Next Right Pointers in Each Node.</span>
<span class="c1">// 主函数</span>
<span class="nc">Node</span> <span class="nf">connect</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">connectTwoNode</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 辅助函数</span>
<span class="kt">void</span> <span class="nf">connectTwoNode</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node1</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">node2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">node2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
    <span class="cm">/**** 前序遍历位置 ****/</span>
    <span class="c1">// 将传入的两个节点连接</span>
    <span class="n">node1</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node2</span><span class="o">;</span>
    <span class="c1">// 连接相同父节点的两个子节点</span>
    <span class="n">connectTwoNode</span><span class="o">(</span><span class="n">node1</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">node1</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="n">connectTwoNode</span><span class="o">(</span><span class="n">node2</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">node2</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="c1">// 连接跨越父节点的两个子节点</span>
    <span class="n">connectTwoNode</span><span class="o">(</span><span class="n">node1</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">node2</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="将二叉树展开为链表">将二叉树展开为链表</h3><p><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">114. Flatten Binary Tree to Linked List</a></p><ul><li>Given the root of a binary tree, flatten the tree into a “linked list”:<li>The “linked list” should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.<li>The “linked list” should be in the same order as a pre-order traversal of the binary tree.<li>Input: root = [1,2,5,3,4,null,6]<li>Output: [1,null,2,null,3,null,4,null,5,null,6]</ul><p>尝试给出这个函数的定义：</p><ul><li>给 flatten 函数输入一个节点 root，那么以 root 为根的二叉树就会被拉平为一条链表。<li>1、将 root 的左子树和右子树拉平。<li>2、将 root 的右子树接到左子树下方，然后将整个左子树作为右子树。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Flatten Binary Tree to Linked List.</span>
<span class="c1">// Memory Usage: 38.5 MB, less than 70.26% of Java online submissions for Flatten Binary Tree to Linked List.</span>
<span class="c1">// 定义：将以 root 为根的树拉平为链表</span>
<span class="kt">void</span> <span class="nf">flatten</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
    <span class="n">flatten</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="n">flatten</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>

    <span class="cm">/**** 后序遍历位置 ****/</span>
    <span class="c1">// 1、左右子树已经被拉平成一条链表</span>
    <span class="c1">// 2、将左子树作为右子树</span>
    <span class="nc">TreeNode</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
    <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">// 3、将原先的右子树接到当前右子树的末端</span>
    <span class="nc">TreeNode</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">p</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="构造最大二叉树">构造最大二叉树</h3><p><a href="https://leetcode.com/problems/maximum-binary-tree/">654. Maximum Binary Tree</a></p><ul><li>You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:<li>Create a root node whose value is the maximum value in nums.<li>Recursively build the left subtree on the subarray prefix to the left of the maximum value.<li>Recursively build the right subtree on the subarray suffix to the right of the maximum value.<li><p>Return the maximum binary tree built from nums.</p><li>先明确根节点做什么？对于构造二叉树的问题，根节点要做的就是把想办法把自己构造出来。<li>肯定要遍历数组把找到最大值 maxVal，把根节点 root 做出来，<li>然后对 maxVal 左边的数组和右边的数组进行递归调用，作为 root 的左右子树。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 90.01% of Java online submissions for Maximum Binary Tree.</span>
<span class="c1">// Memory Usage: 39.1 MB, less than 82.91% of Java online submissions for Maximum Binary Tree.</span>

<span class="cm">/* 主函数 */</span>
<span class="nc">TreeNode</span> <span class="nf">constructMaximumBinaryTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">build</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
<span class="cm">/* 将 nums[lo..hi] 构造成符合条件的树，返回根节点 */</span>
<span class="nc">TreeNode</span> <span class="nf">build</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// base case</span>
    <span class="k">if</span><span class="o">(</span><span class="n">lo</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">// 找到数组中的最大值和对应的索引</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">index</span><span class="o">]);</span>
    <span class="c1">// 递归调用构造左右子树</span>
    <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">build</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">build</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="通过前序和中序后序和中序遍历结果构造二叉树kong">通过前序和中序/后序和中序遍历结果构造二叉树(kong)</h3><p>105.从前序与中序遍历序列构造二叉树（中等）</p><p>106.从中序与后序遍历序列构造二叉树（中等）</p><hr /><h3 id="寻找重复子树kong">寻找重复子树(kong)</h3><p>652 题「寻找重复子树」</p><hr /><h2 id="-层序遍历框架-bst-with-hashset">🔒🔒 层序遍历框架 BST with Hash/Set</h2><h3 id="bfs广度优先搜索用queue和qsize去遍历child--not-visited">BFS（广度优先搜索）用Queue和q.size去遍历child + not visited</h3><p>BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多</p><p>BFS 的核心数据结构；</p><ul><li>cur.adj() 泛指 cur 相邻的节点，比如说二维数组中，cur 上下左右四面的位置就是相邻节点；<li>visited 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 visited。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// 输入起点，进行 BFS 搜索</span>
<span class="kt">int</span> <span class="nf">BFS</span><span class="o">(</span><span class="nc">Node</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">;</span>     <span class="c1">// 核心数据结构</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">visited</span><span class="o">;</span> <span class="c1">// 避免走回头路</span>

    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>    <span class="c1">// 将起点加入队列</span>
    <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 记录搜索的步数</span>

    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="cm">/* 将当前队列中的所有节点向四周扩散一步 */</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="cm">/* 将 cur 的相邻节点加入队列 */</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span> <span class="n">x</span> <span class="o">:</span> <span class="n">cur</span><span class="o">.</span><span class="na">adj</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="n">not</span> <span class="n">in</span> <span class="n">visited</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                    <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">step</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="111-minimum-depth-of-binary-tree-二叉树min层级遍历">111. Minimum Depth of Binary Tree 二叉树min层级遍历</h3><p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">111. Minimum Depth of Binary Tree</a></p><ul><li>Given a binary tree, find its minimum depth.<li>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.<li>Note: A leaf is a node with no children.</ul><h4 id="-用queue和qsize去遍历左右">+++++ 用Queue和q.size去遍历左右</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Minimum Depth of Binary Tree.</span>
<span class="c1">// Memory Usage: 59.3 MB, less than 87.89% of Java online submissions for Minimum Depth of Binary Tree.</span>
<span class="kt">int</span> <span class="nf">minDepth</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="cm">/* 将当前队列中的所有节点向四周扩散 */</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="cm">/* 判断是否到达终点 */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="cm">/* 将 cur 的相邻节点加入队列 */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="cm">/* 这里增加步数 */</span>
        <span class="n">depth</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">depth</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="653-two-sum-iv---input-is-a-bst-easy">653. Two Sum IV - Input is a BST (Easy)</h3><p><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/">653. Two Sum IV - Input is a BST (Easy)</a> Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.</p><p>Example 1: Input: root = [5,3,6,2,4,null,7], k = 9 Output: true</p><h4 id="-recurse-solution-hashset">+++++ recurse solution HashSet</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 98.42% of Java online submissions for Two Sum IV - Input is a BST.</span>
<span class="c1">// Memory Usage: 40.1 MB, less than 69.32% of Java online submissions for Two Sum IV - Input is a BST.</span>

<span class="c1">// o(n) time as we are traversing every node in worst case.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">findTarget</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">findTarget</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span><span class="n">k</span><span class="o">)</span> <span class="o">||</span> <span class="n">findTarget</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span><span class="n">k</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-iterative-每个都放到queue里">+++++ iterative 每个都放到queue里</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 6 ms, faster than 43.30% of Java online submissions for Two Sum IV - Input is a BST.</span>
<span class="c1">// Memory Usage: 48.9 MB, less than 36.20% of Java online submissions for Two Sum IV - Input is a BST.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">findTarget</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="n">cur</span><span class="o">.</span><span class="na">val</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">else</span> <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="104-maximum-depth-of-binary-tree-二叉树max层级遍历">104. Maximum Depth of Binary Tree 二叉树max层级遍历</h3><h4 id="-用queue和qsize去遍历左右-1">+++++ 用Queue和q.size去遍历左右</h4><p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></p><ul><li>Given the root of a binary tree, return its maximum depth.<li>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// 输入一棵二叉树的根节点，层序遍历这棵二叉树</span>
<span class="kt">void</span> <span class="nf">levelTraverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// 从上到下遍历二叉树的每一层</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="c1">// 从左到右遍历每一层的每个节点</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="c1">// 将下一层节点放入队列</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">depth</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">State</span> <span class="o">{</span>
    <span class="c1">// 记录 node 节点的深度</span>
    <span class="kt">int</span> <span class="n">depth</span><span class="o">;</span>
    <span class="nc">TreeNode</span> <span class="n">node</span><span class="o">;</span>
    <span class="nc">State</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">depth</span> <span class="o">=</span> <span class="n">depth</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 输入一棵二叉树的根节点，遍历这棵二叉树所有节点</span>
<span class="kt">void</span> <span class="nf">levelTraverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">State</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>

    <span class="c1">// 遍历二叉树的每一个节点</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">State</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="nc">TreeNode</span> <span class="n">cur_node</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">node</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cur_depth</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">depth</span><span class="o">;</span>
        <span class="c1">// 将子节点放入队列</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cur_node</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="n">cur_node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">cur_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cur_node</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="n">cur_node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">cur_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="559-maximum-depth-of-n-ary-tree-多叉树的层序遍历框架">559. Maximum Depth of N-ary Tree 多叉树的层序遍历框架</h3><h4 id="-用queue和qsize去遍历child">+++++ 用Queue和q.size去遍历child</h4><p><a href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/">559. Maximum Depth of N-ary Tree</a></p><ul><li>Given a n-ary tree, find its maximum depth.<li>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.<li>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 55.15% of Java online submissions for Maximum Depth of N-ary Tree.</span>
<span class="c1">// Memory Usage: 39.3 MB, less than 55.15% of Java online submissions for Maximum Depth of N-ary Tree.</span>
<span class="c1">// 输入一棵多叉树的根节点，层序遍历这棵多叉树</span>
<span class="kt">void</span> <span class="nf">levelTraverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// 从上到下遍历多叉树的每一层</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="c1">// 从左到右遍历每一层的每个节点</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">TreeNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="c1">// 将下一层节点放入队列</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span> <span class="n">child</span> <span class="o">:</span> <span class="n">cur</span><span class="o">.</span><span class="na">children</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">depth</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><hr /><h3 id="穷举所有可能的密码组合-用queue和qsize去遍历all">穷举所有可能的密码组合 用Queue和q.size去遍历all</h3><p>如果你只转一下锁，有几种可能？总共有 4 个位置，每个位置可以向上转，也可以向下转，也就是有 8 种可能对吧。</p><p>比如说从 “0000” 开始，转一次，可以穷举出 “1000”, “9000”, “0100”, “0900”… 共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转一下，穷举出所有可能…</p><p>仔细想想，这就可以抽象成一幅图，每个节点有 8 个相邻的节点，又让你求最短距离，这不就是典型的 BFS 嘛，框架就可以派上用场了，先写出一个「简陋」的 BFS 框架代码再说别的：</p><p>1、会走回头路。比如说我们从 “0000” 拨到 “1000”，但是等从队列拿出 “1000” 时，还会拨出一个 “0000”，这样的话会产生死循环。</p><p>2、没有终止条件，按照题目要求，我们找到 target 就应该结束并返回拨动的次数。</p><p>3、没有对 deadends 的处理，按道理这些「死亡密码」是不能出现的，也就是说你遇到这些密码的时候需要跳过。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="c1">// 将 s[j] 向上拨动一次</span>
<span class="nc">String</span> <span class="nf">plusOne</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'9'</span><span class="o">)</span> <span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'0'</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 将 s[i] 向下拨动一次</span>
<span class="nc">String</span> <span class="nf">minusOne</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span> <span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'9'</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// BFS 框架，打印出所有可能的密码</span>
<span class="kt">void</span> <span class="nf">BFS</span><span class="o">(</span><span class="nc">String</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"0000"</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="cm">/* 将当前队列中的所有节点向周围扩散 */</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="cm">/* 判断是否到达终点 */</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
            <span class="cm">/* 将一个节点的相邻节点加入队列 */</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">up</span> <span class="o">=</span> <span class="n">plusOne</span><span class="o">(</span><span class="n">cur</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
                <span class="nc">String</span> <span class="n">down</span> <span class="o">=</span> <span class="n">minusOne</span><span class="o">(</span><span class="n">cur</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
                <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">up</span><span class="o">);</span>
                <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">down</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="cm">/* 在这里增加步数 */</span>
    <span class="o">}</span>
    <span class="k">return</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="二叉搜索树-bst">二叉搜索树 BST</h2><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">BST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span>
        <span class="c1">// 找到目标，做点什么</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="no">BST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="no">BST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="判断-bst-的合法性">判断 BST 的合法性</h3><p><a href="https://leetcode.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></p><ul><li>Given the root of a binary tree, determine if it is a valid binary search tree (BST).<li>A valid BST is defined as follows:<li>The left subtree of a node contains only nodes with keys less than the node’s key.<li>The right subtree of a node contains only nodes with keys greater than the node’s key.<li>Both the left and right subtrees must also be binary search trees.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Validate Binary Search Tree.</span>
<span class="c1">// Memory Usage: 38.4 MB, less than 92.75% of Java online submissions for Validate Binary Search Tree.</span>

<span class="kt">boolean</span> <span class="nf">isValidBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">checkBST</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/* 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val */</span>
<span class="kt">boolean</span> <span class="nf">checkBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">min</span><span class="o">,</span> <span class="nc">TreeNode</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="c1">// 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">min</span><span class="o">!=</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">&lt;=</span><span class="n">min</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">max</span><span class="o">!=</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">&gt;=</span><span class="n">max</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="c1">// 限定左子树的最大值是 root.val，右子树的最小值是 root.val</span>
    <span class="k">return</span> <span class="nf">checkBST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">min</span><span class="o">,</span> <span class="n">root</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">checkBST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">root</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="在-bst-中搜索元素">在 BST 中搜索元素</h3><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">// 穷举了所有节点，适用于所有普通二叉树</span>
<span class="nc">TreeNode</span> <span class="nf">searchBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="c1">// 当前节点没找到就递归地去左右子树寻找</span>
    <span class="nc">TreeNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">searchBST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
    <span class="nc">TreeNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">searchBST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span><span class="o">;</span>
<span class="o">}</span>

<span class="nc">TreeNode</span> <span class="nf">searchBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">// 去左子树搜索</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="n">searchBST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
    <span class="c1">// 去右子树搜索</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="n">searchBST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="在-bst-中插入一个数">在 BST 中插入一个数</h3><p><a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/">701. Insert into a Binary Search Tree</a></p><ul><li>You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.<li>Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Insert into a Binary Search Tree.</span>
<span class="c1">// Memory Usage: 39.7 MB, less than 66.92% of Java online submissions for Insert into a Binary Search Tree.</span>
<span class="nc">TreeNode</span> <span class="nf">insertIntoBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 找到空位置插入新节点</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
    <span class="c1">// if (root.val == val)</span>
    <span class="c1">//     BST 中一般不会插入已存在元素</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">val</span><span class="o">)</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">insertIntoBST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">val</span><span class="o">)</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">insertIntoBST</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="在-bst-中删除一个数">在 BST 中删除一个数</h3><p><a href="https://leetcode.com/problems/delete-node-in-a-bst/">450. Delete Node in a BST</a></p><ul><li>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.<li>Basically, the deletion can be divided into two stages:<li>Search for a node to remove.<li>If the node is found, delete the node.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Delete Node in a BST.</span>
<span class="c1">// Memory Usage: 39 MB, less than 97.99% of Java online submissions for Delete Node in a BST.</span>
<span class="nc">TreeNode</span> <span class="nf">deleteNode</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 这两个 if 把情况 1 和 2 都正确处理了</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="c1">// 处理情况 3</span>
        <span class="c1">// 找到右子树的最小节点</span>
        <span class="nc">TreeNode</span> <span class="n">minNode</span> <span class="o">=</span> <span class="n">getMin</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="c1">// 把 root 改成 minNode</span>
        <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">minNode</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="c1">// 转而去删除 minNode</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">minNode</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">key</span><span class="o">)</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">)</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deleteNode</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
<span class="o">}</span>

<span class="nc">TreeNode</span> <span class="nf">getMin</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// BST 最左边的就是最小的</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="不同的二叉搜索树---穷举问题">不同的二叉搜索树 - 穷举问题</h3><p><a href="https://leetcode.com/problems/unique-binary-search-trees/">96. Unique Binary Search Trees</a></p><ul><li>Given an integer n, return the number of structurally unique BST’s (binary search trees) which has exactly n nodes of unique values from 1 to n.<li>给你输入一个正整数 n，存储 <code class="language-plaintext highlighter-rouge">{1,2,3...,n}</code> 这些值共有有多少种不同的 BST 结构。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// Runtime Error</span>
<span class="c1">// /* 主函数 */</span>
<span class="c1">// int numTrees(int n) {</span>
<span class="c1">//     // 计算闭区间 [1, n] 组成的 BST 个数</span>
<span class="c1">//     return count(1, n);</span>
<span class="c1">// }</span>

<span class="c1">// /* 计算闭区间 [lo, hi] 组成的 BST 个数 */</span>
<span class="c1">// int count(int lo, int hi) {</span>
<span class="c1">//     // base case</span>
<span class="c1">//     if (lo &gt; hi) return 1;</span>
<span class="c1">//     int res = 0;</span>
<span class="c1">//     for (int i = lo; i &lt;= hi; i++) {</span>
<span class="c1">//         // i 的值作为根节点 root</span>
<span class="c1">//         int left = count(lo, i - 1);</span>
<span class="c1">//         int right = count(i + 1, hi);</span>
<span class="c1">//         // 左右子树的组合数乘积是 BST 的总数</span>
<span class="c1">//         res += left * right;</span>
<span class="c1">//     }</span>
<span class="c1">//     return res;</span>
<span class="c1">// }</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Binary Search Trees.</span>
<span class="c1">// Memory Usage: 35.3 MB, less than 99.03% of Java online submissions for Unique Binary Search Trees.</span>

<span class="c1">// 备忘录</span>
<span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span><span class="o">;</span>

<span class="kt">int</span> <span class="nf">numTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 备忘录的值初始化为 0</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="k">return</span> <span class="nf">count</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="nf">count</span><span class="o">(</span><span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="c1">// 查备忘录</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">lo</span><span class="o">][</span><span class="n">hi</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">lo</span><span class="o">][</span><span class="n">hi</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">mid</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">mid</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">count</span><span class="o">(</span><span class="n">lo</span><span class="o">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">count</span><span class="o">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">left</span> <span class="o">*</span> <span class="n">right</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 将结果存入备忘录</span>
    <span class="n">memo</span><span class="o">[</span><span class="n">lo</span><span class="o">][</span><span class="n">hi</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="不同的二叉搜索树ii">不同的二叉搜索树II</h3><p>95.不同的二叉搜索树II（Medium）</p><ul><li>不止计算有几个不同的 BST，而是要你构建出所有合法的 BST</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="cm">/* 主函数 */</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="nf">generateTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 构造闭区间 [1, n] 组成的 BST</span>
    <span class="k">return</span> <span class="nf">build</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/* 构造闭区间 [lo, hi] 组成的 BST */</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="nf">build</span><span class="o">(</span><span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 1、穷举 root 节点的所有可能。</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">// 2、递归构造出左右子树的所有合法 BST。</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">leftTree</span> <span class="o">=</span> <span class="n">build</span><span class="o">(</span><span class="n">lo</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">rightTree</span> <span class="o">=</span> <span class="n">build</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
        <span class="c1">// 3、给 root 节点穷举所有左右子树的组合。</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span> <span class="n">left</span> <span class="o">:</span> <span class="n">leftTree</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span> <span class="n">right</span> <span class="o">:</span> <span class="n">rightTree</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// i 作为根节点 root 的值</span>
                <span class="nc">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
                <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="二叉树后序遍历">二叉树后序遍历</h3><p>后序遍历的代码框架：</p><ul><li>如果当前节点要做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="cm">/* 后序遍历代码的位置 */</span>
    <span class="cm">/* 在这里处理当前节点 */</span>
<span class="o">}</span>
</pre></table></code></div></div><p><a href="https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/">1373. Maximum Sum BST in Binary Tree</a></p><ul><li>Given a binary tree root, return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree (BST).<li>Assume a BST is defined as follows:<li>The left subtree of a node contains only nodes with keys less than the node’s key.<li>The right subtree of a node contains only nodes with keys greater than the node’s key.<li>Both the left and right subtrees must also be binary search trees.<li>1、我肯定得知道左右子树是不是合法的 BST，如果这俩儿子有一个不是 BST，以我为根的这棵树肯定不会是 BST，对吧。<li>2、如果左右子树都是合法的 BST，我得瞅瞅左右子树加上自己还是不是合法的 BST 了。因为按照 BST 的定义，当前节点的值应该大于左子树的最大值，小于右子树的最小值，否则就破坏了 BST 的性质。<li>3、因为题目要计算最大的节点之和，如果左右子树加上我自己还是一棵合法的 BST，也就是说以我为根的整棵树是一棵 BST，那我需要知道我们这棵 BST 的所有节点值之和是多少，方便和别的 BST 争个高下，对吧。</ul><p>根据以上三点，站在当前节点的视角，需要知道以下具体信息：</p><ul><li>1、左右子树是否是 BST。<li>2、左子树的最大值和右子树的最小值。<li>3、左右子树的节点值之和。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="c1">// 全局变量，记录 BST 最大节点之和</span>
<span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="cm">/* 主函数 */</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxSumBST</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">maxSum</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 函数返回 int[]{ isBST, min, max, sum}</span>
<span class="kt">int</span><span class="o">[]</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="c1">// 递归计算左右子树</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>

    <span class="cm">/******* 后序遍历位置 *******/</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">4</span><span class="o">];</span>
    <span class="c1">// 这个 if 在判断以 root 为根的二叉树是不是 BST</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">left</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
        <span class="c1">// 以 root 为根的二叉树是 BST</span>
        <span class="n">res</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// 计算以 root 为根的这棵 BST 的最小值</span>
        <span class="n">res</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="c1">// 计算以 root 为根的这棵 BST 的最大值</span>
        <span class="n">res</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">right</span><span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="c1">// 计算以 root 为根的这棵 BST 所有节点之和</span>
        <span class="n">res</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="n">left</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">+</span> <span class="n">right</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">+</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="c1">// 更新全局变量</span>
        <span class="n">maxSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxSum</span><span class="o">,</span> <span class="n">res</span><span class="o">[</span><span class="mi">3</span><span class="o">]);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// 以 root 为根的二叉树不是 BST</span>
        <span class="n">res</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// 其他的值都没必要计算了，因为用不到</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="二叉树的序列化与反序列化">二叉树的序列化与反序列化</h3><p>二叉树的遍历方式有哪些？递归遍历方式有</p><ul><li>前序遍历，中序遍历，后序遍历；<li>迭代方式一般是层级遍历。</ul><p><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">297. Serialize and Deserialize Binary Tree</a></p><ul><li>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.<li>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.<li>Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Codec</span> <span class="o">{</span>
    <span class="c1">// 把一棵二叉树序列化成字符串</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">serialize</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{}</span>
    <span class="c1">// 把字符串反序列化成二叉树</span>
    <span class="kd">public</span> <span class="nc">TreeNode</span> <span class="nf">deserialize</span><span class="o">(</span><span class="nc">String</span> <span class="n">data</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">;</span>
<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 暂且用数字 -1 代表空指针 null</span>
        <span class="n">res</span><span class="o">.</span><span class="na">addLast</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="cm">/****** 前序遍历位置 ******/</span>
    <span class="n">res</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
    <span class="cm">/***********************/</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="二叉树打平到一个字符串">二叉树打平到一个字符串</h3><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="no">SEP</span> <span class="o">=</span> <span class="sc">','</span><span class="o">;</span>
<span class="nc">String</span> <span class="no">NULL</span> <span class="o">=</span> <span class="sc">'#'</span><span class="o">;</span>

<span class="cm">/* 主函数，将二叉树序列化为字符串 */</span>
<span class="nc">String</span> <span class="nf">serialize</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="n">serialize</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">sb</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
<span class="kt">void</span> <span class="nf">serialize</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="nc">Null</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="no">SEP</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="no">SEP</span><span class="o">);</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">sb</span><span class="o">);</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">sb</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h1 id="binary-heap-二叉堆">Binary Heap 二叉堆</h1><ul><li>其主要操作就两个，sink（下沉）和 swim（上浮），用以维护二叉堆的性质。<li>其主要应用有两个，<ul><li>首先是一种排序方法「堆排序」，<li>第二是一种很有用的数据结构「优先级队列」。</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/vStOOwC.png" alt="1" /></p><p>因为这棵二叉树是「完全二叉树」，所以把 arr[1] 作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// 父节点的索引</span>
<span class="kt">int</span> <span class="nf">parent</span><span class="o">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">root</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;}</span>

<span class="c1">// 左孩子的索引</span>
<span class="kt">int</span> <span class="nf">left</span><span class="o">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">root</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;}</span>

<span class="c1">// 右孩子的索引</span>
<span class="kt">int</span> <span class="nf">right</span><span class="o">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">root</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;}</span>
</pre></table></code></div></div><h2 id="最大堆和最小堆">最大堆和最小堆</h2><p>二叉堆还分为最大堆和最小堆。</p><ul><li>最大堆的性质是：每个节点都大于等于它的两个子节点。<li>最小堆的性质是：每个节点都小于等于它的子节点。</ul><p>优先级队列 数据结构</p><ul><li>插入或者删除元素的时候，元素会自动排序<li>这底层的原理就是二叉堆的操作。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxPQ</span>
    <span class="o">&lt;</span><span class="nc">Key</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Key</span><span class="o">[]</span> <span class="n">pq</span><span class="o">;</span>    <span class="c1">// 存储元素的数组</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   <span class="c1">// 当前 Priority Queue 中的元素个数</span>

    <span class="kd">public</span> <span class="nf">MaxPQ</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 索引 0 不用，所以多分配一个空间</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Key</span><span class="o">[])</span> <span class="k">new</span> <span class="nc">Comparable</span><span class="o">[</span><span class="n">cap</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="cm">/* 返回当前队列中最大元素 */</span>
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">max</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">pq</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="cm">/* 插入元素 e */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="nc">Key</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">N</span><span class="o">++;</span>
        <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
        <span class="n">swim</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/* 删除并返回当前队列中最大元素 */</span>
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">delMax</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">exch</span><span class="o">(</span><span class="n">pq</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span><span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">]);</span>
        <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="no">N</span><span class="o">--;</span>
        <span class="n">sink</span><span class="o">(</span><span class="n">pq</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="nc">Key</span> <span class="n">max</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 上浮第 k 个元素，以维护最大堆性质 */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swim</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="n">k</span><span class="o">&gt;</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">parent</span><span class="o">(</span><span class="n">k</span><span class="o">),</span><span class="n">k</span><span class="o">))</span> <span class="n">exch</span><span class="o">(</span><span class="n">parent</span><span class="o">(</span><span class="n">k</span><span class="o">),</span><span class="n">k</span><span class="o">);</span>
        <span class="n">k</span><span class="o">=</span><span class="n">parent</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/* 下沉第 k 个元素，以维护最大堆性质 */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">sink</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="n">left</span><span class="o">(</span><span class="n">k</span><span class="o">)&lt;=</span><span class="no">N</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">bigger</span> <span class="o">=</span> <span class="n">left</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">(</span><span class="n">k</span><span class="o">)&lt;=</span><span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">bigger</span><span class="o">,</span> <span class="n">right</span><span class="o">(</span><span class="n">k</span><span class="o">)))</span> <span class="n">bigger</span> <span class="o">=</span> <span class="n">right</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">less</span><span class="o">(</span><span class="n">bigger</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span> <span class="k">break</span><span class="o">;</span>
            <span class="n">exch</span><span class="o">(</span><span class="n">bigger</span><span class="o">,</span><span class="n">k</span><span class="o">);</span>
            <span class="n">k</span><span class="o">=</span><span class="n">bigger</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* 交换数组的两个元素 */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">exch</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Key</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="n">pq</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* pq[i] 是否比 pq[j] 小？ */</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">less</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">compareTo</span><span class="o">(</span><span class="n">pq</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 还有 left, right, parent 三个方法 */</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h1 id="graphy">Graphy</h1><p>邻接表</p><ul><li>把每个节点 x 的邻居都存到一个列表里，<li>然后把 x 和这个列表关联起来，<li>这样就可以通过一个节点 x 找到它的所有相邻节点。</ul><p>邻接矩阵</p><ul><li>二维布尔数组，我们权且成为 matrix<li>如果节点 x 和 y 是相连的，那么就把 matrix[x][y] 设为 true（上图中绿色的方格代表 true）。<li>如果想找节点 x 的邻居，去扫一圈 matrix[x][..] 就行了。</ul><p>有向加权图</p><ul><li>如果是邻接表，我们不仅仅存储某个节点 x 的所有邻居节点，还存储 x 到每个邻居的权重<li>如果是邻接矩阵，matrix[x][y] 不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重</ul><p>无向图</p><ul><li>所谓的「无向」，是不是等同于「双向」？<li>如果连接无向图中的节点 x 和 y，把 matrix[x][y] 和 matrix[y][x] 都变成 true 不就行了；邻接表也是类似的操作。</ul><p>图和多叉树最大的区别是，图是可能包含环的，</p><ul><li>你从图的某一个节点开始遍历，有可能走了一圈又回到这个节点。<li>所以，如果图包含环，遍历框架就要一个 visited 数组进行辅助：</ul><hr /><hr /><h2 id="图的遍历-1">图的遍历</h2><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>

<span class="cm">/* 图遍历框架 */</span>
<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">Graph</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="k">return</span><span class="o">;</span>
    <span class="c1">// 经过节点 s</span>
    <span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">neighbors</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
        <span class="n">traverse</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">neighbor</span><span class="o">);</span>
    <span class="c1">// 离开节点 s</span>
    <span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><hr /><h3 id="转换成图">转换成图</h3><p>图的两种存储形式</p><ul><li>邻接矩阵<li>和邻接表。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// 邻接表</span>
<span class="c1">// [ [1,0], [0,1] ]</span>
<span class="c1">// 节点编号分别是 0, 1, ..., numCourses-1</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="nf">buildGraph</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 图中共有 numCourses 个节点</span>
    <span class="c1">// create graph</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">graph</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">// 修完课程 from 才能修课程 to</span>
        <span class="c1">// 在图中添加一条从 from 指向 to 的有向边</span>
        <span class="n">graph</span><span class="o">[</span><span class="n">from</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">graph</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="所有可能路径">所有可能路径</h3><p>797.所有可能的路径（中等）</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="c1">// 记录所有路径</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">allPathsSourceTarget</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">path</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/* 图的遍历框架 */</span>
<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">path</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 添加节点 s 到路径</span>
    <span class="n">path</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 到达终点</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;(</span><span class="n">path</span><span class="o">));</span>
        <span class="n">path</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 递归每个相邻节点</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="o">{</span>
        <span class="n">traverse</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">path</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 从路径移出节点 s</span>
    <span class="n">path</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 7 ms, faster than 26.00% of Java online submissions for All Paths From Source to Target.</span>
<span class="c1">// Memory Usage: 41.5 MB, less than 47.72% of Java online submissions for All Paths From Source to Target.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">allPathsSourceTarget</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// if null, return null</span>
        <span class="k">if</span><span class="o">(</span><span class="n">graph</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">graph</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// start</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">bfscheckPath</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bfscheckPath</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// start the que</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">que</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
        <span class="n">que</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">start</span><span class="o">));</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">que</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="c1">// start the path</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="n">que</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="c1">// path last node</span>
            <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">graph</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">path</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">end</span><span class="o">])</span> <span class="o">{</span>
                <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">path</span><span class="o">);</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="n">que</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="判断有向图是否存在环">判断有向图是否存在环</h3><p>有向图的环检测、拓扑排序算法。</p><p>看到依赖问题，首先想到的就是把问题转化成「有向图」这种数据结构</p><ul><li>只要图中存在环，那就说明存在循环依赖。</ul><p><a href="https://leetcode.com/problems/course-schedule/">207 题「课程表」207. Course Schedule</a></p><ul><li>只要会遍历，就可以判断图中是否存在环了。<li>There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where <code class="language-plaintext highlighter-rouge">prerequisites[i] = [ai, bi]</code> indicates that you must take course bi first if you want to take course ai.<li>For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return true if you can finish all courses. Otherwise, return false.</ul><p>DFS 算法遍历图的框架</p><ul><li>无非就是从多叉树遍历框架扩展出来的，加了个 visited 数组罢了：</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 99.48% of Java online submissions for Course Schedule.</span>
<span class="c1">// Memory Usage: 40.3 MB, less than 46.35% of Java online submissions for Course Schedule.</span>

<span class="c1">// 防止重复遍历同一个节点</span>
<span class="kt">boolean</span> <span class="n">hasCycle</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="kt">boolean</span><span class="o">[]</span> <span class="n">onPath</span><span class="o">,</span> <span class="n">visited</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="nf">buildGraph</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 图中共有 numCourses 个节点</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
    <span class="c1">// create graph edge first</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">graph</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// check edge</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">// 修完课程 from 才能修课程 to</span>
        <span class="c1">// 在图中添加一条从 from 指向 to 的有向边</span>
        <span class="n">graph</span><span class="o">[</span><span class="n">from</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">graph</span><span class="o">;</span>
<span class="o">}</span>
<span class="kt">boolean</span> <span class="nf">canFinish</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">buildGraph</span><span class="o">(</span><span class="n">numCourses</span><span class="o">,</span> <span class="n">prerequisites</span><span class="o">);</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
    <span class="n">onPath</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">traverse</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">hasCycle</span><span class="o">;</span>
<span class="o">}</span>
<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 发现环！！</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">onPath</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="n">hasCycle</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="k">return</span><span class="o">;</span>
    <span class="cm">/* 前序遍历代码位置 */</span>
    <span class="c1">// 将当前节点标记为已遍历</span>
    <span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="n">onPath</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="n">traverse</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
    <span class="cm">/* 后序遍历代码位置 */</span>
    <span class="n">onPath</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="拓扑排序">拓扑排序</h3><p>拓扑排序的结果就是反转之后的后序遍历结果</p><ul><li>如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，<li>那么这幅图的拓扑排序结果就是上课顺序。<li>先判断一下题目输入的课程依赖是否成环，成环的话是无法进行拓扑排序的，复用上一道题的主函数</ul><p><a href="https://leetcode.com/problems/course-schedule-ii/">210. Course Schedule II</a></p><ul><li>There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where <code class="language-plaintext highlighter-rouge">prerequisites[i] = [ai, bi]</code> indicates that you must take course bi first if you want to take course ai.<li>For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.<li>Return the ordering of courses you should take to finish all courses.<li>If there are many valid answers, return any of them.<li>If it is impossible to finish all courses, return an empty array.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 3 ms, faster than 96.43% of Java online submissions for Course Schedule II.</span>
<span class="c1">// Memory Usage: 40.7 MB, less than 49.39% of Java online submissions for Course Schedule II.</span>

<span class="c1">// 记录后序遍历结果</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">postorder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="c1">// 记录是否存在环</span>
<span class="kt">boolean</span> <span class="n">hasCycle</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="c1">// 防止重复遍历同一个节点</span>
<span class="kt">boolean</span><span class="o">[]</span> <span class="n">onPath</span><span class="o">,</span> <span class="n">visited</span><span class="o">;</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="nf">buildGraph</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 图中共有 numCourses 个节点</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
    <span class="c1">// create graph edge first</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">graph</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// check edge</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">// 修完课程 from 才能修课程 to</span>
        <span class="c1">// 在图中添加一条从 from 指向 to 的有向边</span>
        <span class="n">graph</span><span class="o">[</span><span class="n">from</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">graph</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">// 主函数</span>
<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findOrder</span><span class="o">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">prerequisites</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">buildGraph</span><span class="o">(</span><span class="n">numCourses</span><span class="o">,</span> <span class="n">prerequisites</span><span class="o">);</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
    <span class="n">onPath</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">traverse</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="c1">// 有环图无法进行拓扑排序</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">hasCycle</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{};</span>

    <span class="c1">// 逆后序遍历结果即为拓扑排序结果</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">numCourses</span><span class="o">];</span>
    <span class="nc">Collections</span><span class="o">.</span><span class="na">reverse</span><span class="o">(</span><span class="n">postorder</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">postorder</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 发现环！！</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">onPath</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="n">hasCycle</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">]||</span> <span class="n">hasCycle</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
    <span class="cm">/* 前序遍历代码位置 */</span>
    <span class="c1">// 将当前节点标记为已遍历</span>
    <span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="n">onPath</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="c1">// 前序遍历位置</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="n">traverse</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
    <span class="c1">// 后序遍历位置</span>
    <span class="n">postorder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>

    <span class="n">onPath</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="搜索名人">搜索名人</h2><p>277.搜索名人（中等）</p><ul><li>给你 n 个人的社交关系（你知道任意两个人之间是否认识），然后请你找出这些人中的「名人」。<li>所谓「名人」有两个条件：<ul><li>、所有其他人都认识「名人」。<li>、「名人」不认识任何其他人。</ul></ul><p>把名流问题描述成算法的形式就是这样的：</p><ul><li>给你输入一个大小为 n x n 的二维数组（邻接矩阵） graph 表示一幅有 n 个节点的图，每个人都是图中的一个节点，编号为 0 到 n - 1。<li>如果 graph[i][j] == 1 代表第 i 个人认识第 j 个人，如果 graph[i][j] == 0 代表第 i 个人不认识第 j 个人。<li>有了这幅图表示人与人之间的关系，请你计算，这 n 个人中，是否存在「名人」？<li>如果存在，算法返回这个名人的编号，如果不存在，算法返回 -1。</ul><hr /><h3 id="暴力解法">暴力解法</h3><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">findCelebrity</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">cand</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">cand</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">cand</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">other</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">other</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">other</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">other</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cand</span> <span class="o">==</span> <span class="n">other</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
            <span class="c1">// 保证其他人都认识 cand，且 cand 不认识任何其他人</span>
            <span class="c1">// 否则 cand 就不可能是名人</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">knows</span><span class="o">(</span><span class="n">cand</span><span class="o">,</span> <span class="n">other</span><span class="o">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">knows</span><span class="o">(</span><span class="n">other</span><span class="o">,</span> <span class="n">cand</span><span class="o">))</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">other</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 找到名人</span>
            <span class="k">return</span> <span class="n">cand</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 没有一个人符合名人特性</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="优化解法">优化解法</h3><p>我再重复一遍所谓「名人」的定义：</p><ul><li>1、所有其他人都认识名人<li>2、名人不认识任何其他人。<li>这个定义就很有意思，它保证了人群中最多有一个名人。<li>这很好理解，如果有两个人同时是名人，那么这两条定义就自相矛盾了。<li>只要观察任意两个候选人的关系，我一定能确定其中的一个人不是名人，把他排除。</ul><p>逐一分析每种情况，看看怎么排除掉一个人。</p><ul><li>对于情况一，cand 认识 other，所以 cand 肯定不是名人，排除。因为名人不可能认识别人。<li>对于情况二，other 认识 cand，所以 other 肯定不是名人，排除。<li>对于情况三，他俩互相认识，肯定都不是名人，可以随便排除一个。<li>对于情况四，他俩互不认识，肯定都不是名人，可以随便排除一个。因为名人应该被所有其他人认识。<li>我们可以不断从候选人中选两个出来，然后排除掉一个，直到最后只剩下一个候选人，这时候再使用一个 for 循环判断这个候选人是否是货真价实的「名人」。<li>避免了嵌套 for 循环，时间复杂度降为 O(N) 了，<li>不过引入了一个队列来存储候选人集合，使用了 O(N) 的空间复杂度。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">findCelebrity</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// 将所有候选人装进队列</span>
    <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">q</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="c1">// 一直排除，直到只剩下一个候选人停止循环</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 每次取出两个候选人，排除一个</span>
        <span class="kt">int</span> <span class="n">cand</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">other</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
        <span class="c1">// cand 不可能是名人，排除，让 other 归队</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">knows</span><span class="o">(</span><span class="n">cand</span><span class="o">,</span> <span class="n">other</span><span class="o">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">knows</span><span class="o">(</span><span class="n">other</span><span class="o">,</span> <span class="n">cand</span><span class="o">))</span> <span class="n">q</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">other</span><span class="o">);</span>
        <span class="c1">// other 不可能是名人，排除，让 cand 归队</span>
        <span class="k">else</span> <span class="n">q</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">cand</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 现在排除得只剩一个候选人，判断他是否真的是名人</span>
    <span class="kt">int</span> <span class="n">cand</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">other</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">other</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">other</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">other</span> <span class="o">==</span> <span class="n">cand</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
        <span class="c1">// 保证其他人都认识 cand，且 cand 不认识任何其他人</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">knows</span><span class="o">(</span><span class="n">other</span><span class="o">,</span> <span class="n">cand</span><span class="o">)</span> <span class="o">||</span> <span class="n">knows</span><span class="o">(</span><span class="n">cand</span><span class="o">,</span> <span class="n">other</span><span class="o">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// cand 是名人</span>
    <span class="k">return</span> <span class="n">cand</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="最终解法">最终解法</h3><p>时间复杂度为 O(N)，空间复杂度为 O(1)</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">findCelebrity</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 先假设 cand 是名人</span>
    <span class="kt">int</span> <span class="n">cand</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">other</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">other</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">other</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">// if other x-&gt; cand or cand-&gt;other</span>
        <span class="c1">// cand 不可能是名人，排除</span>
        <span class="c1">// 假设 other 是名人</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">knows</span><span class="o">(</span><span class="n">other</span><span class="o">,</span> <span class="n">cand</span><span class="o">)</span> <span class="o">||</span> <span class="n">knows</span><span class="o">(</span><span class="n">cand</span><span class="o">,</span> <span class="n">other</span><span class="o">))</span> <span class="n">cand</span> <span class="o">=</span> <span class="n">other</span><span class="o">;</span>
        <span class="c1">// other 不可能是名人，排除</span>
        <span class="c1">// 什么都不用做，继续假设 cand 是名人 下一个other</span>
        <span class="k">else</span> <span class="o">{}</span>
    <span class="o">}</span>
    <span class="c1">// 现在的 cand 是排除的最后结果，但不能保证一定是名人</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">other</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">other</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">other</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cand</span> <span class="o">==</span> <span class="n">other</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
        <span class="c1">// 需要保证其他人都认识 cand，且 cand 不认识任何其他人</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">knows</span><span class="o">(</span><span class="n">other</span><span class="o">,</span> <span class="n">cand</span><span class="o">)</span> <span class="o">||</span> <span class="n">knows</span><span class="o">(</span><span class="n">cand</span><span class="o">,</span> <span class="n">other</span><span class="o">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">cand</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="union-find-并查集算法-计算-连通分量">UNION-FIND 并查集算法 计算 连通分量</h2><hr /><h3 id="union-find算法">UNION-FIND算法</h3><p>动态连通性</p><ul><li>抽象成给一幅图连线。<li>比如总共有 10 个节点，他们互不相连，分别用 0~9 标记：</ul><p>Union-Find 算法主要需要实现这两个 API：</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">UF</span> <span class="o">{</span>
    <span class="cm">/* 将 p 和 q 连接 */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">);</span>
    <span class="cm">/* 判断 p 和 q 是否连通 */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">connected</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">);</span>
    <span class="cm">/* 返回图中有多少个连通分量 */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>「连通」是一种等价关系，也就是说具有如下三个性质：</p><ul><li>1、自反性：节点 p 和 p 是连通的。<li>2、对称性：如果节点 p 和 q 连通，那么 q 和 p 也连通。<li>3、传递性：如果节点 p 和 q 连通，q 和 r 连通，那么 p 和 r 也连通。<li>比如说之前那幅图，0～9 任意两个不同的点都不连通，调用 connected 都会返回 false，连通分量为 10 个。<li>如果现在调用 union(0, 1)，那么 0 和 1 被连通，连通分量降为 9 个。<li>再调用 union(1, 2)，这时 0,1,2 都被连通，调用 connected(0, 2) 也会返回 true，连通分量变为 8 个。</ul><p>判断这种「等价关系」非常实用</p><ul><li>比如说编译器判断同一个变量的不同引用，比如社交网络中的朋友圈计算等等。<li>Union-Find 算法的关键就在于 union 和 connected 函数的效率。</ul><p>算法的关键点有 3 个：</p><ul><li>1、用 parent 数组记录每个节点的父节点，相当于指向父节点的指针，所以 parent 数组内实际存储着一个森林（若干棵多叉树）。<li>2、用 size 数组记录着每棵树的重量，目的是让 union 后树依然拥有平衡性，而不会退化成链表，影响操作效率。<li>3、在 find 函数中进行路径压缩，保证任意树的高度保持在常数，使得 union 和 connected API 时间复杂度为 O(1)。</ul><hr /><h4 id="基本思路">基本思路</h4><ul><li>设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己<li>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上：</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">UF</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>      <span class="c1">// 记录连通分量</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>   <span class="c1">// 节点 x 的节点是 parent[x]</span>

    <span class="cm">/* 构造函数，n 为图的节点总数 */</span>
    <span class="kd">public</span> <span class="nf">UF</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 一开始互不连通</span>
        <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="c1">// 父节点指针初始指向自己</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 返回某个节点 x 的根节点 */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 根节点的 parent[x] == x</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">!=</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="o">=</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 返回当前的连通分量个数 */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 其他函数 */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">rootP</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rootQ</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="c1">// 将两棵树合并为一棵</span>
        <span class="c1">// 简单粗暴的把 p 所在的树接到 q 所在的树的根节点下面</span>
        <span class="n">parent</span><span class="o">[</span><span class="n">rootP</span><span class="o">]</span> <span class="o">=</span> <span class="n">rootQ</span><span class="o">;</span>
        <span class="c1">// parent[rootQ] = rootP 也一样</span>
        <span class="n">count</span><span class="o">--;</span> <span class="c1">// 两个分量合二为一</span>
    <span class="o">}</span>

    <span class="c1">// 如果节点 p 和 q 连通的话，它们一定拥有相同的根节点</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">connected</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">rootP</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rootQ</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><p>主要 API connected 和 union 中的复杂度都是 find 函数造成的，它们的复杂度和 find 一样。</p><ul><li>find 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。<li>我们可能习惯性地认为树的高度就是 logN，但这并不一定。树的高度最坏情况下可能变成 N。</ul><p>所以说上面这种解法，find , union , connected 的时间复杂度都是 O(N)。</p><hr /><h4 id="平衡性优化">平衡性优化</h4><p>for 小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些</p><ul><li>树的高度大致在 logN 这个数量级，极大提升执行效率。<li>此时，find , union , connected 的时间复杂度都下降为 O(logN)，即便数据规模上亿，所需时间也非常少。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">UF</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>      <span class="c1">// 记录连通分量</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>   <span class="c1">// 节点 x 的节点是 parent[x]</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">size</span><span class="o">;</span>     <span class="c1">// 新增一个数组记录树的“重量”</span>

    <span class="cm">/* 构造函数，n 为图的节点总数 */</span>
    <span class="kd">public</span> <span class="nf">UF</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 一开始互不连通</span>
        <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="c1">// 父节点指针初始指向自己</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">size</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>      <span class="c1">// 记录每棵树包含的节点数</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* 返回某个节点 x 的根节点 */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 根节点的 parent[x] == x</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">!=</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 返回当前的连通分量个数 */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 其他函数 */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">rootP</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rootQ</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="c1">// 将两棵树合并为一棵</span>
        <span class="c1">// 简单粗暴的把 p 所在的树接到 q 所在的树的根节点下面</span>
        <span class="k">if</span><span class="o">(</span><span class="n">size</span><span class="o">[</span><span class="n">rootP</span><span class="o">]&gt;</span><span class="n">size</span><span class="o">[</span><span class="n">rootQ</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">rootQ</span><span class="o">]</span> <span class="o">=</span> <span class="n">rootP</span><span class="o">;</span>
            <span class="n">size</span><span class="o">[</span><span class="n">rootP</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">rootQ</span><span class="o">];</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">rootP</span><span class="o">]</span> <span class="o">=</span> <span class="n">rootQ</span><span class="o">;</span>
            <span class="n">size</span><span class="o">[</span><span class="n">rootQ</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">rootP</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">count</span><span class="o">--;</span> <span class="c1">// 两个分量合二为一</span>
    <span class="o">}</span>

    <span class="c1">// 如果节点 p 和 q 连通的话，它们一定拥有相同的根节点</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">connected</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">rootP</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rootQ</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="路径压缩">路径压缩</h4><p>进一步压缩每棵树的高度，使树高始终保持为常数</p><ul><li>这样 find 就能以 O(1) 的时间找到某一节点的根节点，<li>相应的，connected 和 union 复杂度都下降为 O(1)。<li>调用 find 函数每次向树根遍历的同时，顺手将树高缩短了，最终所有树高都不会超过 3（union 的时候树高可能达到 3）。</ul><p>Union-Find 算法的复杂度可以这样分析：</p><ul><li>构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；<li>连通两个节点 union、判断两个节点的连通性 connected、计算连通分量 count 所需的时间复杂度均为 O(1)。</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/gUVWOv6.jpg" alt="1" /></p><p>如果带有重量平衡优化，一定会得到情况一，而不带重量优化，可能出现情况二。</p><ul><li>高度为 3 时才会触发路径压缩那个 while 循环，<li>所以情况一根本不会触发路径压缩，而情况二会多执行很多次路径压缩，将第三层节点压缩到第二层。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">UF</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>      <span class="c1">// 记录连通分量</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>   <span class="c1">// 节点 x 的节点是 parent[x]</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">size</span><span class="o">;</span>     <span class="c1">// 新增一个数组记录树的“重量”</span>

    <span class="cm">/* 构造函数，n 为图的节点总数 */</span>
    <span class="kd">public</span> <span class="nf">UF</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 一开始互不连通</span>
        <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="c1">// 父节点指针初始指向自己</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">size</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">size</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>      <span class="c1">// 记录每棵树包含的节点数</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* 返回某个节点 x 的根节点 */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 根节点的 parent[x] == x</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">!=</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">parent</span><span class="o">[</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]];</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 返回当前的连通分量个数 */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 其他函数 */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">rootP</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rootQ</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="c1">// 将两棵树合并为一棵</span>
        <span class="c1">// 简单粗暴的把 p 所在的树接到 q 所在的树的根节点下面</span>
        <span class="k">if</span><span class="o">(</span><span class="n">size</span><span class="o">[</span><span class="n">rootP</span><span class="o">]&gt;</span><span class="n">size</span><span class="o">[</span><span class="n">rootQ</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">rootQ</span><span class="o">]</span> <span class="o">=</span> <span class="n">rootP</span><span class="o">;</span>
            <span class="n">size</span><span class="o">[</span><span class="n">rootP</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">rootQ</span><span class="o">];</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">rootP</span><span class="o">]</span> <span class="o">=</span> <span class="n">rootQ</span><span class="o">;</span>
            <span class="n">size</span><span class="o">[</span><span class="n">rootQ</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">rootP</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">count</span><span class="o">--;</span> <span class="c1">// 两个分量合二为一</span>
    <span class="o">}</span>

    <span class="c1">// 如果节点 p 和 q 连通的话，它们一定拥有相同的根节点</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">connected</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">rootP</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rootQ</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="union-find算法应用">UNION-FIND算法应用</h2><p>使用 Union-Find 算法，主要是如何把原问题转化成<code class="language-plaintext highlighter-rouge">图的动态连通性问题</code>。</p><ul><li>对于算式合法性问题，可以直接利用等价关系，<li>对于棋盘包围问题，则是利用一个虚拟节点，营造出动态连通特性。<li>将二维数组映射到一维数组，利用方向数组 d 来简化代码量</ul><hr /><h3 id="dfs-的替代方案">DFS 的替代方案</h3><p><a href="https://leetcode.com/problems/surrounded-regions/">130. Surrounded Regions</a></p><ul><li>Given an m x n matrix board containing ‘X’ and ‘O’, capture all regions that are 4-directionally surrounded by ‘X’.<li>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.<li>被围绕的区域：给你一个 M×N 的二维矩阵，其中包含字符 X 和 O，<li>让你找到矩阵中四面被 X 围住的 O，并且把它们替换成 X。</ul><p>传统方法</p><ul><li>先用 for 循环遍历棋盘的四边，<li>用 DFS 算法把那些与边界相连的 O 换成一个特殊字符，比如 #；<li>然后再遍历整个棋盘，把剩下的 O 换成 X，<li>把 # 恢复成 O。<li>只有和边界 O 相连的 O 才具有和 dummy 的连通性，他们不会被替换。<li>这样就能完成题目的要求，时间复杂度 O(MN)。</ul><p>将二维坐标映射到一维的常用技巧。</p><ul><li>二维坐标 (x,y) 可以转换成 x * n + y 这个数<li>（m 是棋盘的行数，n 是棋盘的列数）。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 6 ms, faster than 12.80% of Java online submissions for Surrounded Regions.</span>
<span class="c1">// Memory Usage: 41 MB, less than 73.76% of Java online submissions for Surrounded Regions.</span>
<span class="kt">void</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

    <span class="c1">// 给 dummy 留一个额外位置</span>
    <span class="no">UF</span> <span class="n">uf</span> <span class="o">=</span> <span class="k">new</span> <span class="no">UF</span><span class="o">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">dummy</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="o">;</span>

    <span class="c1">// 将首列和末列的 O 与 dummy 连通</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="o">)</span> <span class="n">uf</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">n</span><span class="o">,</span> <span class="n">dummy</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="o">)</span> <span class="n">uf</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">dummy</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 将首行和末行的 O 与 dummy 连通</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="o">)</span> <span class="n">uf</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">dummy</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="o">)</span> <span class="n">uf</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">n</span> <span class="o">*</span> <span class="o">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">j</span><span class="o">,</span> <span class="n">dummy</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 方向数组 d 是上下左右搜索的常用手法</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">},</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">});</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="o">)</span>
                <span class="c1">// 将此 O 与上下左右的 O 连通</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">d</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">d</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="o">)</span> <span class="n">uf</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">y</span><span class="o">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">j</span><span class="o">);</span>
                <span class="o">}</span>
    <span class="c1">// 所有不和 dummy 连通的 O，都要被替换</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">uf</span><span class="o">.</span><span class="na">connected</span><span class="o">(</span><span class="n">dummy</span><span class="o">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">j</span><span class="o">))</span> <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'X'</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">UF</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>      <span class="c1">// 记录连通分量</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>   <span class="c1">// 节点 x 的节点是 parent[x]</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">size</span><span class="o">;</span>     <span class="c1">// 新增一个数组记录树的“重量”</span>

    <span class="cm">/* 构造函数，n 为图的节点总数 */</span>
    <span class="kd">public</span> <span class="nf">UF</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 一开始互不连通</span>
        <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="c1">// 父节点指针初始指向自己</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">size</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">size</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* 返回某个节点 x 的根节点 */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 根节点的 parent[x] == x</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">!=</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">parent</span><span class="o">[</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]];</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 返回当前的连通分量个数 */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 其他函数 */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">rootP</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rootQ</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="c1">// 将两棵树合并为一棵</span>
        <span class="c1">// 简单粗暴的把 p 所在的树接到 q 所在的树的根节点下面</span>
        <span class="k">if</span><span class="o">(</span><span class="n">size</span><span class="o">[</span><span class="n">rootP</span><span class="o">]&gt;</span><span class="n">size</span><span class="o">[</span><span class="n">rootQ</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">rootQ</span><span class="o">]</span> <span class="o">=</span> <span class="n">rootP</span><span class="o">;</span>
            <span class="n">size</span><span class="o">[</span><span class="n">rootP</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">rootQ</span><span class="o">];</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">rootP</span><span class="o">]</span> <span class="o">=</span> <span class="n">rootQ</span><span class="o">;</span>
            <span class="n">size</span><span class="o">[</span><span class="n">rootQ</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">rootP</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">count</span><span class="o">--;</span> <span class="c1">// 两个分量合二为一</span>
    <span class="o">}</span>

    <span class="c1">// 如果节点 p 和 q 连通的话，它们一定拥有相同的根节点</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">connected</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">rootP</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rootQ</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="判定合法等式">判定合法等式</h3><p><a href="https://leetcode.com/problems/satisfiability-of-equality-equations/">990. Satisfiability of Equality Equations</a></p><ul><li>You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: “xi==yi” or “xi!=yi”.Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.<li>Return true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 77.43% of Java online submissions for Satisfiability of Equality Equations.</span>
<span class="c1">// Memory Usage: 38.6 MB, less than 75.05% of Java online submissions for Satisfiability of Equality Equations.</span>

<span class="kd">class</span> <span class="nc">UF</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">size</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">UF</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">count</span><span class="o">=</span><span class="n">n</span><span class="o">;</span>
        <span class="n">parent</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">size</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
          <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">i</span><span class="o">;</span>
          <span class="n">size</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
        <span class="k">while</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]!=</span><span class="n">x</span><span class="o">){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]=</span><span class="n">parent</span><span class="o">[</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]];</span>
            <span class="n">x</span><span class="o">=</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">rootP</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rootQ</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">size</span><span class="o">[</span><span class="n">rootP</span><span class="o">]&gt;</span><span class="n">size</span><span class="o">[</span><span class="n">rootQ</span><span class="o">]){</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">rootQ</span><span class="o">]=</span><span class="n">rootP</span><span class="o">;</span>
            <span class="n">size</span><span class="o">[</span><span class="n">rootP</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">rootQ</span><span class="o">];</span>
        <span class="o">}</span> <span class="k">else</span><span class="o">{</span>
            <span class="n">parent</span><span class="o">[</span><span class="n">rootP</span><span class="o">]=</span><span class="n">rootQ</span><span class="o">;</span>
            <span class="n">size</span><span class="o">[</span><span class="n">rootQ</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">rootP</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">count</span><span class="o">--;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">connected</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">rootP</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rootQ</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Solution</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equationsPossible</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">equations</span><span class="o">){</span>
        <span class="c1">// 26 个英文字母</span>
        <span class="no">UF</span> <span class="n">uf</span><span class="o">=</span><span class="k">new</span> <span class="no">UF</span><span class="o">(</span><span class="mi">26</span><span class="o">);</span>
        <span class="c1">// 先让相等的字母形成连通分量</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">eq</span> <span class="o">:</span> <span class="n">equations</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">eq</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'='</span><span class="o">){</span>
                <span class="kt">char</span> <span class="n">x</span><span class="o">=</span><span class="n">eq</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
                <span class="kt">char</span> <span class="n">y</span><span class="o">=</span><span class="n">eq</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
                <span class="n">uf</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">,</span> <span class="n">y</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 检查不等关系是否打破相等关系的连通性</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">eq</span> <span class="o">:</span> <span class="n">equations</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">eq</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'!'</span><span class="o">){</span>
                <span class="kt">char</span> <span class="n">x</span><span class="o">=</span><span class="n">eq</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
                <span class="kt">char</span> <span class="n">y</span><span class="o">=</span><span class="n">eq</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
                <span class="c1">// 如果相等关系成立，就是逻辑冲突</span>
                <span class="k">if</span><span class="o">(</span><span class="n">uf</span><span class="o">.</span><span class="na">connected</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">,</span> <span class="n">y</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="dijkstra-算法">DIJKSTRA 算法</h2><p>「无权图」</p><ul><li>与其说每条「边」没有权重，不如说每条「边」的权重都是 1，<li>从起点 start 到任意一个节点之间的路径权重就是它们之间「边」的条数</ul><p>「加权图」</p><ul><li>不能默认每条边的「权重」都是 1 了，<li>这个权重可以是任意正数（Dijkstra 算法要求不能存在负权重边）</ul><p>DIJKSTRA</p><ul><li>输入是一幅图 graph 和一个起点 start<li>返回是一个记录最短路径权重的数组。<li>比方说，<ul><li>输入起点 start = 3，函数返回一个 int[] 数组，<li>假设赋值给 distTo 变量，那么从起点 3 到节点 6 的最短路径权重的值就是 distTo[6]。</ul><li>是的，标准的 Dijkstra 算法会把从起点 start 到所有其他节点的最短路径都算出来。<li>当然，如果你的需求只是计算从起点 start 到某一个终点 end 的最短路径，那么在标准 Dijkstra 算法上稍作修改就可以更高效地完成这个需求，这个我们后面再说。<li>其次，我们也需要一个 State 类来辅助算法的运行：</ul><p>Dijkstra 可以理解成一个带 dp table（备忘录）的 BFS 算法</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">State</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>               <span class="c1">// 图节点的 id</span>
    <span class="kt">int</span> <span class="n">distFromStart</span><span class="o">;</span>    <span class="c1">// 从 start 节点到当前节点的距离</span>
    <span class="nc">State</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="kt">int</span> <span class="n">distFromStart</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">distFromStart</span> <span class="o">=</span> <span class="n">distFromStart</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 返回节点 from 到节点 to 之间的边的权重</span>
<span class="kt">int</span> <span class="nf">weight</span><span class="o">(</span><span class="kt">int</span> <span class="n">from</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to</span><span class="o">);</span>

<span class="c1">// 输入节点 s 返回 s 的相邻节点</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">adj</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">);</span>

<span class="c1">// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离</span>
<span class="kt">int</span><span class="o">[]</span> <span class="nf">dijkstra</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="no">V</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>   <span class="c1">// 图中节点的个数</span>

    <span class="c1">// 记录最短路径的权重, dp table</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">V</span><span class="o">];</span>              <span class="c1">// distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">distTo</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span> <span class="c1">// 求最小值，所以 dp table 初始化为正无穷</span>
    <span class="n">distTo</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                      <span class="c1">// base case，start 到 start 的最短距离就是 0</span>

    <span class="c1">// 优先级队列，distFromStart 较小的排在前面</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">State</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">distFromStart</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">distFromStart</span><span class="o">;</span>
    <span class="o">});</span>

    <span class="c1">// 从起点 start 开始进行 BFS</span>
    <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">State</span> <span class="n">curState</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">curNodeID</span> <span class="o">=</span> <span class="n">curState</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">curDistFromStart</span> <span class="o">=</span> <span class="n">curState</span><span class="o">.</span><span class="na">distFromStart</span><span class="o">;</span>

        <span class="c1">// 已经有一条更短的路径到达 curNode 节点了</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">curDistFromStart</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">curNodeID</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>
        <span class="c1">// 将 curNode 的相邻节点装入队列</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">nextNodeID</span> <span class="o">:</span> <span class="n">adj</span><span class="o">(</span><span class="n">curNodeID</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 看看从 curNode 达到 nextNode 的距离是否会更短</span>
            <span class="kt">int</span> <span class="n">distToNextNode</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">curNodeID</span><span class="o">]</span> <span class="o">+</span> <span class="n">weight</span><span class="o">(</span><span class="n">curNodeID</span><span class="o">,</span> <span class="n">nextNodeID</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">nextNodeID</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distToNextNode</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 更新 dp table</span>
                <span class="n">distTo</span><span class="o">[</span><span class="n">nextNodeID</span><span class="o">]</span> <span class="o">=</span> <span class="n">distToNextNode</span><span class="o">;</span>
                <span class="c1">// 将这个节点以及距离放入队列</span>
                <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="n">nextNodeID</span><span class="o">,</span> <span class="n">distToNextNode</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">distTo</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="dijkstra-算法-起点-start-到某一个终点-end-的最短路径">DIJKSTRA 算法 起点 start 到某一个终点 end 的最短路径</h2><p>因为优先级队列自动排序的性质，每次从队列里面拿出来的都是 distFromStart 值最小的，所以当你从队头拿出一个节点，如果发现这个节点就是终点 end，那么 distFromStart 对应的值就是从 start 到 end 的最短距离。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">State</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>               <span class="c1">// 图节点的 id</span>
    <span class="kt">int</span> <span class="n">distFromStart</span><span class="o">;</span>    <span class="c1">// 从 start 节点到当前节点的距离</span>
    <span class="nc">State</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="kt">int</span> <span class="n">distFromStart</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">distFromStart</span> <span class="o">=</span> <span class="n">distFromStart</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 返回节点 from 到节点 to 之间的边的权重</span>
<span class="kt">int</span> <span class="nf">weight</span><span class="o">(</span><span class="kt">int</span> <span class="n">from</span><span class="o">,</span> <span class="kt">int</span> <span class="n">to</span><span class="o">);</span>

<span class="c1">// 输入节点 s 返回 s 的相邻节点</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">adj</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">);</span>

<span class="c1">// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离</span>
<span class="kt">int</span><span class="o">[]</span> <span class="nf">dijkstra</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="no">V</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>   <span class="c1">// 图中节点的个数</span>

    <span class="c1">// 记录最短路径的权重, dp table</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">V</span><span class="o">];</span>              <span class="c1">// distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">distTo</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span> <span class="c1">// 求最小值，所以 dp table 初始化为正无穷</span>
    <span class="n">distTo</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                      <span class="c1">// base case，start 到 start 的最短距离就是 0</span>

    <span class="c1">// 优先级队列，distFromStart 较小的排在前面</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">State</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">distFromStart</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">distFromStart</span><span class="o">;</span>
    <span class="o">});</span>

    <span class="c1">// 从起点 start 开始进行 BFS</span>
    <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">State</span> <span class="n">curState</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">curNodeID</span> <span class="o">=</span> <span class="n">curState</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">curDistFromStart</span> <span class="o">=</span> <span class="n">curState</span><span class="o">.</span><span class="na">distFromStart</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">curNodeID</span> <span class="o">==</span> <span class="n">end</span><span class="o">)</span> <span class="k">return</span> <span class="n">curDistFromStart</span><span class="o">;</span>
        <span class="c1">// 已经有一条更短的路径到达 curNode 节点了</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">curDistFromStart</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">curNodeID</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>
        <span class="c1">// 将 curNode 的相邻节点装入队列</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">nextNodeID</span> <span class="o">:</span> <span class="n">adj</span><span class="o">(</span><span class="n">curNodeID</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 看看从 curNode 达到 nextNode 的距离是否会更短</span>
            <span class="kt">int</span> <span class="n">distToNextNode</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">curNodeID</span><span class="o">]</span> <span class="o">+</span> <span class="n">weight</span><span class="o">(</span><span class="n">curNodeID</span><span class="o">,</span> <span class="n">nextNodeID</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">nextNodeID</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distToNextNode</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 更新 dp table</span>
                <span class="n">distTo</span><span class="o">[</span><span class="n">nextNodeID</span><span class="o">]</span> <span class="o">=</span> <span class="n">distToNextNode</span><span class="o">;</span>
                <span class="c1">// 将这个节点以及距离放入队列</span>
                <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="n">nextNodeID</span><span class="o">,</span> <span class="n">distToNextNode</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="网络延迟时间">网络延迟时间</h3><p><a href="https://leetcode.com/problems/network-delay-time/">743. Network Delay Time</a></p><ul><li>You are given a network of n nodes, labeled from 1 to n.<li>You are also given times, a list of travel times as directed edges <code class="language-plaintext highlighter-rouge">times[i] = (ui, vi, wi)</code>, where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.<li>We will send a signal from a given node k. Return the time it takes for all the n nodes to receive the signal.<li>If it is impossible for all the n nodes to receive the signal, return -1.</ul><p>求所有节点都收到信号的时间</p><ul><li>把所谓的传递时间看做距离，实际上就是「从节点 k 到其他所有节点的最短路径中，最长的那条最短路径距离是多少」<li>从节点 k 出发到其他所有节点的最短路径，就是标准的 Dijkstra 算法。</ul><div class="language-plaintext highlighter-rouge"><div class="code-header" text-data="plaintext"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre><td class="rouge-code"><pre>int networkDelayTime(int[][] times, int n, int k) {
    if(n==0) return -1;
    // 节点编号是从 1 开始的，所以要一个大小为 n + 1 的邻接表
    List&lt;int[]&gt;[] graph = new LinkedList[n + 1];
    for (int i = 1; i &lt;= n; i++) graph[i] = new LinkedList&lt;&gt;();

    // 构造图
    for (int[] edge : times) {
        int from = edge[0];
        int to = edge[1];
        int weight = edge[2];
        // from -&gt; List&lt;(to, weight)&gt;
        // 邻接表存储图结构，同时存储权重信息
        graph[from].add(new int[]{to, weight});
    }
    // 启动 dijkstra 算法计算以节点 k 为起点到其他节点的最短路径
    int[] distTo = dijkstra(k, graph);

    // 找到最长的那一条最短路径
    int res = 0;
    for (int i = 1; i &lt; distTo.length; i++) {
        if (distTo[i] == Integer.MAX_VALUE) return -1; // 有节点不可达，返回 -1
        res = Math.max(res, distTo[i]);
    }
    return res;
}


class State{
    int id;
    int distFromStart;
    State(int id, int distFromStart){
        this.id=id;
        this.distFromStart=distFromStart;
    }
}

// 输入一个起点 start，计算从 start 到其他节点的最短距离
int[] dijkstra(int start, List&lt;int[]&gt;[] graph) {
    // 图中节点的个数
    // 记录最短路径的权重，你可以理解为 dp table
    // 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重
    // 求最小值，所以 dp table 初始化为正无穷
    // base case，start 到 start 的最短距离就是 0
    int[] disTo = new int[graph.length];
    Arrays.fill(disTo, Integer.MAX_VALUE);
    disTo[start] = 0;

    // 优先级队列，distFromStart 较小的排在前面
    Queue&lt;State&gt; pq = new PriorityQueue&lt;&gt;(
        (a,b) -&gt; {return a.distFromStart - b.distFromStart;}
    );

    // 从起点 start 开始进行 BFS
    pq.offer(new State(start, 0));

    while(!pq.isEmpty()){
        State cur = pq.poll();

        int curId = cur.id;
        int curDistFromStart = cur.curDistFromStart;

        if(curDistFromStart &gt; disTo[curId]) continue;

        for(int[] node : graph[curId]){
            int nextNodeID = node[0];
            int nextnodeDis = disTo[curId] + node[1];
            if( nextnodeDis &lt; disTo[nextNodeID]){
                disTo[nextNodeID] = nextnodeDis;
                pq.offer(new State(nextNodeID, nextnodeDis);
            }
        }
    }
    return disTo;
}


</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre><td class="rouge-code"><pre>
<span class="kd">class</span> <span class="nc">State</span><span class="o">{</span>
    <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">distFromStart</span><span class="o">;</span>
    <span class="nc">State</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="kt">int</span> <span class="n">distFromStart</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">distFromStart</span> <span class="o">=</span> <span class="n">distFromStart</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">networkDelayTime</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">times</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">// graph</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;[]</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">graph</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">times</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
            <span class="n">graph</span><span class="o">[</span><span class="n">from</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">to</span><span class="o">,</span> <span class="n">weight</span><span class="o">});</span>
        <span class="o">}</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">disTo</span> <span class="o">=</span> <span class="n">dijkstra</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">graph</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">res</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">disTo</span><span class="o">[</span><span class="n">i</span><span class="o">]==</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="n">res</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">disTo</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">dijkstra</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;[]</span> <span class="n">graph</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">graph</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">distTo</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
        <span class="n">distTo</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">State</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span>
            <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span><span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">distFromStart</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="na">distFromStart</span><span class="o">;}</span>
        <span class="o">);</span>
        <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="n">start</span><span class="o">,</span><span class="mi">0</span><span class="o">));</span>

        <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">State</span> <span class="n">curState</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">curNodeID</span> <span class="o">=</span> <span class="n">curState</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">curDistFromStart</span> <span class="o">=</span> <span class="n">curState</span><span class="o">.</span><span class="na">distFromStart</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">curDistFromStart</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">curNodeID</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 将 curNode 的相邻节点装入队列</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">curNodeID</span><span class="o">])</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">nextNodeID</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">distToNextNode</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">curNodeID</span><span class="o">]</span> <span class="o">+</span> <span class="n">neighbor</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
                <span class="c1">// 更新 dp table</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">nextNodeID</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distToNextNode</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">distTo</span><span class="o">[</span><span class="n">nextNodeID</span><span class="o">]</span> <span class="o">=</span> <span class="n">distToNextNode</span><span class="o">;</span>
                    <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="n">nextNodeID</span><span class="o">,</span> <span class="n">distToNextNode</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">distTo</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="路径经过的权重最大值">路径经过的权重最大值</h3><p><a href="">1631. Path With Minimum Effort</a></p><ul><li>You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.<li>A routes effort is the maximum absolute difference in heights between two consecutive cells of the route.<li>Return the minimum effort required to travel from the top-left cell to the bottom-right cell.</ul><p>这道题中评判一条路径是长还是短的标准不再是路径经过的权重总和，而是路径经过的权重最大值。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 47 ms, faster than 75.18% of Java online submissions for Path With Minimum Effort.</span>
<span class="c1">// Memory Usage: 39.5 MB, less than 76.36% of Java online submissions for Path With Minimum Effort.</span>

<span class="kd">class</span> <span class="nc">State</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">;</span>             <span class="c1">// 矩阵中的一个位置</span>
    <span class="kt">int</span> <span class="n">effortFromStart</span><span class="o">;</span>  <span class="c1">// 从起点 (0, 0) 到当前位置的最小体力消耗（距离）</span>
    <span class="nc">State</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">effortFromStart</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">effortFromStart</span> <span class="o">=</span> <span class="n">effortFromStart</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 方向数组，上下左右的坐标偏移量</span>
<span class="kt">int</span><span class="o">[][]</span> <span class="n">dirs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]</span><span class="n">括号</span><span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">},</span> <span class="o">{</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">},</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">}</span><span class="n">括号</span><span class="o">;</span>

<span class="c1">// 返回坐标 (x, y) 的上下左右相邻坐标</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="nf">adj</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
    <span class="c1">// 存储相邻节点</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">dir</span> <span class="o">:</span> <span class="n">dirs</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dir</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nx</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 索引越界</span>
        <span class="n">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nx</span><span class="o">,</span> <span class="n">ny</span><span class="o">});</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">neighbors</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// Dijkstra 算法</span>
<span class="c1">// 计算 (0, 0) 到 (m - 1, n - 1) 的最小体力消耗</span>
<span class="kt">int</span> <span class="nf">minimumEffortPath</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">heights</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">heights</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">heights</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

    <span class="c1">// 定义：从 (0, 0) 到 (i, j) 的最小体力消耗是 effortTo[i][j]</span>
    <span class="c1">// dp table 初始化为正无穷</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">effortTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">effortTo</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="c1">// base case，起点到起点的最小消耗就是 0</span>
    <span class="n">effortTo</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="c1">// 优先级队列，effortFromStart 较小的排在前面</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">State</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span>
        <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span><span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">effortFromStart</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">effortFromStart</span><span class="o">;}</span>
    <span class="o">);</span>
    <span class="c1">// 从起点 (0, 0) 开始进行 BFS</span>
    <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>

    <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">State</span> <span class="n">curState</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">curX</span> <span class="o">=</span> <span class="n">curState</span><span class="o">.</span><span class="na">x</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">curY</span> <span class="o">=</span> <span class="n">curState</span><span class="o">.</span><span class="na">y</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">curEffortFromStart</span> <span class="o">=</span> <span class="n">curState</span><span class="o">.</span><span class="na">effortFromStart</span><span class="o">;</span>
        <span class="c1">// 到达终点提前结束</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">curX</span> <span class="o">==</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">curY</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">curEffortFromStart</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">curEffortFromStart</span> <span class="o">&gt;</span> <span class="n">effortTo</span><span class="o">[</span><span class="n">curX</span><span class="o">][</span><span class="n">curY</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>
        <span class="c1">// 将 (curX, curY) 的相邻坐标装入队列</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">adj</span><span class="o">(</span><span class="n">heights</span><span class="o">,</span> <span class="n">curX</span><span class="o">,</span> <span class="n">curY</span><span class="o">))</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">nextX</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">nextY</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="c1">// 计算从 (curX, curY) 达到 (nextX, nextY) 的消耗</span>
            <span class="kt">int</span> <span class="n">effortToNextNode</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span>
                <span class="n">effortTo</span><span class="o">[</span><span class="n">curX</span><span class="o">][</span><span class="n">curY</span><span class="o">],</span>
                <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">heights</span><span class="o">[</span><span class="n">curX</span><span class="o">][</span><span class="n">curY</span><span class="o">]</span> <span class="o">-</span> <span class="n">heights</span><span class="o">[</span><span class="n">nextX</span><span class="o">][</span><span class="n">nextY</span><span class="o">]));</span>
            <span class="c1">// 更新 dp table</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">effortTo</span><span class="o">[</span><span class="n">nextX</span><span class="o">][</span><span class="n">nextY</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">effortToNextNode</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">effortTo</span><span class="o">[</span><span class="n">nextX</span><span class="o">][</span><span class="n">nextY</span><span class="o">]</span> <span class="o">=</span> <span class="n">effortToNextNode</span><span class="o">;</span>
                <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="n">nextX</span><span class="o">,</span> <span class="n">nextY</span><span class="o">,</span> <span class="n">effortToNextNode</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 正常情况不会达到这个 return</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="概率最大的路径">概率最大的路径</h3><p><a href="https://leetcode.com/problems/path-with-maximum-probability/">1514. Path with Maximum Probability</a></p><ul><li>You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].<li>Given two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.<li>If there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 28 ms, faster than 96.09% of Java online submissions for Path with Maximum Probability.</span>
<span class="c1">// Memory Usage: 52.4 MB, less than 58.96% of Java online submissions for Path with Maximum Probability.</span>

<span class="kd">class</span> <span class="nc">State</span> <span class="o">{</span>
    <span class="c1">// 图节点的 id</span>
    <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="c1">// 从 start 节点到达当前节点的概率</span>
    <span class="kt">double</span> <span class="n">probFromStart</span><span class="o">;</span>

    <span class="nc">State</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="kt">double</span> <span class="n">probFromStart</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">probFromStart</span> <span class="o">=</span> <span class="n">probFromStart</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kt">double</span> <span class="nf">maxProbability</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">,</span> <span class="kt">double</span><span class="o">[]</span> <span class="n">succProb</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">[]&gt;[]</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">graph</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
    <span class="c1">// 构造邻接表结构表示图</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">edges</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">double</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">succProb</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="c1">// 无向图就是双向图；先把 int 统一转成 double，待会再转回来</span>
        <span class="n">graph</span><span class="o">[</span><span class="n">from</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">double</span><span class="o">[]{(</span><span class="kt">double</span><span class="o">)</span><span class="n">to</span><span class="o">,</span> <span class="n">weight</span><span class="o">});</span>
        <span class="n">graph</span><span class="o">[</span><span class="n">to</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">double</span><span class="o">[]{(</span><span class="kt">double</span><span class="o">)</span><span class="n">from</span><span class="o">,</span> <span class="n">weight</span><span class="o">});</span>
    <span class="o">}</span>

    <span class="c1">// 定义：probTo[i] 的值就是节点 start 到达节点 i 的最大概率</span>
    <span class="kt">double</span><span class="o">[]</span> <span class="n">probTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="c1">// dp table 初始化为一个取不到的最小值</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">probTo</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="c1">// base case，start 到 start 的概率就是 1</span>
    <span class="n">probTo</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

    <span class="c1">// 优先级队列，probFromStart 较大的排在前面</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">State</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Double</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">probFromStart</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">probFromStart</span><span class="o">);</span>
    <span class="o">});</span>
    <span class="c1">// 从起点 start 开始进行 BFS</span>
    <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>

    <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">State</span> <span class="n">curState</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">curNodeID</span> <span class="o">=</span> <span class="n">curState</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
        <span class="kt">double</span> <span class="n">curProbFromStart</span> <span class="o">=</span> <span class="n">curState</span><span class="o">.</span><span class="na">probFromStart</span><span class="o">;</span>

        <span class="c1">// 遇到终点提前返回</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">curNodeID</span> <span class="o">==</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">curProbFromStart</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">curProbFromStart</span> <span class="o">&lt;</span> <span class="n">probTo</span><span class="o">[</span><span class="n">curNodeID</span><span class="o">])</span> <span class="o">{</span>
            <span class="c1">// 已经有一条概率更大的路径到达 curNode 节点了</span>
            <span class="k">continue</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 将 curNode 的相邻节点装入队列</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">double</span><span class="o">[]</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">curNodeID</span><span class="o">])</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">nextNodeID</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">neighbor</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="c1">// 看看从 curNode 达到 nextNode 的概率是否会更大</span>
            <span class="kt">double</span> <span class="n">probToNextNode</span> <span class="o">=</span> <span class="n">probTo</span><span class="o">[</span><span class="n">curNodeID</span><span class="o">]</span> <span class="o">*</span> <span class="n">neighbor</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">probTo</span><span class="o">[</span><span class="n">nextNodeID</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">probToNextNode</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">probTo</span><span class="o">[</span><span class="n">nextNodeID</span><span class="o">]</span> <span class="o">=</span> <span class="n">probToNextNode</span><span class="o">;</span>
                <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">State</span><span class="o">(</span><span class="n">nextNodeID</span><span class="o">,</span> <span class="n">probToNextNode</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 如果到达这里，说明从 start 开始无法到达 end，返回 0</span>
    <span class="k">return</span> <span class="mf">0.0</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h1 id="设计数据结构">设计数据结构</h1><ul><li>LRU 算法的淘汰策略是 Least Recently Used， 淘汰那些最久没被使用的数据；<ul><li>LRU 算法的核心数据结构是使用哈希链表 LinkedHashMap，<li>借助链表的<code class="language-plaintext highlighter-rouge">有序性</code>使得链表元素维持插入顺序，<li>借助哈希映射的<code class="language-plaintext highlighter-rouge">快速访问能力</code>使得我们可以在 O(1) 时间访问链表的任意元素。<li>LRU 算法相当于把数据按照时间排序<ul><li>这个需求借助链表很自然就能实现，<li>一直从链表头部加入元素的话，越靠近头部的元素就是新的数据，越靠近尾部的元素就是旧的数据，<li>进行缓存淘汰的时候只要简单地将尾部的元素淘汰掉就行了。</ul></ul><li>而 LFU 算法的淘汰策略是 Least Frequently Used， 淘汰那些使用次数最少的数据。<ul><li>LFU 算法的难度大于 LRU 算法<li>把数据按照访问频次进行排序，<li>还有一种情况，如果多个数据拥有相同的访问频次，我们就得删除最早插入的那个数据。<ul><li>也就是说 LFU 算法是淘汰访问频次最低的数据，<li>如果访问频次最低的数据有多条，需要淘汰最旧的数据。</ul></ul></ul><hr /><h2 id="缓存淘汰">缓存淘汰</h2><h3 id="lru-缓存淘汰算法-least-recently-used">LRU 缓存淘汰算法 Least Recently Used</h3><p>让 put 和 get 方法的时间复杂度为 O(1)，cache 这个数据结构必要的条件：</p><ul><li>cache 中的元素必须有时序，<ul><li>以区分最近使用的和久未使用的数据，<li>当容量满了之后要删除最久未使用的那个元素腾位置。</ul><li>要在 cache 中快速找某个 key 是否已存在并得到对应的 val；<li>每次访问 cache 中的某个 key，需要将这个元素变为最近使用的，<ul><li>也就是说 cache 要支持在任意位置快速插入和删除元素。</ul></ul><p>数据结构</p><ul><li>哈希表查找快，但是数据无固定顺序；<li>链表有顺序之分，插入删除快，但是查找慢。<li>结合一下，形成一种新的数据结构：哈希链表 LinkedHashMap。</ul><p>LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：</p><hr /><h4 id="造轮子-lru-算法">造轮子 LRU 算法</h4><ul><li>我们实现的双链表 API 只能从尾部插入<li>也就是说靠尾部的数据是最近使用的，靠头部的数据是最久为使用的。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
</pre><td class="rouge-code"><pre><span class="c1">// 双链表的节点类</span>
<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="n">next</span><span class="o">,</span> <span class="n">prev</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 依靠我们的 Node 类型构建一个双链表</span>
<span class="kd">class</span> <span class="nc">DoubleList</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">;</span>   <span class="c1">// 头尾虚节点</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>          <span class="c1">// 链表元素数</span>

    <span class="kd">public</span> <span class="nf">DoubleList</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 初始化双向链表的数据</span>
        <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
        <span class="n">tail</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 在链表尾部添加节点 x，时间 O(1)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addLast</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">x</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
        <span class="n">tail</span><span class="o">.</span><span class="na">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">tail</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">size</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="c1">// 删除链表中的 x 节点（x 一定存在）</span>
    <span class="c1">// 由于是双链表且给的是目标 Node 节点，时间 O(1)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">x</span><span class="o">.</span><span class="na">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
        <span class="n">size</span><span class="o">--;</span>
    <span class="o">}</span>

    <span class="c1">// 删除链表中第一个节点，并返回该节点，时间 O(1)</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">removeFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="n">tail</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">first</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">remove</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 返回链表长度，时间 O(1)</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">size</span><span class="o">;</span> <span class="o">}</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">LRUCache</span> <span class="o">{</span>
    <span class="c1">// key -&gt; Node(key, val)</span>
    <span class="kd">private</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">;</span>
    <span class="c1">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span>
    <span class="kd">private</span> <span class="nc">DoubleList</span> <span class="n">cache</span><span class="o">;</span>
    <span class="c1">// 最大容量</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">cap</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cap</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
        <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DoubleList</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">// 将该数据提升为最近使用的</span>
        <span class="n">makeRecently</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="na">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 删除旧的数据</span>
            <span class="n">deleteKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="c1">// 新插入的数据为最近使用的数据</span>
            <span class="n">addRecently</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">cap</span> <span class="o">==</span> <span class="n">cache</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 删除最久未使用的元素</span>
            <span class="n">removeLeastRecently</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">// 添加为最近使用的元素</span>
        <span class="n">addRecently</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="cm">/* 将某个 key 提升为最近使用的 */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">makeRecently</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="c1">// 先从链表中删除这个节点</span>
    <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
    <span class="c1">// 重新插到队尾</span>
    <span class="n">cache</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/* 添加最近使用的元素 */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">addRecently</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="c1">// 链表尾部就是最近使用的元素</span>
    <span class="n">cache</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
    <span class="c1">// 别忘了在 map 中添加 key 的映射</span>
    <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/* 删除某一个 key */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">deleteKey</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="c1">// 从链表中删除</span>
    <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
    <span class="c1">// 从 map 中删除</span>
    <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/* 删除最久未使用的元素 */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">removeLeastRecently</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 链表头部的第一个元素就是最久未使用的</span>
    <span class="nc">Node</span> <span class="n">deletedNode</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
    <span class="c1">// 同时别忘了从 map 中删除它的 key</span>
    <span class="kt">int</span> <span class="n">deletedKey</span> <span class="o">=</span> <span class="n">deletedNode</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
    <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">deletedKey</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="使用-java-内置的-linkedhashmap-来实现一遍">使用 Java 内置的 LinkedHashMap 来实现一遍。</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">LRUCache</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">cap</span><span class="o">;</span>
    <span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cap</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// get + 将 key 变为最近使用</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">cache</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">// 将 key 变为最近使用</span>
        <span class="n">makeRecently</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// add + 将 key 变为最近使用</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 修改 key 的值</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
            <span class="c1">// 将 key 变为最近使用</span>
            <span class="n">makeRecently</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="o">.</span><span class="na">cap</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 链表头部就是最久未使用的 key</span>
            <span class="kt">int</span> <span class="n">oldestKey</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">keySet</span><span class="o">().</span><span class="na">iterator</span><span class="o">().</span><span class="na">next</span><span class="o">();</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">oldestKey</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// 将新的 key 添加链表尾部</span>
        <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">makeRecently</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="c1">// 删除 key，重新插入到队尾</span>
        <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="lfu-淘汰算法-least-frequently-used">LFU 淘汰算法 Least Frequently Used</h3><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 71 ms, faster than 56.22% of Java online submissions for LFU Cache.</span>
<span class="c1">// Memory Usage: 122.6 MB, less than 78.55% of Java online submissions for LFU Cache.</span>

<span class="kd">class</span> <span class="nc">LFUCache</span> <span class="o">{</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">keyToVal</span><span class="o">;</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">keyToFreq</span><span class="o">;</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">freqToKeys</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">minFreq</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cap</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LFUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">){</span>
        <span class="n">keyToVal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">keyToFreq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">freqToKeys</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cap</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">minFreq</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">keyToVal</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span><span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="n">increaseFreq</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">keyToVal</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cap</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span><span class="k">return</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">keyToVal</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">)){</span>
            <span class="n">keyToVal</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
            <span class="n">increaseFreq</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">keyToVal</span><span class="o">.</span><span class="na">size</span><span class="o">()&gt;=</span> <span class="k">this</span><span class="o">.</span><span class="na">cap</span><span class="o">)</span><span class="n">removeMinFreqKey</span><span class="o">();</span>
        <span class="n">keyToVal</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="n">keyToFreq</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>

        <span class="n">freqToKeys</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;());</span>
        <span class="n">freqToKeys</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="c1">// 插入新 key 后最小的 freq 肯定是 1</span>
        <span class="k">this</span><span class="o">.</span><span class="na">minFreq</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeMinFreqKey</span><span class="o">(){</span>
        <span class="nc">LinkedHashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">keyList</span> <span class="o">=</span> <span class="n">freqToKeys</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">minFreq</span><span class="o">);</span>
        <span class="c1">// 其中最先被插入的那个 key 就是该被淘汰的 key</span>
        <span class="kt">int</span> <span class="n">deletedKey</span> <span class="o">=</span> <span class="n">keyList</span><span class="o">.</span><span class="na">iterator</span><span class="o">().</span><span class="na">next</span><span class="o">();</span>
        <span class="n">keyList</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">deletedKey</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">keyList</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span><span class="n">freqToKeys</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">minFreq</span><span class="o">);</span>
        <span class="n">keyToVal</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">deletedKey</span><span class="o">);</span>
        <span class="n">keyToFreq</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">deletedKey</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">increaseFreq</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">keyToFreq</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="n">keyToFreq</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">freq</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">freqToKeys</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">freq</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;&gt;());</span>
        <span class="n">freqToKeys</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">freq</span><span class="o">+</span><span class="mi">1</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>

        <span class="n">freqToKeys</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">freq</span><span class="o">).</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">freqToKeys</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">freq</span><span class="o">).</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">freqToKeys</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">freq</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">minFreq</span> <span class="o">==</span> <span class="n">freq</span><span class="o">)</span><span class="k">this</span><span class="o">.</span><span class="na">minFreq</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache obj = new LFUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */</span>
</pre></table></code></div></div><hr /><h2 id="最大栈-maximum-frequency-stack">最大栈 Maximum Frequency Stack</h2><p><a href="https://leetcode.com/problems/maximum-frequency-stack/">895. Maximum Frequency Stack</a></p><ul><li>Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.<li>Implement the FreqStack class:<ul><li>FreqStack() constructs an empty frequency stack.<li>void push(int val) pushes an integer val onto the top of the stack.<li>int pop() removes and returns the most frequent element in the stack.<li>If there is a tie for the most frequent element, the element closest to the stacks top is removed and returned.</ul></ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre><td class="rouge-code"><pre><span class="nc">FreqStack</span> <span class="n">stk</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FreqStack</span><span class="o">();</span>

<span class="c1">// 向最大频率栈中添加元素</span>
<span class="n">stk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> <span class="n">stk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">7</span><span class="o">);</span> <span class="n">stk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
<span class="n">stk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">7</span><span class="o">);</span> <span class="n">stk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> <span class="n">stk</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>

<span class="c1">// 栈中元素：[2,7,2,7,2,4]</span>
<span class="n">stk</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="c1">// 返回 2</span>
<span class="c1">// 因为 2 出现了三次</span>

<span class="c1">// 栈中元素：[2,7,2,7,4]</span>
<span class="n">stk</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="c1">// 返回 7</span>
<span class="c1">// 2 和 7 都出现了两次，但 7 是最近添加的</span>

<span class="c1">// 栈中元素：[2,7,2,4]</span>
<span class="n">stk</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="c1">// 返回 2</span>

<span class="c1">// 栈中元素：[2,7,4]89-p-0p098-0p</span>
<span class="n">stk</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="c1">// 返回 4</span>

<span class="c1">// 栈中元素：[2,7]</span>


<span class="c1">// Runtime: 27 ms, faster than 67.35% of Java online submissions for Maximum Frequency Stack.</span>
<span class="c1">// Memory Usage: 49.8 MB, less than 38.95% of Java online submissions for Maximum Frequency Stack.</span>

<span class="kd">class</span> <span class="nc">FreqStack</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">maxFre</span><span class="o">;</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="nc">ValFre</span><span class="o">;</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nc">FreVal</span><span class="o">;</span>


    <span class="kd">public</span> <span class="nf">FreqStack</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 记录 FreqStack 中元素的最大频率</span>
        <span class="n">maxFreq</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// 记录 FreqStack 中每个 val 对应的出现频率，后文就称为 VF 表</span>
        <span class="n">valToFreq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// 记录频率 freq 对应的 val 列表，后文就称为 FV 表</span>
        <span class="n">freqToVals</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 修改 VF 表：val 对应的 freq 加一</span>
        <span class="kt">int</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">valToFreq</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">valToFreq</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="n">freq</span><span class="o">);</span>
        <span class="c1">// 修改 FV 表：在 freq 对应的列表加上 val</span>
        <span class="n">freqToVals</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">freq</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;());</span>
        <span class="n">freqToVals</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">freq</span><span class="o">).</span><span class="na">push</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="c1">// 更新 maxFreq</span>
        <span class="n">maxFreq</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxFreq</span><span class="o">,</span> <span class="n">freq</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 修改 FV 表：pop 出一个 maxFreq 对应的元素 v</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">freqToVals</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">maxFreq</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="c1">// 修改 VF 表：v 对应的 freq 减一</span>
        <span class="kt">int</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">valToFreq</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">valToFreq</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">freq</span><span class="o">);</span>
        <span class="c1">// 更新 maxFreq</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">vals</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 如果 maxFreq 对应的元素空了</span>
            <span class="n">maxFreq</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><hr /><h1 id="数据流">数据流</h1><hr /><h2 id="reservoir-sampling-随机-水塘抽样算法">Reservoir Sampling 随机 水塘抽样算法</h2><p>随机是均匀随机（uniform random）</p><ul><li>如果有 n 个元素，每个元素被选中的概率都是 1/n，不可以有统计意义上的偏差。</ul><p>一般的想法就是，先遍历一遍链表，得到链表的总长度 n，再生成一个 [1,n] 之间的随机数为索引，然后找到索引对应的节点，就是一个随机的节点了.</p><ul><li>但只能遍历一次，意味着这种思路不可行。<li>题目还可以再泛化，给一个未知长度的序列，如何在其中随机地选择 k 个元素？想要解决这个问题，就需要著名的水塘抽样算法了。</ul><p>但是这种问题的关键在于证明，你的算法为什么是对的？为什么每次以 1/i 的概率更新结果就可以保证结果是平均随机（uniform random）？</p><ul><li>证明：<li>假设总共有 n 个元素，每个元素被选择的概率都是 1/n，<li>那么对于第 i 个元素，它被选择的概率就是：</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/dYosNcJ.png" alt="formula1" /></p><hr /><h3 id="382-linked-list-random-node-无限序列随机抽取1元素">382. Linked List Random Node 无限序列随机抽取1元素</h3><p><a href="https://leetcode.com/problems/linked-list-random-node/">382. Linked List Random Node</a></p><ul><li>Given a singly linked list,<li>return a random nodes value from the linked list.<li>Each node must have the same probability of being chosen.<li>Implement the Solution class:<ul><li>Solution(ListNode head) Initializes the object with the integer array nums.<li>int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.</ul></ul><p>当你遇到第 i 个元素时，应该有 1/i 的概率选择该元素，1 - 1/i 的概率保持原有的选择。</p><p>证明：</p><ul><li>假设总共有 n 个元素，<li>随机性 每个元素被选择的概率都是 1/n<li>那么对于第 i 个元素，它被选择的概率就是：<li>第 i 个元素被选择的概率是 1/i，<li>第 i+1 次不被替换的概率是 1 - 1/(i+1)，以此类推，相乘就是第 i 个元素最终被选中的概率，就是 1/n。</ul><p>因此，该算法的逻辑是正确的。</p><h4 id="be-list-size-random-n">be list, size, random n</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// time: O(N) + O(1)</span>
<span class="c1">// space: O(N) a list store all n</span>
<span class="kd">public</span> <span class="nf">Solution</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">while</span><span class="o">(</span><span class="n">head</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="n">head</span><span class="o">=</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getRandom</span><span class="o">()</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="na">get</span><span class="o">(</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="n">arr</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="reservoir-sampling">Reservoir Sampling</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 17 ms, faster than 28.48% of Java online submissions for Linked List Random Node.</span>
<span class="c1">// Memory Usage: 40.7 MB, less than 82.71% of Java online submissions for Linked List Random Node.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">n</span><span class="o">;</span>
    <span class="nc">Random</span> <span class="n">r</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Solution</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">n</span><span class="o">=</span><span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getRandom</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="c1">// 生成一个 [0, i) 之间的整数</span>
            <span class="c1">// 这个整数等于 0 的概率就是 1/i</span>
            <span class="k">if</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">i</span><span class="o">++)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">res</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="无限序列随机抽取-k-个数">无限序列随机抽取 k 个数</h3><p><img data-proofer-ignore data-src="https://i.imgur.com/Lk6Pim9.png" alt="formula2" /></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cm">/* 返回链表中 k 个随机节点的值 */</span>
<span class="kt">int</span><span class="o">[]</span> <span class="nf">getRandom</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Random</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
    <span class="nc">ListNode</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

    <span class="c1">// 前 k 个元素先默认选上</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">res</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
    <span class="c1">// while 循环遍历链表</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 生成一个 [0, i) 之间的整数</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(++</span><span class="n">i</span><span class="o">);</span>
        <span class="c1">// 这个整数小于 k 的概率就是 k/i</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="n">res</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="398-random-pick-index-medium">398. Random Pick Index (Medium)</h3><p><a href="https://leetcode.com/problems/random-pick-index/">398. Random Pick Index</a> Given an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.</p><p>Implement the Solution class:</p><p>Solution(int[] nums) Initializes the object with the array nums. int pick(int target) Picks a random index i from nums where nums[i] == target. If there are multiple valid i’s, then each index should have an equal probability of returning.</p><p>Example 1: Input [“Solution”, “pick”, “pick”, “pick”] [[[1, 2, 3, 3, 3]], [3], [1], [3]] Output [null, 4, 0, 2]</p><h4 id="reservoir-sampling-1">Reservoir Sampling</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 93 ms, faster than 21.70% of Java online submissions for Random Pick Index.</span>
<span class="c1">// Memory Usage: 72.5 MB, less than 21.60% of Java online submissions for Random Pick Index.</span>
<span class="cm">/**
 * Using Reservoir Sampling
 *
 * Suppose the indexes of the target element in array are from 1 to N. You have
 * already picked i-1 elements. Now you are trying to pick ith element. The
 * probability to pick it is 1/i. Now you do not want to pick any future
 * numbers.. Thus, the final probability for ith element = 1/i * (1 - 1/(i+1)) *
 * (1 - 1/(i+2)) * .. * (1 - 1/N) = 1 / N.
 *
 * Time Complexity:
 * 1) Solution() Constructor -&gt; O(1)
 * 2) pick() -&gt; O(N)
 *
 * Space Complexity: O(1)
 *
 * N = Length of the input array.
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
    <span class="nc">Random</span> <span class="n">r</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums</span><span class="o">=</span><span class="n">nums</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pick</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span><span class="o">=-</span><span class="mi">1</span><span class="o">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(++</span><span class="n">count</span><span class="o">)==</span><span class="mi">0</span><span class="o">)</span> <span class="n">res</span><span class="o">=</span><span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="hashmap">HashMap</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Preprocessing input using HashMap
 *
 * Time Complexity:
 * 1) Solution() Constructor -&gt; O(N)
 * 2) pick() -&gt; O(1)
 *
 * Space Complexity: O(N)
 *
 * N = Length of the input array.
 */</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
    <span class="nc">Random</span> <span class="n">r</span><span class="o">;</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">map</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums</span><span class="o">=</span><span class="n">nums</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
            <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]).</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pick</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">target</span><span class="o">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">curList</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">curList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">curList</span><span class="o">.</span><span class="na">size</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="380-insert-delete-getrandom-o1-实现随机集合">380. Insert Delete GetRandom O(1) 实现随机集合</h3><p><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/">380. Insert Delete GetRandom O(1)</a></p><p>Implement the RandomizedSet class:</p><p>RandomizedSet() Initializes the RandomizedSet object. bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. int getRandom() Returns a random element from the current set of elements (it’s guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned. You must implement the functions of the class such that each function works in average O(1) time complexity.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="nc">Example</span> <span class="mi">1</span><span class="o">:</span>

<span class="nc">Input</span>
<span class="o">[</span><span class="s">"RandomizedSet"</span><span class="o">,</span> <span class="s">"insert"</span><span class="o">,</span> <span class="s">"remove"</span><span class="o">,</span> <span class="s">"insert"</span><span class="o">,</span> <span class="s">"getRandom"</span><span class="o">,</span> <span class="s">"remove"</span><span class="o">,</span> <span class="s">"insert"</span><span class="o">,</span> <span class="s">"getRandom"</span><span class="o">]</span>
<span class="o">[[],</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[],</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[]]</span>
<span class="nc">Output</span>
<span class="o">[</span><span class="kc">null</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>

<span class="nc">Explanation</span>
<span class="nc">RandomizedSet</span> <span class="n">randomizedSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RandomizedSet</span><span class="o">();</span>
<span class="n">randomizedSet</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// Inserts 1 to the set. Returns true as 1 was inserted successfully.</span>
<span class="n">randomizedSet</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> <span class="c1">// Returns false as 2 does not exist in the set.</span>
<span class="n">randomizedSet</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> <span class="c1">// Inserts 2 to the set, returns true. Set now contains [1,2].</span>
<span class="n">randomizedSet</span><span class="o">.</span><span class="na">getRandom</span><span class="o">();</span> <span class="c1">// getRandom() should return either 1 or 2 randomly.</span>
<span class="n">randomizedSet</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// Removes 1 from the set, returns true. Set now contains [2].</span>
<span class="n">randomizedSet</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> <span class="c1">// 2 was already in the set, so return false.</span>
<span class="n">randomizedSet</span><span class="o">.</span><span class="na">getRandom</span><span class="o">();</span> <span class="c1">// Since 2 is the only number in the set, getRandom() will always return 2.</span>
</pre></table></code></div></div><p>难点：</p><ol><li>插入，删除，获取随机元素这三个操作的时间复杂度必须都是 O(1)。<ol><li>想「等概率」且「在 O(1) 的时间」取出元素，一定要满足：底层用数组实现，且数组必须是紧凑的。<li>这样就可以直接生成随机数作为索引，从数组中取出该随机索引对应的元素，作为随机元素。<li>但如果用数组存储元素的话，插入，删除的时间复杂度怎么可能是 O(1) 呢？<ol><li>对数组尾部进行插入和删除操作不会涉及数据搬移，时间复杂度是 O(1)。<li>所以在 O(1) 的时间删除数组中的某一个元素 val，可以先把这个元素交换到数组的尾部，然后再 pop 掉。<li>交换两个元素必须通过索引进行交换对吧，那么我们需要一个哈希表 valToIndex 来记录每个元素值对应的索引。</ol></ol><li>getRandom 方法返回的元素必须等概率返回随机元素，如果集合里面有 n 个元素，每个元素被返回的概率必须是 1/n。</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">RandomizedSet</span> <span class="o">{</span>

    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="nc">Random</span> <span class="n">random</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">RandomizedSet</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//val, index</span>
        <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="c1">//{[index]val, }</span>
        <span class="n">array</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100001</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="n">random</span><span class="o">=</span><span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 若 val 已存在，不用再插入</span>
        <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">val</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">// 若 val 不存在，插入到 nums 尾部，</span>
        <span class="c1">// 并记录 val 对应的索引值</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
            <span class="n">list</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="n">index</span><span class="o">);</span>
            <span class="n">index</span><span class="o">++;</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">list</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">val</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 先拿到 val 的索引</span>
            <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
            <span class="n">array</span><span class="o">[</span><span class="n">pos</span><span class="o">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">])){</span>
                <span class="n">list</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="n">pos</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">index</span><span class="o">--;</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getRandom</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 随机获取 nums 中的一个元素</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">index</span><span class="o">)];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="710-random-pick-with-blacklist-避开黑名单的随机数-blacklist-index-to-good-index">710. Random Pick with Blacklist 避开黑名单的随机数 <code class="language-plaintext highlighter-rouge">blacklist index to good index</code></h3><p><a href="https://leetcode.com/problems/random-pick-with-blacklist/">710. Random Pick with Blacklist</a></p><p>You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a random integer in the range [0, n - 1] that is not in blacklist. Any integer that is in the mentioned range and not in blacklist should be equally likely to be returned.</p><p>Optimize your algorithm such that it minimizes the number of calls to the built-in random function of your language.</p><p>Implement the Solution class:</p><p>Solution(int n, int[] blacklist) Initializes the object with the integer n and the blacklisted integers blacklist. int pick() Returns a random integer in the range [0, n - 1] and not in blacklist.</p><ul><li>给你输入一个正整数 N，代表左闭右开区间 [0,N)，<li>再给你输入一个数组 blacklist，其中包含一些「黑名单数字」，且 blacklist 中的数字都是区间 [0,N) 中的数字。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 42 ms, faster than 40.45% of Java online submissions for Random Pick with Blacklist.</span>
<span class="c1">// Memory Usage: 54 MB, less than 17.08% of Java online submissions for Random Pick with Blacklist.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="nc">Random</span> <span class="n">ran</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span> <span class="n">range</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">blacklist</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">blacklist</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">b:</span><span class="n">blacklist</span><span class="o">)</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>

        <span class="n">range</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="n">blacklist</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">last</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">b:</span><span class="n">blacklist</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">b</span><span class="o">&lt;</span><span class="n">range</span><span class="o">){</span>
                <span class="k">while</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">last</span><span class="o">))</span> <span class="n">last</span><span class="o">--;</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">b</span><span class="o">,</span><span class="n">last</span><span class="o">);</span>
                <span class="n">last</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pick</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">ran</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">range</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="528-random-pick-with-weight-medium">528. Random Pick with Weight (Medium)</h3><p>You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index.</p><p>You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).</p><p>For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%).</p><h4 id="2-for-123---122333"><code class="language-plaintext highlighter-rouge">2 for: [1,2,3] -&gt; [1,2,2,3,3,3]</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// memory limit exceeds. Then pick a random value from the arraylist.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nums</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Random</span> <span class="n">rand</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">w</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">w</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">j</span><span class="o">++)</span> <span class="k">this</span><span class="o">.</span><span class="na">nums</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pickIndex</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="reservoir-sampling-2">Reservoir Sampling</h4><p>[1,2,3,4,5,] [1,3,6,10,15]</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">total</span><span class="o">;</span>
    <span class="nc">Random</span> <span class="n">r</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">w</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">this</span><span class="o">.</span><span class="na">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">runningTotal</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">w</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">runningTotal</span> <span class="o">+=</span> <span class="n">w</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">this</span><span class="o">.</span><span class="na">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">runningTotal</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">total</span> <span class="o">=</span> <span class="n">runningTotal</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pickIndex</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">total</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">r</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">total</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="reservoir-sampling-best">reservoir sampling <strong>BEST</strong></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 20 ms, faster than 96.28% of Java online submissions for Random Pick with Weight.</span>
<span class="c1">// Memory Usage: 44 MB, less than 69.48% of Java online submissions for Random Pick with Weight.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">total</span><span class="o">;</span>
    <span class="nc">Random</span> <span class="n">r</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">w</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">this</span><span class="o">.</span><span class="na">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">runningTotal</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">w</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">runningTotal</span> <span class="o">+=</span> <span class="n">w</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">this</span><span class="o">.</span><span class="na">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">runningTotal</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">total</span> <span class="o">=</span> <span class="n">runningTotal</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pickIndex</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">total</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">r</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span> <span class="n">pos</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">pos</span><span class="o">)</span> <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">else</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="other-1">other</h2><h3 id="295-find-median-from-data-stream-中位数">295. Find Median from Data Stream 中位数</h3><p><a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median from Data Stream</a></p><ul><li>The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.<ul><li>For example, for arr = [2,3,4], the median is 3.<li>For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.</ul><li>Implement the MedianFinder class:<ul><li>MedianFinder() initializes the MedianFinder object.<li>void addNum(int num) adds the integer num from the data stream to the data structure.<li>double findMedian() returns the median of all elements so far.<ul><li>Answers within 10^-5 of the actual answer will be accepted.</ul></ul></ul><ol><li>如果输入一个数组，排个序，长度是奇数，最中间的一个元素就是中位数，长度是偶数，最中间两个元素的平均数作为中位数。<li>如果数据规模非常大，排序不现实，使用概率算法，随机抽取一部分数据，排序，求中位数，作为所有数据的中位数。</ol><p>必然需要有序数据结构，本题的核心思路是使用两个优先级队列。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 102 ms, faster than 70.85% of Java online submissions for Find Median from Data Stream.</span>
<span class="c1">// Memory Usage: 69.2 MB, less than 50.74% of Java online submissions for Find Median from Data Stream.</span>

<span class="kd">class</span> <span class="nc">MedianFinder</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">large</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">small</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MedianFinder</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 小顶堆</span>
        <span class="n">large</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// 大顶堆</span>
        <span class="n">small</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span>
            <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span><span class="k">return</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="o">;}</span>
        <span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">findMedian</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 如果元素不一样多，多的那个堆的堆顶元素就是中位数</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">large</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">small</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="k">return</span> <span class="n">small</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">large</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">small</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="k">return</span> <span class="n">large</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
        <span class="c1">// 如果元素一样多，两个堆堆顶元素的平均数是中位数</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">large</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">+</span> <span class="n">small</span><span class="o">.</span><span class="na">peek</span><span class="o">())</span> <span class="o">/</span> <span class="mf">2.0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addNum</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">small</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">large</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">small</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
            <span class="n">large</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">small</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">large</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
            <span class="n">small</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">large</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><hr /><h1 id="dfs-and-bfs">DFS and BFS</h1><ol><li>为什么 BFS 可以找到最短距离，DFS 不行吗？<ol><li>BFS 的逻辑，depth 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。<li>DFS 也是可以的，但是时间复杂度相对高很多。DFS 实际上是靠递归的堆栈记录走过的路径，找最短路径得把二叉树中所有树杈都探索完, 才能对比出最短的路径有多长<li>BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。<li>形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动</ol><li>既然 BFS 那么好，为啥 DFS 还要存在？<ol><li>BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。<li>假设给你的这个二叉树是满二叉树，节点数为 N，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 O(logN)。<li>BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 N/2，用 Big O 表示的话也就是 O(N)。<li>由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。</ol></ol><hr /><h2 id="-bfs">🔒🔒 BFS</h2><p>BFS 相对 DFS 的最主要的区别是：BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多</p><p>BFS 出现的常见场景好吧，</p><ul><li>问题的本质就是让你在一幅「图」中找到从起点 start 到终点 target 的最近距离<li>BFS 算法问题其实都是在干这个事儿，<li>比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？<li>再比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？<li>比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？<li>本质上就是一幅「图」，让你从一个起点，走到终点，问最短路径。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// 计算从起点 start 到终点 target 的最近距离</span>
<span class="kt">int</span> <span class="nf">BFS</span><span class="o">(</span><span class="nc">Node</span> <span class="n">start</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">;</span> <span class="c1">// 核心数据结构</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">visited</span><span class="o">;</span> <span class="c1">// 避免走回头路</span>

    <span class="c1">// 将起点加入队列</span>
    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
    <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 记录扩散的步数</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">q</span> <span class="n">not</span> <span class="n">empty</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="cm">/* 将当前队列中的所有节点向四周扩散 */</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="cm">/* 划重点：这里判断是否到达终点 */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cur</span> <span class="n">is</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="n">step</span><span class="o">;</span>
            <span class="cm">/* 将 cur 的相邻节点加入队列 */</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span> <span class="n">x</span> <span class="o">:</span> <span class="n">cur</span><span class="o">.</span><span class="na">adj</span><span class="o">())</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="n">not</span> <span class="n">in</span> <span class="n">visited</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                    <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                <span class="o">}</span>
        <span class="o">}</span>
        <span class="cm">/* 划重点：更新步数在这里 */</span>
        <span class="n">step</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="-752-open-the-lock-解开密码锁最少次数-用queue和qsize去遍历all--visited--deads">🔒 752. Open the Lock 解开密码锁最少次数 <code class="language-plaintext highlighter-rouge">用Queue和q.size去遍历all + visited + deads</code></h3><p><a href="https://labuladong.github.io/algo/4/29/108/">752. Open the Lock</a></p><ul><li>You have a lock in front of you with 4 circular wheels.<li>Each wheel has 10 slots: ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’.<li>The wheels can rotate freely and wrap around: for example we can turn ‘9’ to be ‘0’, or ‘0’ to be ‘9’.<li>Each move consists of turning one wheel one slot.<li>The lock initially starts at ‘0000’, a string representing the state of the 4 wheels.<li>You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.<li>Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.</ul><h4 id="bfs">BFS</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 76 ms, faster than 79.81% of Java online submissions for Open the Lock.</span>
<span class="c1">// Memory Usage: 44.9 MB, less than 79.14% of Java online submissions for Open the Lock.</span>
<span class="c1">// 将 s[j] 向上拨动一次</span>

<span class="nc">String</span> <span class="nf">plusOne</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'9'</span><span class="o">)</span> <span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'0'</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 将 s[i] 向下拨动一次</span>
<span class="nc">String</span> <span class="nf">minusOne</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span> <span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'9'</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="nf">openLock</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">deadends</span><span class="o">,</span> <span class="nc">String</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 记录需要跳过的死亡密码</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">deads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">deadends</span><span class="o">)</span> <span class="n">deads</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>

    <span class="c1">// 记录已经穷举过的密码，防止走回头路</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 从起点开始启动广度优先搜索</span>
    <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"0000"</span><span class="o">);</span>
    <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"0000"</span><span class="o">);</span>

    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="cm">/* 将当前队列中的所有节点向周围扩散 */</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="cm">/* 判断是否到达终点 */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">deads</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">cur</span><span class="o">))</span> <span class="k">continue</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">target</span><span class="o">))</span> <span class="k">return</span> <span class="n">step</span><span class="o">;</span>
            <span class="cm">/* 将一个节点的未遍历相邻节点加入队列 */</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">up</span> <span class="o">=</span> <span class="n">plusOne</span><span class="o">(</span><span class="n">cur</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
                <span class="nc">String</span> <span class="n">down</span> <span class="o">=</span> <span class="n">minusOne</span><span class="o">(</span><span class="n">cur</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">visited</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">up</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">up</span><span class="o">);</span>
                    <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">up</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">visited</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">down</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">down</span><span class="o">);</span>
                    <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">down</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="cm">/* 在这里增加步数 */</span>
        <span class="n">step</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="c1">// 如果穷举完都没找到目标密码，那就是找不到了</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="双向-bfs-优化-用queue和qsize去遍历-q1q2q2temp">双向 BFS 优化 <code class="language-plaintext highlighter-rouge">用Queue和q.size去遍历 q1=q2;q2=temp</code></h4><p>无论传统 BFS 还是双向 BFS，无论做不做优化，</p><ul><li>从 Big O 衡量标准来看，时间复杂度都是一样的，<li><p>只能说双向 BFS 是一种 trick，算法运行的速度会相对快一点</p><li>双向 BFS 也有局限，因为你必须知道终点在哪里。<ul><li>比如我们刚才讨论的二叉树最小高度的问题，你一开始根本就不知道终点在哪里，也就无法使用双向 BFS；<li>但是第二个密码锁的问题，是可以使用双向 BFS 算法来提高效率的，代码稍加修改即可：</ul><li>还是遵循 BFS 算法框架的，<ul><li>只是不再使用队列，而是使用 HashSet 方便快速判断两个集合是否有交集。</ul><li>另外的一个技巧点就是 while 循环的最后交换 q1 和 q2 的内容，<ul><li>所以只要默认扩散 q1 就相当于轮流扩散 q1 和 q2。</ul></ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 20 ms, faster than 96.72% of Java online submissions for Open the Lock.</span>
<span class="c1">// Memory Usage: 39.4 MB, less than 98.61% of Java online submissions for Open the Lock.</span>

<span class="nc">String</span> <span class="nf">plusOne</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'9'</span><span class="o">)</span> <span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'0'</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 将 s[i] 向下拨动一次</span>
<span class="nc">String</span> <span class="nf">minusOne</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span> <span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'9'</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">ch</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="nf">openLock</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">deadends</span><span class="o">,</span> <span class="nc">String</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">deads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">deadends</span><span class="o">)</span> <span class="n">deads</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="c1">// 用集合不用队列，可以快速判断元素是否存在</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">q1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">q2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

    <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">q1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"0000"</span><span class="o">);</span>
    <span class="n">q2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">q1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">q2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// 哈希集合在遍历的过程中不能修改，用 temp 存储扩散结果</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="cm">/* 将 q1 中的所有节点向周围扩散 */</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">cur</span> <span class="o">:</span> <span class="n">q1</span><span class="o">)</span> <span class="o">{</span>
            <span class="cm">/* 判断是否到达终点 */</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">deads</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">cur</span><span class="o">))</span> <span class="k">continue</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">q2</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">cur</span><span class="o">))</span> <span class="k">return</span> <span class="n">step</span><span class="o">;</span>
            <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
            <span class="cm">/* 将一个节点的未遍历相邻节点加入集合 */</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">up</span> <span class="o">=</span> <span class="n">plusOne</span><span class="o">(</span><span class="n">cur</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
                <span class="nc">String</span> <span class="n">down</span> <span class="o">=</span> <span class="n">minusOne</span><span class="o">(</span><span class="n">cur</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">visited</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">up</span><span class="o">))</span> <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">up</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">visited</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">down</span><span class="o">))</span> <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">down</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="cm">/* 在这里增加步数 */</span>
        <span class="n">step</span><span class="o">++;</span>
        <span class="c1">// temp 相当于 q1</span>
        <span class="c1">// 这里交换 q1 q2，下一轮 while 就是扩散 q2</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="n">q2</span><span class="o">;</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>双向 BFS 还有一个优化，就是在 while 循环开始时做一个判断：</p><ul><li>因为按照 BFS 的逻辑，队列（集合）中的元素越多，扩散之后新的队列（集合）中的元素就越多；<li>在双向 BFS 算法中，如果我们每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// ...</span>
<span class="k">while</span> <span class="o">(!</span><span class="n">q1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">q2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">q1</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">q2</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// 交换 q1 和 q2</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">q1</span><span class="o">;</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="n">q2</span><span class="o">;</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="-dfs-backtrack-回溯算法">🔒🔒 DFS backtrack 回溯算法</h2><p>回溯算法其实就是我们常说的 DFS 算法，本质上就是一种暴力穷举算法。</p><ul><li>1、路径：也就是已经做出的选择。<li>2、选择列表：也就是你当前可以做的选择。<li>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</ul><p>这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// 防止重复遍历同一个节点</span>
<span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
<span class="c1">// 从节点 s 开始 BFS 遍历，将遍历过的节点标记为 true</span>
<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;[]</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="k">return</span><span class="o">;</span>
    <span class="cm">/* 前序遍历代码位置 */</span>
    <span class="c1">// 将当前节点标记为已遍历</span>
    <span class="n">visited</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">:</span> <span class="n">graph</span><span class="o">[</span><span class="n">s</span><span class="o">])</span> <span class="n">traverse</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
    <span class="cm">/* 后序遍历代码位置 */</span>
<span class="o">}</span>

<span class="n">result</span> <span class="o">=</span> <span class="o">[]</span>
<span class="n">def</span> <span class="nf">backtrack</span><span class="o">(</span><span class="n">路径</span><span class="o">,</span> <span class="n">选择列表</span><span class="o">):</span>
    <span class="k">if</span> <span class="nl">满足结束条件:</span>
        <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">路径</span><span class="o">)</span>
        <span class="k">return</span>

    <span class="k">for</span> <span class="n">选择</span> <span class="n">in</span> <span class="nl">选择列表:</span>
        <span class="n">做选择</span>
        <span class="n">backtrack</span><span class="o">(</span><span class="n">路径</span><span class="o">,</span> <span class="n">选择列表</span><span class="o">)</span>
        <span class="n">撤销选择</span>
</pre></table></code></div></div><hr /><h3 id="-46-permutations-全排列问题-">🔒 46. Permutations 全排列问题 ??????????/</h3><p><a href="https://leetcode.com/problems/permutations/">46. Permutations</a></p><p>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.</p><p>Example 1:</p><p>Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><ol><li>Iterative Solution</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Iterative Solution
 *
 * The idea is to add the nth number in every possible position of each
 * permutation of the first n-1 numbers.
 *
 * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each permutation takes O(N) to construct
 * T(n) = (x=2-&gt;n) ∑ (x-1)!*x(x+1)/2
  *  = (x=1-&gt;n-1) ∑ (x)!*x(x-1)/2
  *  = O(N * N!)
 * Space Complexity: O((N-1) * (N-1)!) = O(N * N!). All permutations of the first n-1 numbers.
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">permute</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">subres</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cur</span> <span class="o">:</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">newCur</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">cur</span><span class="o">);</span>
                    <span class="n">newCur</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                    <span class="n">subres</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newCur</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">subres</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>Recursive Backtracking using visited array</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 94.15% of Java online submissions for Permutations.</span>
<span class="c1">// Memory Usage: 39.2 MB, less than 76.83% of Java online submissions for Permutations.</span>
<span class="c1">// Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each permutation takes O(N) to construct</span>
<span class="c1">//  * T(n) = n*T(n-1) + O(n)</span>
<span class="c1">//  * T(n-1) = (n-1)*T(n-2) + O(n)</span>
<span class="c1">//  * ...</span>
<span class="c1">//  * T(2) = (2)*T(1) + O(n)</span>
<span class="c1">//  * T(1) = O(n)</span>
<span class="c1">// Space Complexity: O(N). Recursion stack + visited array</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">permute</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="c1">// 记录「路径」</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">track</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">used</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="n">backtrack</span><span class="o">(</span><span class="n">track</span><span class="o">,</span> <span class="n">used</span><span class="o">,</span> <span class="n">res</span><span class="o">,</span> <span class="n">nums</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 从节点 s 开始 BFS 遍历，将遍历过的节点标记为 true</span>
    <span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">track</span><span class="o">,</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">used</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 触发结束条件</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">track</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">(</span><span class="n">track</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="c1">// skip used letters</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">used</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>
            <span class="c1">// add letter to permutation, mark letter as used</span>
            <span class="n">track</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">used</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">backtrack</span><span class="o">(</span><span class="n">track</span><span class="o">,</span> <span class="n">used</span><span class="o">,</span> <span class="n">res</span><span class="o">,</span> <span class="n">nums</span><span class="o">);</span>
            <span class="c1">// remove letter from permutation, mark letter as unused</span>
            <span class="n">track</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
            <span class="n">used</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="-51-n-queens-n-皇后问题-">🔒 51. N-Queens N 皇后问题 ??????????</h3><p><a href="https://leetcode.com/problems/n-queens/">51. N-Queens</a></p><p>The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.</p><p>Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.</p><p>Each solution contains a distinct board configuration of the n-queens placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space, respectively.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">solveNQueens</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">pos</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">pos</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">pos</span><span class="o">,</span> <span class="kt">int</span> <span class="n">step</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">step</span><span class="o">==</span><span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">printboard</span><span class="o">(</span><span class="n">pos</span><span class="o">,</span><span class="n">n</span><span class="o">);</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="n">ls</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">pos</span><span class="o">[</span><span class="n">step</span><span class="o">]=</span><span class="n">i</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isvalid</span><span class="o">(</span><span class="n">pos</span><span class="o">,</span><span class="n">step</span><span class="o">))</span> <span class="n">dfs</span><span class="o">(</span><span class="n">pos</span><span class="o">,</span><span class="n">step</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="n">list</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isvalid</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">pos</span><span class="o">,</span> <span class="kt">int</span> <span class="n">step</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">step</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span> <span class="n">pos</span><span class="o">[</span><span class="n">i</span><span class="o">]==</span><span class="n">pos</span><span class="o">[</span><span class="n">step</span><span class="o">]</span> <span class="o">||</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">pos</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="n">pos</span><span class="o">[</span><span class="n">step</span><span class="o">]))==(</span><span class="n">step</span><span class="o">-</span><span class="n">i</span><span class="o">)</span> <span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">printboard</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">pos</span><span class="o">,</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ls</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'.'</span><span class="o">);</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">pos</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="sc">'Q'</span><span class="o">);</span>
            <span class="n">ls</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ls</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Space Optimized Backtracking
 * Total number of permutations can be found by this equation
 * T(N) = N * T(N-1) + O(N)
 * T(N-1) = (N-1) * T(N-2) + O(N)
 * T(N-2) = (N-2) * T(N-3) + O(N)
 * T(N-3) = (N-3) * T(N-4) + O(N)
 * ...
 * T(2) = 2 * T(1) + O(N)
 * T(1) = O(1)
 * Thus total number of permutations
  *  = N * (P(N,0) + P(N,1) + ... + P(N, N-2)) + P(N,N-1)
  *  = N * (e * N! - P(N,N-1) - P(N,N)) + N!
  *  = ((e-2)*N + 1) * N!
        = (0.718 * N + 1) * N!
 * Also, if there are S(N) solutions, then time taken to generate these solution will be N^2 * S(N).
 * Here number of solutions will be much less than the total number of permutations.
 * Thus we can ignore the time taken for generating and adding the board in the result list.
 * Total Time Complexity = O(N * N!)
 * Space Complexity:
 * -&gt; O(N) for queensPos arr
 * -&gt; O(N) for recursion depth
 * -&gt; O(1) for occupied BitSet
 * Total Space Complexity = O(N)
 * N = Input board size.
 */</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="nf">solveNQueens</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Invalid board"</span><span class="o">);</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">queensPos</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">solveNQueensHelper</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">queensPos</span><span class="o">,</span> <span class="k">new</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">n</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">solveNQueensHelper</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">queensPos</span><span class="o">,</span> <span class="nc">BitSet</span> <span class="n">occupied</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">queensPos</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">generateResultBoard</span><span class="o">(</span><span class="n">queensPos</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">col</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// First N bits are for columns</span>
            <span class="c1">// Then 2*N bits are for diagonal at 45 degrees</span>
            <span class="c1">// Then 2*N bits are for diagonal at 135 degrees</span>
            <span class="kt">int</span> <span class="n">diag45</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="o">(</span><span class="n">row</span> <span class="o">+</span> <span class="n">col</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">diag135</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">row</span> <span class="o">-</span> <span class="n">col</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">occupied</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">col</span><span class="o">)</span> <span class="o">||</span> <span class="n">occupied</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">diag45</span><span class="o">)</span> <span class="o">||</span> <span class="n">occupied</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">diag135</span><span class="o">))</span> <span class="k">continue</span><span class="o">;</span>

            <span class="n">occupied</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">col</span><span class="o">);</span>
            <span class="n">occupied</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">diag45</span><span class="o">);</span>
            <span class="n">occupied</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">diag135</span><span class="o">);</span>
            <span class="n">queensPos</span><span class="o">[</span><span class="n">row</span><span class="o">]</span> <span class="o">=</span> <span class="n">col</span><span class="o">;</span>

            <span class="n">solveNQueensHelper</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">queensPos</span><span class="o">,</span> <span class="n">occupied</span><span class="o">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

            <span class="n">occupied</span><span class="o">.</span><span class="na">clear</span><span class="o">(</span><span class="n">col</span><span class="o">);</span>
            <span class="n">occupied</span><span class="o">.</span><span class="na">clear</span><span class="o">(</span><span class="n">diag45</span><span class="o">);</span>
            <span class="n">occupied</span><span class="o">.</span><span class="na">clear</span><span class="o">(</span><span class="n">diag135</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">generateResultBoard</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">queensPos</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">queensPos</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="sc">'.'</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">q</span> <span class="o">:</span> <span class="n">queensPos</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">b</span><span class="o">[</span><span class="n">q</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'Q'</span><span class="o">;</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">b</span><span class="o">));</span>
            <span class="n">b</span><span class="o">[</span><span class="n">q</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'.'</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">;</span>
<span class="cm">/* 输入棋盘边长 n，返回所有合法的放置 */</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="nf">solveNQueens</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// '.' 表示空，'Q' 表示皇后，初始化空棋盘。</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="nf">board</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">string</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="sc">'.'</span><span class="o">));</span>
    <span class="n">backtrack</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span>
<span class="c1">// 选择列表：第 row 行的所有列都是放置皇后的选择</span>
<span class="c1">// 结束条件：row 超过 board 的最后一行</span>
<span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 触发结束条件</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">board</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">res</span><span class="o">.</span><span class="na">push_back</span><span class="o">(</span><span class="n">board</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">].</span><span class="na">size</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">col</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">// 排除不合法选择</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">isValid</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">))</span> <span class="k">continue</span><span class="o">;</span>
        <span class="c1">// 做选择</span>
        <span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'Q'</span><span class="o">;</span>
        <span class="c1">// 进入下一行决策</span>
        <span class="n">backtrack</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="c1">// 撤销选择</span>
        <span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'.'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/* 是否可以在 board[row][col] 放置皇后？ */</span>
<span class="n">bool</span> <span class="nf">isValid</span><span class="o">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">board</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="c1">// 检查列是否有皇后互相冲突</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'Q'</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 检查右上方是否有皇后互相冲突</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">--,</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'Q'</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 检查左上方是否有皇后互相冲突</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--,</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'Q'</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="78-subsets-子集中等">78. Subsets 子集（中等）</h3><p><a href="https://leetcode.com/problems/subsets/">78. Subsets</a></p><p>Given an integer array nums of unique elements, return all possible subsets (the power set).</p><p>The solution set must not contain duplicate subsets. Return the solution in any order.</p><p>Example 1: Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p><p>Example 2: Input: nums = [0] Output: [[],[0]]</p><ol><li>数学归纳 递归结构 Iterative<ol><li>[1,2,3] 的子集可以由 [1,2] 追加得出，[1,2] 的子集可以由 [1] 追加得出，base case 显然就是当输入集合为空集时，输出子集也就是一个空集。<li><code class="language-plaintext highlighter-rouge">subset([1,2,3]) = A + [A[i].add(3) for i = 1..len(A)]</code><li>The idea is simple. We go through the elements in the nums list. For each element, we loop over the current result list we have constructed so far. For each list in the result, we make a copy of this list and append the current element to it (it means picking the element). It is based on the same idea in backtracking (in each step you have choices: pick or not pick).<li>计算递归算法时间复杂度的方法<ol><li>递归深度 乘以 每次递归中迭代的次数<li>递归深度显然是 N，每次递归 for 循环的迭代次数取决于 res 的长度，并不是固定的。<li>res 的长度应该是每次递归都翻倍，所以说总的迭代次数应该是 2^N。<li>大小为 N 的集合的子集总共有几个？2^N 个<li>2^N 个子集是 push_back 添加进 res 的，所以要考虑 push_back 这个操作的效率：<li>总的时间复杂度就是 O(N*2^N)，还是比较耗时的。</ol><li>如果不计算储存返回结果所用的空间的，只需要 O(N) 的递归堆栈空间。如果计算 res 所需的空间，应该是 O(N*2^N)。</ol></ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Subsets.</span>
<span class="c1">// Memory Usage: 38.8 MB, less than 97.56% of Java online submissions for Subsets.</span>
<span class="cm">/**
 * Constant Space Iterative Solution

 * S(n) = (0 × (n C 0) + 1 × (n C 1) + 2 × (n C 2) + … + n × (n C n))
 * Note that (n C k) = (n C n-k). Therefore:
 * S(n) = 0 × (n C n) + 1 × (n C n-1) + 2 × (n C n-2) + … + n × (n C 0)
 * If we add these two together, we get
 * 2S(n) = n × (n C 0) + n × (n C 1) + … + n × (n C n)
  *   = n × (n C 0 + n C 1 + … + n C n)
 * As per binomial theorem, (n C 0 + n C 1 + … + n C n) = 2^n, so
 * 2*S(n) = n * 2^n =&gt; S(n) = n * 2^(n-1)
 *
 * Time Complexity: O(S(N) + n C 0) = O(N * 2^(N-1) + 1) = O(N * 2^N)
 *
 * Space Complexity: O(1) (Excluding the result space)
 *
 * N = Length of input nums array
 */</span>
<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">subsets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Arrays.sort(nums); // make sure subsets are ordered, not needed</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span> <span class="c1">// start with empty set</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// remember</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">subset</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span> <span class="c1">// copy a new one</span>
            <span class="n">subset</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// expand</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">subset</span><span class="o">);</span> <span class="c1">// collect</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Subsets.</span>
<span class="c1">// Memory Usage: 39.2 MB, less than 77.10% of Java online submissions for Subsets.</span>
<span class="c1">// Time: O(N * 2^N)</span>
<span class="c1">// The outer loop takes O(N) time.</span>
<span class="c1">// The inner loop takes 2, 4, 8, ..., 2^N time respectively.</span>
<span class="c1">// In inner loop, making a new copy of L takes at most O(N) time.</span>
<span class="c1">// Total runtime T(N) = N * (2 + 4 + 8 + ... + 2^N) ~= N * 2^N</span>
<span class="c1">// Space: O(N * 2^N)</span>
<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">subsets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>  <span class="c1">// empty set</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">subres</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span> <span class="c1">// used for new lists</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="no">L</span> <span class="o">:</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
      <span class="no">L</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="no">L</span><span class="o">);</span> <span class="c1">// copy</span>
      <span class="no">L</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
      <span class="n">subres</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="no">L</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">result</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">subres</span><span class="o">);</span>  <span class="c1">// concatenate</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>backtracking</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 21.39% of Java online submissions for Subsets.</span>
<span class="c1">// Memory Usage: 40 MB, less than 20.20% of Java online submissions for Subsets.</span>
<span class="cm">/**
 * Backtracking (Recursion)
 *
 * Time Complexity: O(N * 2 ^ N) Refer to above explanation
 *
 * Space Complexity: O(N) (Recursion Depth + TempList)
 *
 * N = Length of input nums array
 */</span>
<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">subsets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
    <span class="n">backtrack</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(),</span> <span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">list</span> <span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tempList</span><span class="o">,</span> <span class="kt">int</span> <span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">){</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">tempList</span><span class="o">));</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="n">tempList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="n">backtrack</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">tempList</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">tempList</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">tempList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="c1">// Runtime: 1 ms, faster than 60.07% of Java online submissions for Subsets.</span>
<span class="c1">// Memory Usage: 39.9 MB, less than 20.20% of Java online submissions for Subsets.</span>
<span class="c1">// Time: O(N * 2^N) since the recurrence is T(N) = 2T(N - 1) and we also spend at most O(N) time within a call.</span>
<span class="c1">// Space: O(N * 2^N) since there are 2^N subsets. If we only print the result, we just need O(N) space.</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">numList</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">offset</span><span class="o">];</span>
  <span class="c1">// pick</span>
  <span class="c1">// add to result</span>
  <span class="n">numList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
  <span class="n">subsets</span><span class="o">(</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">numList</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
  <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">numList</span><span class="o">));</span>
  <span class="c1">// not pick</span>
  <span class="n">numList</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">numList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
  <span class="n">subsets</span><span class="o">(</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">numList</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
<span class="o">}</span>

</pre></table></code></div></div><hr /><h3 id="90-subsets-ii">90. Subsets II</h3><p><a href="https://leetcode.com/problems/subsets-ii/">90. Subsets II</a> Given an integer array nums that may contain duplicates, return all possible subsets (the power set).</p><p>The solution set must not contain duplicate subsets. Return the solution in any order.</p><p>Example 1:</p><p>Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]</p><p>https://leetcode.com/problems/subsets-ii/discuss/388566/Subsets-I-and-II-Java-Solution-with-Detailed-Explanation-and-Comments-(Recursion-and-Iteration)</p><ol><li>iteration</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 43.93% of Java online submissions for Subsets II.</span>
<span class="c1">// Memory Usage: 40.9 MB, less than 11.52% of Java online submissions for Subsets II.</span>
<span class="c1">// Time: O(N * 2^N)</span>
<span class="c1">// Space: O(N * 2^N)</span>
<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">subsetsWithDup</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// sort</span>
  <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>  <span class="c1">// empty set</span>

  <span class="kt">int</span> <span class="n">cachedSize</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">startIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">subres</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>  <span class="c1">// used for new lists</span>
    <span class="c1">// set startIdx first before we update cachedSize</span>
    <span class="n">startIdx</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">?</span> <span class="n">cachedSize</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// if duplicate occurs</span>
    <span class="n">cachedSize</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="c1">// cache the size for startIdx in the next round</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">startIdx</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="no">L</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
      <span class="no">L</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="no">L</span><span class="o">);</span>  <span class="c1">// copy</span>
      <span class="no">L</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
      <span class="n">subres</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="no">L</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">res</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">subres</span><span class="o">);</span>  <span class="c1">// concatenate</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>Backtracking</ol><p>The information of whether it picks or not could be passed down by a boolean parameter isPicked.</p><p>If the above condition is satisfied:</p><p>Do not add the list to the result list. Do not do the subproblem after picking the current element. Only do the subproblem after not picking the current element.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">subsetsWithDup</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// sorting</span>
  <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">numList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
  <span class="n">subsets</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">numList</span><span class="o">,</span> <span class="n">result</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">subsets</span><span class="o">(</span><span class="kt">int</span> <span class="n">offset</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">numList</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isPicked</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// base case</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">offset</span><span class="o">];</span>
  <span class="c1">// duplicate checking (convert &amp;&amp; to ||)</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nums</span><span class="o">[</span><span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">offset</span><span class="o">]</span> <span class="o">||</span> <span class="n">isPicked</span> <span class="o">==</span> <span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// pick</span>
    <span class="n">numList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
    <span class="n">subsets</span><span class="o">(</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">numList</span><span class="o">,</span> <span class="n">result</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">numList</span><span class="o">));</span>  <span class="c1">// add to the result list</span>
    <span class="n">numList</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">numList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="c1">// not pick</span>
  <span class="n">subsets</span><span class="o">(</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">numList</span><span class="o">,</span> <span class="n">result</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>


<span class="c1">// Time: O(N * 2^N)</span>
<span class="c1">// Space: O(N * 2^N)</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">subsets</span><span class="o">(</span><span class="kt">int</span> <span class="n">offset</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">numList</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isPicked</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// base case</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">offset</span><span class="o">];</span>
  <span class="c1">// not pick</span>
  <span class="n">subsets</span><span class="o">(</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">numList</span><span class="o">,</span> <span class="n">result</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
  <span class="c1">// duplicate check</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">offset</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">isPicked</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
  <span class="c1">// pick</span>
  <span class="n">numList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
  <span class="n">subsets</span><span class="o">(</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">numList</span><span class="o">,</span> <span class="n">result</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
  <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">numList</span><span class="o">));</span>  <span class="c1">// add to the result list</span>
  <span class="n">numList</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">numList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="77-combinations">77. Combinations</h3><p><a href="https://leetcode.com/problems/combinations/">77. Combinations</a></p><p>Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].</p><p>You may return the answer in any order.</p><p>Example 1:</p><p>Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]</p><ol><li>backtracking 典型的回溯算法，<ol><li>k 限制了树的高度，n 限制了树的宽度，<li>直接套我们以前讲过的回溯算法模板框架就行了：</ol></ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 17 ms, faster than 68.79% of Java online submissions for Combinations.</span>
<span class="c1">// Memory Usage: 41.6 MB, less than 35.55% of Java online submissions for Combinations.</span>
<span class="cm">/**
 * Backtracking (Recursive Solution)
 *
 * Time complexity = InternalNodes in the RecursionTree   +   K * LeafNodes in RecursionTree
  *             = (C(N,0) + C(N,1) + ... + C(N,K-1))   +   K * C(N,K)
 *
 * Space Complexity = O(K) -&gt; Depth of Recursion tree + Size of TempList
 *
 * N, K -&gt; Input numbers.
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">combine</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="o">||</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;());</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">backtracking</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(),</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">backtracking</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">,</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">curr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">size</span><span class="o">()==</span><span class="n">k</span><span class="o">)</span> <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">(</span><span class="n">curr</span><span class="o">));</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">start</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">.</span><span class="na">size</span><span class="o">()&lt;</span><span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">backtracking</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">curr</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>



<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">combine</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">backtracking</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(),</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">backtracking</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span><span class="n">res</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">combs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(</span><span class="n">comb</span><span class="o">));</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">start</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">comb</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
			<span class="n">combine</span><span class="o">(</span><span class="n">combs</span><span class="o">,</span> <span class="n">comb</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
			<span class="n">comb</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">comb</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
		<span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>


</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 7 ms, faster than 84.10% of Java online submissions for Combinations.</span>
<span class="c1">// Memory Usage: 52.6 MB, less than 14.45% of Java online submissions for Combinations.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">combine</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="o">||</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"invalid input"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;());</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Case I: Add number n to answer</span>
        <span class="c1">// Add current element to final solution combine(n-1, k-1)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">combine</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">:</span> <span class="n">result</span><span class="o">)</span> <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="c1">// Case II: Do not add number n to answer</span>
        <span class="n">result</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">combine</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h1 id="功能">功能</h1><hr /><h2 id="设计朋友圈时间线">设计朋友圈时间线</h2><p><img data-proofer-ignore data-src="https://i.imgur.com/FA6dYX3.png" alt="design" /></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 9 ms, faster than 75.98% of Java online submissions for Design Twitter.</span>
<span class="c1">// Memory Usage: 37.5 MB, less than 44.43% of Java online submissions for Design Twitter.</span>

<span class="kd">class</span> <span class="nc">Twitter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">timestamp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Tweet</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">time</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">Tweet</span> <span class="n">next</span><span class="o">;</span>

        <span class="c1">// 需要传入推文内容（id）和发文时间</span>
        <span class="kd">public</span> <span class="nf">Tweet</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="kt">int</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">followed</span><span class="o">;</span>
        <span class="c1">// 用户发表的推文链表头结点</span>
        <span class="kd">public</span> <span class="nc">Tweet</span> <span class="n">head</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="kt">int</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">followed</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
            <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">userId</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="c1">// 关注一下自己</span>
            <span class="n">follow</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">follow</span><span class="o">(</span><span class="kt">int</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">followed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">userId</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unfollow</span><span class="o">(</span><span class="kt">int</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 不可以取关自己</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">userId</span> <span class="o">!=</span> <span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">)</span>
                <span class="n">followed</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">userId</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">post</span><span class="o">(</span><span class="kt">int</span> <span class="n">tweetId</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Tweet</span> <span class="n">twt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Tweet</span><span class="o">(</span><span class="n">tweetId</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">);</span>
            <span class="n">timestamp</span><span class="o">++;</span>
            <span class="c1">// 将新建的推文插入链表头</span>
            <span class="c1">// 越靠前的推文 time 值越大</span>
            <span class="n">twt</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">twt</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 我们需要一个映射将 userId 和 User 对象对应起来</span>
    <span class="kd">private</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">User</span><span class="o">&gt;</span> <span class="n">userMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="cm">/** user 发表一条 tweet 动态 */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postTweet</span><span class="o">(</span><span class="kt">int</span> <span class="n">userId</span><span class="o">,</span> <span class="kt">int</span> <span class="n">tweetId</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 若 userId 不存在，则新建</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">userMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">userId</span><span class="o">))</span>
            <span class="n">userMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="n">userId</span><span class="o">));</span>
        <span class="nc">User</span> <span class="n">u</span> <span class="o">=</span> <span class="n">userMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">userId</span><span class="o">);</span>
        <span class="n">u</span><span class="o">.</span><span class="na">post</span><span class="o">(</span><span class="n">tweetId</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/** follower 关注 followee */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">follow</span><span class="o">(</span><span class="kt">int</span> <span class="n">followerId</span><span class="o">,</span> <span class="kt">int</span> <span class="n">followeeId</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 若 follower 不存在，则新建</span>
		<span class="k">if</span><span class="o">(!</span><span class="n">userMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">followerId</span><span class="o">)){</span>
			<span class="nc">User</span> <span class="n">u</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="n">followerId</span><span class="o">);</span>
			<span class="n">userMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">followerId</span><span class="o">,</span> <span class="n">u</span><span class="o">);</span>
		<span class="o">}</span>
        <span class="c1">// 若 followee 不存在，则新建</span>
		<span class="k">if</span><span class="o">(!</span><span class="n">userMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">followeeId</span><span class="o">)){</span>
			<span class="nc">User</span> <span class="n">u</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="n">followeeId</span><span class="o">);</span>
			<span class="n">userMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">followeeId</span><span class="o">,</span> <span class="n">u</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="n">userMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">followerId</span><span class="o">).</span><span class="na">follow</span><span class="o">(</span><span class="n">followeeId</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/** follower 取关 followee，如果 Id 不存在则什么都不做 */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unfollow</span><span class="o">(</span><span class="kt">int</span> <span class="n">followerId</span><span class="o">,</span> <span class="kt">int</span> <span class="n">followeeId</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">userMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">followerId</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">User</span> <span class="n">flwer</span> <span class="o">=</span> <span class="n">userMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">followerId</span><span class="o">);</span>
            <span class="n">flwer</span><span class="o">.</span><span class="na">unfollow</span><span class="o">(</span><span class="n">followeeId</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/** 返回该 user 关注的人（包括他自己）最近的动态 id，
    最多 10 条，而且这些动态必须按从新到旧的时间线顺序排列。*/</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">getNewsFeed</span><span class="o">(</span><span class="kt">int</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">userMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">userId</span><span class="o">))</span> <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="c1">// 关注列表的用户 Id</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="n">userMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">userId</span><span class="o">).</span><span class="na">followed</span><span class="o">;</span>
        <span class="c1">// 自动通过 time 属性从大到小排序，容量为 users 的大小</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Tweet</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span>
            <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="n">users</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)-&gt;(</span><span class="n">b</span><span class="o">.</span><span class="na">time</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="na">time</span><span class="o">));</span>

        <span class="c1">// 先将所有链表头节点插入优先级队列</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">id</span> <span class="o">:</span> <span class="n">users</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Tweet</span> <span class="n">twt</span> <span class="o">=</span> <span class="n">userMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">id</span><span class="o">).</span><span class="na">head</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">twt</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">twt</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 最多返回 10 条就够了</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="c1">// 弹出 time 值最大的（最近发表的）</span>
            <span class="nc">Tweet</span> <span class="n">twt</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">twt</span><span class="o">.</span><span class="na">id</span><span class="o">);</span>
            <span class="c1">// 将下一篇 Tweet 插入进行排序</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">twt</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">pq</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">twt</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><hr /><h1 id="-map">🔒🔒 Map</h1><h2 id="application">Application</h2><h3 id="application-counting-word-frequencies">Application: Counting Word Frequencies</h3><ul><li>begin with an empty map, mapping words to their integer frequencies.<li>first scan through the input, considering adjacent alphabetic characters to be words, which we then convert to lowercase.<li>For each word found, we attempt to retrieve its current frequency from the map using the get method, with a yet unseen word having frequency zero.<li>We then (re)set its frequency to be one more to reflect the current occurrence of the word.<li>After processing the entire input, we loop through the entrySet() of the map to determine which word has the most occurrences.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordCount</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ChainHashMap</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Scanner</span> <span class="n">doc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">).</span><span class="na">useDelimiter</span><span class="o">(</span><span class="s">"[^a-zA-Z]+"</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(</span><span class="n">doc</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
            <span class="nc">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="na">next</span><span class="o">().</span><span class="na">toLowerCase</span><span class="o">();</span>
            <span class="nc">Integer</span> <span class="n">count</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
            <span class="n">freq</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">++);</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">maxWord</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">ent</span> <span class="o">:</span> <span class="n">freq</span><span class="o">.</span><span class="na">entrySet</span><span class="o">()){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ent</span><span class="o">.</span><span class="na">getValue</span><span class="o">()&gt;</span><span class="n">maxCount</span><span class="o">){</span>
                <span class="n">maxWord</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="na">getKet</span><span class="o">();</span>
                <span class="n">maxCount</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"The most frequent word is '"</span> <span class="o">+</span> <span class="n">maxWord</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"' with "</span> <span class="o">+</span> <span class="n">maxCount</span> <span class="o">+</span> <span class="s">" occurrences."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><hr /><h1 id="-动态规划">🔒🔒 动态规划</h1><p>求解动态规划的核心问题是穷举。</p><ul><li>动态规划的穷举 存在「重叠子问题」如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。<ul><li>穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」，才能正确地穷举。</ul><li>而且，动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。</ul><p>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义。</p><hr /><h2 id="-动态规划-1">🔒 动态规划</h2><hr /><h3 id="斐波那契数列">斐波那契数列</h3><p><a href="https://leetcode.com/problems/fibonacci-number/">509. Fibonacci Number</a></p><p>The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,</p><p>F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n &gt; 1. Given n, calculate F(n).</p><p>Example 1:</p><p>Input: n = 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</p><ol><li>暴力递归</ol><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。</p><p>这就是动态规划问题的第一个性质：重叠子问题。下面，我们想办法解决这个问题。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">fib</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="no">N</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="nf">fib</span><span class="o">(</span><span class="no">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fib</span><span class="o">(</span><span class="no">N</span> <span class="o">-</span> <span class="mi">2</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>带备忘录的递归解法 时间复杂度是 O(n)</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Fibonacci Number.</span>
<span class="c1">// Memory Usage: 37.3 MB, less than 26.68% of Java online submissions for Fibonacci Number.</span>


<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">fib</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 备忘录全初始化为 0</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span> <span class="n">n</span><span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="c1">// 进行带备忘录的递归</span>
        <span class="k">return</span> <span class="nf">helper</span><span class="o">(</span><span class="n">memo</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">helper</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">memo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// base case</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">n</span><span class="o">;</span>

        <span class="c1">// 已经计算过，不用再计算了</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="n">memo</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="n">helper</span><span class="o">(</span><span class="n">memo</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">helper</span><span class="o">(</span><span class="n">memo</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>dp 数组的迭代解法</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Fibonacci Number.</span>
<span class="c1">// Memory Usage: 37.3 MB, less than 26.68% of Java online submissions for Fibonacci Number.</span>

<span class="kt">int</span> <span class="nf">fib</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

    <span class="c1">// base case</span>
    <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

    <span class="c1">// 状态转移</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="o">];</span>
    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
<span class="o">}</span>

</pre></table></code></div></div><ol><li>状态压缩 pre+cur</ol><p>能够使用状态压缩技巧的动态规划都是二维 dp 问题，你看它的状态转移方程，如果计算状态 dp[i][j] 需要的都是 dp[i][j] 相邻的状态，那么就可以使用状态压缩技巧，将二维的 dp 数组转化成一维，将空间复杂度从 O(N^2) 降低到 O(N)。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">fib</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">+</span> <span class="n">curr</span><span class="o">;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">curr</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="动态规划解法">动态规划解法</h2><hr /><h3 id="322-coin-change-凑零钱--for-i-for-coin-dpi--mathmindpi-dpi-coin1">322. Coin Change 凑零钱 ` for i, for coin, dp[i] = Math.min(dp[i], dp[i-coin]+1);`</h3><p><a href="https://leetcode.com/problems/coin-change/">322. Coin Change</a></p><p>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.</p><p>Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p><p>You may assume that you have an infinite number of each kind of coin.</p><p>Example 1:</p><p>Input: coins = [1,2,5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1</p><ol><li>从小到大，<ol><li>5=coin(4)+1</ol></ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 28 ms, faster than 33.57% of Java online submissions for Coin Change.</span>
<span class="c1">// Memory Usage: 41.4 MB, less than 30.06% of Java online submissions for Coin Change.</span>
<span class="c1">// Performance:</span>
<span class="c1">// time: O(n * m), n is the amount, m is n of coins</span>
<span class="c1">// memory: O(n), n is the amount</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">subCoin</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">subCoin</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">subCoin</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">amount</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="kt">int</span> <span class="n">minC</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">coin:</span><span class="n">coins</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">coin</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">rest</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">subCoin</span><span class="o">[</span><span class="n">rest</span><span class="o">]</span> <span class="o">==-</span><span class="mi">1</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
            <span class="n">minC</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minC</span><span class="o">,</span> <span class="n">subCoin</span><span class="o">[</span><span class="n">rest</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">minC</span><span class="o">==</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
        <span class="n">subCoin</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">minC</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">subCoin</span><span class="o">[</span><span class="n">amount</span><span class="o">];</span>
<span class="o">}</span>

</pre></table></code></div></div><h4 id="暴力解法-1">暴力解法</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">dp</span><span class="o">(</span><span class="n">coins</span><span class="o">,</span> <span class="n">amount</span><span class="o">)</span>
<span class="o">}</span>
<span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">coin</span> <span class="o">:</span> <span class="n">coins</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 计算子问题的结果</span>
        <span class="kt">int</span> <span class="n">subProblem</span> <span class="o">=</span> <span class="n">dp</span><span class="o">(</span><span class="n">coins</span><span class="o">,</span> <span class="n">amount</span> <span class="o">-</span> <span class="n">coin</span><span class="o">);</span>
        <span class="c1">// 子问题无解则跳过</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">subProblem</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
        <span class="c1">// 在子问题中选择最优解，然后加一</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">subProblem</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="best-带备忘录的递归">best 带备忘录的递归</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[]</span> <span class="n">memo</span><span class="o">;</span>
<span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="c1">// dp 数组全都初始化为特殊值</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">memo</span><span class="o">,</span> <span class="o">-</span><span class="mi">666</span><span class="o">);</span>
    <span class="k">return</span> <span class="nf">dp</span><span class="o">(</span><span class="n">coins</span><span class="o">,</span> <span class="n">amount</span><span class="o">);</span>
<span class="o">}</span>
<span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="c1">// 查备忘录，防止重复计算</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">amount</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">666</span><span class="o">)</span> <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">amount</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">coin</span> <span class="o">:</span> <span class="n">coins</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 计算子问题的结果</span>
        <span class="kt">int</span> <span class="n">subProblem</span> <span class="o">=</span> <span class="n">dp</span><span class="o">(</span><span class="n">coins</span><span class="o">,</span> <span class="n">amount</span> <span class="o">-</span> <span class="n">coin</span><span class="o">);</span>
        <span class="c1">// 子问题无解则跳过</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">subProblem</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
        <span class="c1">// 在子问题中选择最优解，然后加一</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">subProblem</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 把计算结果存入备忘录</span>
    <span class="n">memo</span><span class="o">[</span><span class="n">amount</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">res</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">res</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">amount</span><span class="o">];</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="dp-数组的迭代解法">dp 数组的迭代解法</h4><p>自底向上使用 dp table 来消除重叠子问题</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 12 ms, faster than 79.68% of Java online submissions for Coin Change.</span>
<span class="c1">// Memory Usage: 38.5 MB, less than 70.58% of Java online submissions for Coin Change.</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">amount</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">coin:</span><span class="n">coins</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">coin</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">coin</span><span class="o">]+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">amount</span><span class="o">]&gt;</span><span class="n">amount</span><span class="o">?</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">dp</span><span class="o">[</span><span class="n">amount</span><span class="o">];</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="983-minimum-cost-for-tickets-medium">983. Minimum Cost For Tickets (Medium)</h4><p><a href="https://leetcode.com/problems/minimum-cost-for-tickets/">983. Minimum Cost For Tickets</a></p><p>You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.</p><p>Train tickets are sold in three different ways:</p><p>a 1-day pass is sold for costs[0] dollars, a 7-day pass is sold for costs[1] dollars, and a 30-day pass is sold for costs[2] dollars. The passes allow that many days of consecutive travel.</p><p>For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days.</p><p>Example 1:</p><p>Input: days = [1,4,6,7,8,20], costs = [2,7,15] Output: 11 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1. On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, …, 9. On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20. In total, you spent $11 and covered all the days of your travel.</p><h4 id="bottom-up-dp">bottom-up dp</h4><div class="table-wrapper"><table><tbody><tr><td>O(N) Time<td>O(N) Space</table></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 81.07% of Java online submissions for Minimum Cost For Tickets.</span>
<span class="c1">// Memory Usage: 36.9 MB, less than 65.32% of Java online submissions for Minimum Cost For Tickets.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">mincostTickets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">days</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">costs</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">366</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span> <span class="c1">//no days to travel, no need to spend</span>
        <span class="k">return</span> <span class="nf">dp</span><span class="o">(</span><span class="n">days</span><span class="o">,</span> <span class="n">costs</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">days</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">costs</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">365</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">&gt;=</span><span class="n">days</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span> <span class="c1">//when we are done with our travel days we break.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">days</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// if the day is not a travel day, put the previous day cost.</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">costs</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">i</span><span class="o">-</span><span class="mi">7</span><span class="o">)]+</span> <span class="n">costs</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">i</span><span class="o">-</span><span class="mi">30</span><span class="o">)]+</span> <span class="n">costs</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">days</span><span class="o">[</span><span class="n">days</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="memoization">Memoization</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 81.07% of Java online submissions for Minimum Cost For Tickets.</span>
<span class="c1">// Memory Usage: 36.9 MB, less than 65.32% of Java online submissions for Minimum Cost For Tickets.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">mincostTickets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">days</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">costs</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">366</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span> <span class="c1">//no days to travel, no need to spend</span>
        <span class="k">return</span> <span class="nf">dp</span><span class="o">(</span><span class="n">days</span><span class="o">,</span> <span class="n">costs</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">days</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">costs</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">365</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">&gt;=</span><span class="n">days</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span> <span class="c1">//when we are done with our travel days we break.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">days</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// if the day is not a travel day, put the previous day cost.</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">costs</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">i</span><span class="o">-</span><span class="mi">7</span><span class="o">)]+</span> <span class="n">costs</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">i</span><span class="o">-</span><span class="mi">30</span><span class="o">)]+</span> <span class="n">costs</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">days</span><span class="o">[</span><span class="n">days</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="64-minimum-path-sum-最小路径和中等">64. Minimum Path Sum 最小路径和（中等）</h3><p><a href="https://leetcode.com/problems/minimum-path-sum/">64. Minimum Path Sum</a></p><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p><p>Note: You can only move either down or right at any point in time.</p><ol><li>自顶向下动态规划解法 <code class="language-plaintext highlighter-rouge">int[][] memo, memo[i][j] = Math.min( dp(grid, i - 1, j), dp(grid, i, j - 1) ) + grid[i][j];)</code><ol><li>时间复杂度和空间复杂度都是 <code class="language-plaintext highlighter-rouge">O(MN)</code>，标准的自顶向下动态规划解法。<li>一般来说，让你在二维矩阵中求最优化问题（最大值或者最小值），肯定需要递归 + 备忘录，也就是动态规划技巧。<li>从 D 走到 A 的最小路径和是 6，而从 D 走到 C 的最小路径和是 8，6 小于 8，所以一定要从 A 走到 B 才能使路径和最小。<li>我们把「从 D 走到 B 的最小路径和」这个问题转化成了<li>「从 D 走到 A 的最小路径和」和 「从 D 走到 C 的最小路径和」这两个问题。<li>从左上角位置 (0, 0) 走到位置 (i, j) 的最小路径和为 dp(grid, i, j)。<li>dp(grid, i, j) 的值取决于 dp(grid, i - 1, j) 和 dp(grid, i, j - 1) 返回的值。</ol></ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 84.10% of Java online submissions for Minimum Path Sum.</span>
<span class="c1">// Memory Usage: 43 MB, less than 19.44% of Java online submissions for Minimum Path Sum.</span>

<span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span><span class="o">;</span>

<span class="kt">int</span> <span class="nf">minPathSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">row:</span><span class="n">memo</span><span class="o">)</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="c1">// 计算从左上角走到右下角的最小路径和</span>
    <span class="k">return</span> <span class="nf">dp</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// base case</span>
    <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>

    <span class="c1">// 如果索引出界，返回一个很大的值，</span>
    <span class="c1">// 保证在取 min 的时候不会被取到</span>
    <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

    <span class="k">if</span><span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]!=-</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>

    <span class="c1">// 左边和上面的最小路径和加上 grid[i][j]</span>
    <span class="c1">// 就是到达 (i, j) 的最小路径和</span>
    <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span>
        <span class="n">dp</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">),</span>
        <span class="n">dp</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">)</span> <span class="o">+</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>

    <span class="k">return</span>  <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>重叠子问题, 自底向上的迭代解法 <code class="language-plaintext highlighter-rouge">int[][] memo, memo[i][j] = Math.min(memo[i-1][j], memo[i][j-1] ) + grid[i][j];)</code></ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 4 ms, faster than 21.15% of Java online submissions for Minimum Path Sum.</span>
<span class="c1">// Memory Usage: 43 MB, less than 19.44% of Java online submissions for Minimum Path Sum.</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">minPathSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

    <span class="n">memo</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>

    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="n">memo</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">memo</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>

    <span class="c1">// 状态转移</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span>
                <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span>
                <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>
            <span class="o">)</span> <span class="o">+</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="931-minimum-falling-path-sum-下降路径最小和">931. Minimum Falling Path Sum 下降路径最小和</h3><p><a href="https://leetcode.com/problems/minimum-falling-path-sum/">931. Minimum Falling Path Sum</a></p><p>Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.</p><p>A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).</p><ol><li>暴力穷举解法</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">minFallingPathSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="c1">// 终点可能在最后一行的任意一列</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">dp</span><span class="o">(</span><span class="n">matrix</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 非法索引检查</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
        <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span>
        <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 返回一个特殊值</span>
        <span class="k">return</span> <span class="mi">99999</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>

    <span class="c1">// 状态转移</span>
    <span class="k">return</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">min</span><span class="o">(</span>
            <span class="n">dp</span><span class="o">(</span><span class="n">matrix</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">),</span>
            <span class="n">dp</span><span class="o">(</span><span class="n">matrix</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">),</span>
            <span class="n">dp</span><span class="o">(</span><span class="n">matrix</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
        <span class="o">);</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="nf">min</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>
<span class="o">}</span>

</pre></table></code></div></div><ol><li>用备忘录的方法消除重叠子问题</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 3 ms, faster than 84.22% of Java online submissions for Minimum Falling Path Sum.</span>
<span class="c1">// Memory Usage: 45 MB, less than 5.34% of Java online submissions for Minimum Falling Path Sum.</span>

<span class="c1">// 备忘录</span>
<span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span><span class="o">;</span>

<span class="kt">int</span> <span class="nf">minFallingPathSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="c1">// 备忘录里的值初始化为 66666</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">66666</span><span class="o">);</span>
    <span class="c1">// 终点可能在 matrix[n-1] 的任意一列</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">dp</span><span class="o">(</span><span class="n">matrix</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 1、索引合法性检查</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
        <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span>
        <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">99999</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 2、base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>

    <span class="c1">// 3、查找备忘录，防止重复计算</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">66666</span><span class="o">)</span> <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>

    <span class="c1">// 进行状态转移</span>
    <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">min</span><span class="o">(</span>
        <span class="n">dp</span><span class="o">(</span><span class="n">matrix</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">),</span>
        <span class="n">dp</span><span class="o">(</span><span class="n">matrix</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">),</span>
        <span class="n">dp</span><span class="o">(</span><span class="n">matrix</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">);</span>
    <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="nf">min</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="174-dungeon-game-地下城游戏-">174. Dungeon Game 地下城游戏 ????????????</h3><p><a href="https://leetcode.com/problems/dungeon-game/">174. Dungeon Game</a></p><p>The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess.</p><p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p><p>Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight’s health (represented by positive integers).</p><p>To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p><p>Return the knight’s minimum initial health so that he can rescue the princess.</p><p>Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="cm">/* 主函数 */</span>
<span class="kt">int</span> <span class="nf">calculateMinimumHP</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
    <span class="c1">// 备忘录中都初始化为 -1</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">memo</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="nf">dp</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 备忘录，消除重叠子问题</span>
<span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span><span class="o">;</span>

<span class="cm">/* 定义：从 (i, j) 到达右下角，需要的初始血量至少是多少 */</span>
<span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
    <span class="c1">// base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="c1">// 避免重复计算</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
    <span class="c1">// 状态转移逻辑</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span>
            <span class="n">dp</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">),</span>
            <span class="n">dp</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span>
        <span class="o">)</span> <span class="o">-</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
    <span class="c1">// 骑士的生命值至少为 1</span>
    <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">res</span><span class="o">;</span>

    <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="514-freedom-trail-自由之路困难">514. Freedom Trail 自由之路（困难）??????</h3><p><a href="https://leetcode.com/problems/freedom-trail/">514. Freedom Trail</a></p><p>In the video game Fallout 4, the quest “Road to Freedom” requires players to reach a metal dial called the “Freedom Trail Ring” and use the dial to spell a specific keyword to open the door.</p><p>Given a string ring that represents the code engraved on the outer ring and another string key that represents the keyword that needs to be spelled, return the minimum number of steps to spell all the characters in the keyword.</p><p>Initially, the first character of the ring is aligned at the “12:00” direction. You should spell all the characters in key one by one by rotating ring clockwise or anticlockwise to make each character of the string key aligned at the “12:00” direction and then by pressing the center button.</p><p>At the stage of rotating the ring to spell the key character key[i]:</p><p>You can rotate the ring clockwise or anticlockwise by one place, which counts as one step. The final purpose of the rotation is to align one of ring’s characters at the “12:00” direction, where this character must equal key[i]. If the character key[i] has been aligned at the “12:00” direction, press the center button to spell, which also counts as one step. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.</p><p>Example 1: Input: ring = “godding”, key = “gd” Output: 4 Explanation: For the first key character ‘g’, since it is already in place, we just need 1 step to spell this character. For the second key character ‘d’, we need to rotate the ring “godding” anticlockwise by two steps to make it become “ddinggo”. Also, we need 1 more step for spelling. So the final output is 4. Example 2: Input: ring = “godding”, key = “godding” Output: 13</p><ul><li>遇到求最值的问题，基本都是由动态规划算法来解决，<li>动态规划本身就是运筹优化算法的一种<li>状态是什么？状态就是「下一个需要弹奏的音符」和「当前的手的状态」。<li>选择是什么？选择就是「下一个音符应该由哪个手指头来弹」，无非就是穷举五个手指头。结合当前手的状态，做出每个选择需要对应代价的，刚才说过这个代价是因人而异的，所以我需要给自己定制一个损失函数，计算不同指法切换的「别扭程度」。<li><p>现在的问题就变成了一个标准的动态规划问题，根据损失函数做出「别扭程度」最小的选择，使得整段演奏最流畅……</p><li>题目给你输入一个字符串 ring 代表圆盘上的字符（指针位置在 12 点钟方向，初始指向 ring[0]），再输入一个字符串 key 代表你需要拨动圆盘输入的字符串，你的算法需要返回输入这个 key 至少进行多少次操作（拨动一格圆盘和按下圆盘中间的按钮都算是一次操作）。<li>原题可以转化为：圆盘固定，我们可以拨动指针；现在需要我们拨动指针并按下按钮，以最少的操作次数输入 key 对应的字符串。<li>「状态」就是「当前需要输入的字符」和「当前圆盘指针的位置」。<li>「状态」就是 i 和 j 两个变量。<li>用 i 表示当前圆盘上指针指向的字符（也就是 ring[i]）；<li>用 j 表示需要输入的字符（也就是 key[j]）。<li>当圆盘指针指向 ring[i] 时，输入字符串 key[j..] 至少需要 dp(ring, i, key, j) 次操作。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">findRotateSteps</span><span class="o">(</span><span class="nc">String</span> <span class="n">ring</span><span class="o">,</span> <span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">ring</span><span class="o">.</span><span class="na">length</span><span class="o">()][</span><span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
    <span class="c1">// the first key is the position on the ring we are on, the second is how many letters we have completed!</span>
    <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">ring</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// pos represents the pos of the ring we are sitting on, and the steps represents how many letters we've gone through</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">String</span> <span class="n">ring</span><span class="o">,</span> <span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="o">,</span> <span class="kt">int</span> <span class="n">steps</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// have we already analyzed one path? -- no point moving further left or right from this position</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">pos</span><span class="o">][</span><span class="n">steps</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">pos</span><span class="o">][</span><span class="n">steps</span><span class="o">];</span>

    <span class="kt">boolean</span> <span class="n">clockWise</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">counterClockWise</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">clockSteps</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span> <span class="n">counterClockSteps</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">curr</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">pos</span><span class="o">)</span> <span class="o">%</span> <span class="n">n</span><span class="o">;</span> <span class="c1">// handles loop</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">clockWise</span> <span class="o">&amp;&amp;</span> <span class="n">ring</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">curr</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">steps</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">clockSteps</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dfs</span><span class="o">(</span><span class="n">ring</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">curr</span><span class="o">,</span> <span class="n">steps</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">clockWise</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">curr2</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">curr2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">curr2</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span> <span class="c1">// every position we are negative is one off of the length!</span>

        <span class="k">if</span> <span class="o">(!</span><span class="n">counterClockWise</span> <span class="o">&amp;&amp;</span> <span class="n">ring</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">curr2</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">steps</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">counterClockSteps</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dfs</span><span class="o">(</span><span class="n">ring</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">curr2</span><span class="o">,</span> <span class="n">steps</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">counterClockWise</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">clockWise</span> <span class="o">&amp;&amp;</span> <span class="n">counterClockWise</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">memo</span><span class="o">[</span><span class="n">pos</span><span class="o">][</span><span class="n">steps</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">clockSteps</span><span class="o">,</span> <span class="n">counterClockSteps</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// +1 to click the button</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="c1">// 字符 -&gt; 索引列表</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">charToIndex</span><span class="o">;</span>
<span class="c1">// 备忘录</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">memo</span><span class="o">;</span>

<span class="cm">/* 主函数 */</span>
<span class="kt">int</span> <span class="nf">findRotateSteps</span><span class="o">(</span><span class="n">string</span> <span class="n">ring</span><span class="o">,</span> <span class="n">string</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="c1">// 备忘录全部初始化为 0</span>
    <span class="n">memo</span><span class="o">.</span><span class="na">resize</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;(</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
    <span class="c1">// 记录圆环上字符到索引的映射</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ring</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">charToIndex</span><span class="o">[</span><span class="n">ring</span><span class="o">[</span><span class="n">i</span><span class="o">]].</span><span class="na">push_back</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 圆盘指针最初指向 12 点钟方向，</span>
    <span class="c1">// 从第一个字符开始输入 key</span>
    <span class="k">return</span> <span class="nf">dp</span><span class="o">(</span><span class="n">ring</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 计算圆盘指针在 ring[i]，输入 key[j..] 的最少操作数</span>
<span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">ring</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// base case 完成输入</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// 查找备忘录，避免重叠子问题</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>

    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="c1">// 做选择</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="no">INT_MAX</span><span class="o">;</span>
    <span class="c1">// ring 上可能有多个字符 key[j]</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">:</span> <span class="n">charToIndex</span><span class="o">[</span><span class="n">key</span><span class="o">[</span><span class="n">j</span><span class="o">]])</span> <span class="o">{</span>
        <span class="c1">// 拨动指针的次数</span>
        <span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">abs</span><span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">i</span><span class="o">);</span>
        <span class="c1">// 选择顺时针还是逆时针</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">min</span><span class="o">(</span><span class="n">delta</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">delta</span><span class="o">);</span>
        <span class="c1">// 将指针拨到 ring[k]，继续输入 key[j+1..]</span>
        <span class="kt">int</span> <span class="n">subProblem</span> <span class="o">=</span> <span class="n">dp</span><span class="o">(</span><span class="n">ring</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="c1">// 选择「整体」操作次数最少的</span>
        <span class="c1">// 加一是因为按动按钮也是一次操作</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">min</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">+</span> <span class="n">subProblem</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 将结果存入备忘录</span>
    <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="加权有向图-最短路径">加权有向图 最短路径</h2><h3 id="787-k-站中转内最便宜的航班中等">787. K 站中转内最便宜的航班（中等）</h3><p><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/">787. Cheapest Flights Within K Stops</a></p><p>There are n cities connected by some number of flights. You are given an array flights where <code class="language-plaintext highlighter-rouge">flights[i] = [fromi, toi, pricei]</code> indicates that there is a flight from city <code class="language-plaintext highlighter-rouge">fromi</code> to city <code class="language-plaintext highlighter-rouge">toi</code> with cost pricei.</p><p>You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.</p><p>Example 1: Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1 Output: 200 Explanation: The graph is shown. The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.</p><ul><li>一幅加权有向图，让你求 src 到 dst 权重最小的一条路径，同时要满足，这条路径最多不能超过 K + 1 条边（经过 K 个节点相当于经过 K + 1 条边。</ul><ol><li>BFS 算法</ol><ul><li>对于加权图的场景，我们需要优先级队列「自动排序」的特性，将路径权重较小的节点排在队列前面，以此为基础施展 BFS 算法。</ul><ol><li>动态规划思路</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="n">minPath</span><span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">)</span> <span class="o">=</span> <span class="n">min</span><span class="o">(</span>
    <span class="n">minPath</span><span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">s1</span><span class="o">)</span> <span class="o">+</span> <span class="n">w1</span><span class="o">,</span>
    <span class="n">minPath</span><span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="o">+</span> <span class="n">w2</span>
<span class="o">)</span>

<span class="n">dp</span><span class="o">(</span><span class="n">dst</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> <span class="o">=</span> <span class="n">min</span><span class="o">(</span>
    <span class="n">dp</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">w1</span><span class="o">,</span>
    <span class="n">dp</span><span class="o">(</span><span class="n">s2</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">w2</span>
<span class="o">)</span>

<span class="c1">// Time Limit Exceeded</span>
<span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;&gt;</span> <span class="n">indegree</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">findCheapestPrice</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">flights</span><span class="o">,</span> <span class="kt">int</span> <span class="n">src</span><span class="o">,</span> <span class="kt">int</span> <span class="n">dst</span><span class="o">,</span> <span class="kt">int</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">k</span><span class="o">++;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">src</span><span class="o">=</span><span class="n">src</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">dst</span><span class="o">=</span><span class="n">dst</span><span class="o">;</span>
    <span class="n">indegree</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="nl">f:</span><span class="n">flights</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">f</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">f</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="n">f</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="c1">// 记录谁指向该节点，以及之间的权重</span>
        <span class="n">indegree</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">to</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;());</span>
        <span class="n">indegree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">to</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">from</span><span class="o">,</span> <span class="n">price</span><span class="o">});</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="nf">dp</span><span class="o">(</span><span class="n">dst</span><span class="o">,</span><span class="n">k</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 定义：从 src 出发，k 步之内到达 s 的最短路径权重</span>
<span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">==</span><span class="k">this</span><span class="o">.</span><span class="na">src</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

    <span class="c1">// 初始化为最大值，方便等会取最小值</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">indegree</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">)){</span>
        <span class="c1">// 当 s 有入度节点时，分解为子问题</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">v</span> <span class="o">:</span> <span class="n">indegree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">v</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="n">v</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

            <span class="c1">// 从 src 到达相邻的入度节点所需的最短路径权重</span>
            <span class="kt">int</span> <span class="n">subProblem</span> <span class="o">=</span> <span class="n">dp</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="c1">// 跳过无解的情况</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">subProblem</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">subProblem</span> <span class="o">+</span> <span class="n">price</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 如果还是初始值，说明此节点不可达</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>memo</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 7 ms, faster than 47.07% of Java online submissions for Cheapest Flights Within K Stops.</span>
<span class="c1">// Memory Usage: 39.3 MB, less than 98.25% of Java online submissions for Cheapest Flights Within K Stops.</span>


<span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;&gt;</span> <span class="n">indegree</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">;</span>
<span class="c1">// 备忘录</span>
<span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">findCheapestPrice</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">flights</span><span class="o">,</span> <span class="kt">int</span> <span class="n">src</span><span class="o">,</span> <span class="kt">int</span> <span class="n">dst</span><span class="o">,</span> <span class="kt">int</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">k</span><span class="o">++;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">src</span><span class="o">=</span><span class="n">src</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">dst</span><span class="o">=</span><span class="n">dst</span><span class="o">;</span>
    <span class="c1">// 初始化备忘录，全部填一个特殊值</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="no">K</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">memo</span><span class="o">)</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="o">-</span><span class="mi">888</span><span class="o">);</span>
    <span class="n">indegree</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="nl">f:</span><span class="n">flights</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">f</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">f</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="n">f</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="c1">// 记录谁指向该节点，以及之间的权重</span>
        <span class="n">indegree</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">to</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;());</span>
        <span class="n">indegree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">to</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">from</span><span class="o">,</span> <span class="n">price</span><span class="o">});</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="nf">dp</span><span class="o">(</span><span class="n">dst</span><span class="o">,</span><span class="n">k</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 定义：从 src 出发，k 步之内到达 s 的最短路径权重</span>
<span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">==</span><span class="k">this</span><span class="o">.</span><span class="na">src</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="c1">// 查备忘录，防止冗余计算</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">s</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">888</span><span class="o">)</span> <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">s</span><span class="o">][</span><span class="n">k</span><span class="o">];</span>

    <span class="c1">// 初始化为最大值，方便等会取最小值</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">indegree</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">)){</span>
        <span class="c1">// 当 s 有入度节点时，分解为子问题</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">v</span> <span class="o">:</span> <span class="n">indegree</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">v</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="n">v</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

            <span class="c1">// 从 src 到达相邻的入度节点所需的最短路径权重</span>
            <span class="kt">int</span> <span class="n">subProblem</span> <span class="o">=</span> <span class="n">dp</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="c1">// 跳过无解的情况</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">subProblem</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">subProblem</span> <span class="o">+</span> <span class="n">price</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 存入备忘录</span>
    <span class="n">memo</span><span class="o">[</span><span class="n">s</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">res</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">s</span><span class="o">][</span><span class="n">k</span><span class="o">];</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="-子序列">🔒 子序列</h2><p>一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着呢？</p><p>既然要用动态规划，那就要定义 dp 数组，找状态转移关系。</p><ol><li>一个一维的 dp 数组：</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">最值</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="o">...)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>二维的 dp 数组：</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">])</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="o">...</span>
        <span class="k">else</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">最值</span><span class="o">(...)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>这种思路运用相对更多一些，尤其是涉及两个字符串/数组的子序列。</p><p>dp 数组的含义</p><ol><li>涉及两个字符串/数组时（比如最长公共子序列）<ol><li>在子数组arr1[0..i]和子数组arr2[0..j]中<li>我们要求的子序列（最长公共子序列）长度为dp[i][j]。</ol><li>只涉及一个字符串/数组时（比如本文要讲的最长回文子序列）<ol><li>在子数组array[i..j]中<li>我们要求的子序列（最长回文子序列）的长度为dp[i][j]。</ol></ol><hr /><h2 id="-subarray">🔒 SubArray</h2><hr /><h3 id="152-maximum-product-subarray-medium">152. Maximum Product Subarray (Medium)</h3><p><a href="https://leetcode.com/problems/maximum-product-subarray/">152. Maximum Product Subarray</a></p><p>Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.</p><p>The test cases are generated so that the answer will fit in a 32-bit integer.</p><p>A subarray is a contiguous subsequence of the array.</p><p>Example 1: Input: nums = [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.</p><p>Example 2: Input: nums = [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</p><ol><li>brute force: try every subarray O(n^2)</ol><hr /><h4 id="-record-max-and-min">+++++ <code class="language-plaintext highlighter-rouge">record max and min</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 97.53% of Java online submissions for Maximum Product Subarray.</span>
<span class="c1">// Memory Usage: 42.6 MB, less than 84.37% of Java online submissions for Maximum Product Subarray.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProduct</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="no">A</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">min</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">ans</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">max</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">min</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]),</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">temp</span><span class="o">,</span> <span class="n">min</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]),</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">max</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
        <span class="o">}</span>


<span class="c1">// Runtime: 1 ms, faster than 97.53% of Java online submissions for Maximum Product Subarray.</span>
<span class="c1">// Memory Usage: 41.8 MB, less than 99.74% of Java online submissions for Maximum Product Subarray.</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProduct</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="no">A</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">min</span> <span class="o">=</span> <span class="n">max</span><span class="o">,</span> <span class="n">ans</span><span class="o">=</span><span class="n">max</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                    <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="o">}</span>
                <span class="k">else</span><span class="o">{</span>
                    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
                    <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">min</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                    <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">temp</span> <span class="o">*</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">max</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><hr /><h2 id="-子序列---一维dp数组">🔒 子序列 - 一维dp数组</h2><hr /><h3 id="53-maximum-subarray-最大子序和easy">53. Maximum Subarray 最大子序和（Easy)</h3><p><a href="https://leetcode.com/problems/maximum-subarray/">53. Maximum Subarray</a></p><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>A subarray is a contiguous part of an array.</p><p>Example 1: Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.</p><p>Example 2: Input: nums = [1] Output: 1</p><h4 id="-int-dp-max--mathmaxmax-dpi">+++++ <code class="language-plaintext highlighter-rouge">int[] dp, max = Math.max(max, dp[i])</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 100.00% of Java online submissions for Maximum Subarray.</span>
<span class="c1">// Memory Usage: 51.8 MB, less than 85.97% of Java online submissions for Maximum Subarray.</span>
<span class="c1">//    1. 复杂度是 O(N)，</span>
<span class="c1">//    2. 空间复杂度也是 O(N)</span>
<span class="kt">int</span> <span class="nf">maxSubArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="c1">// base case</span>
    <span class="c1">// 第一个元素前面没有子数组</span>
    <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">// 状态转移方程</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]);</span>
        <span class="c1">// 得到 nums 的最大子数组</span>
        <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="-状态压缩-dpi-仅仅和-dpi-1-的状态有关">+++++ 状态压缩 <code class="language-plaintext highlighter-rouge">dp[i] 仅仅和 dp[i-1] 的状态有关</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 100.00% of Java online submissions for Maximum Subarray.</span>
<span class="c1">// Memory Usage: 49.2 MB, less than 78.66% of Java online submissions for Maximum Subarray.</span>
<span class="kt">int</span> <span class="nf">maxSubArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">num_pre</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">num_cur</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">// 状态转移方程</span>
        <span class="n">num_cur</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">num_pre</span><span class="o">);</span>
        <span class="n">num_pre</span> <span class="o">=</span> <span class="n">num_cur</span><span class="o">;</span>
        <span class="c1">// 得到 nums 的最大子数组</span>
        <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">num_cur</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
<span class="o">}</span>


<span class="c1">// not best</span>
<span class="c1">// Runtime: 3 ms, faster than 19.59% of Java online submissions for Maximum Subarray.</span>
<span class="c1">// Memory Usage: 73.6 MB, less than 54.46% of Java online submissions for Maximum Subarray.</span>
<span class="kt">int</span> <span class="nf">maxSubArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="217-contains-duplicate-easy">217. Contains Duplicate (Easy)</h3><p><a href="https://leetcode.com/problems/contains-duplicate/">217. Contains Duplicate</a> Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.</p><p>Example 1: Input: nums = [1,2,3,1] Output: true</p><p>Example 2: Input: nums = [1,2,3,4] Output: false</p><h4 id="-hash-记住出现过的数字">+++++ <code class="language-plaintext highlighter-rouge">hash 记住出现过的数字</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 6 ms, faster than 93.81% of Java online submissions for Contains Duplicate.</span>
<span class="c1">// Memory Usage: 54.7 MB, less than 68.52% of Java online submissions for Contains Duplicate.</span>
<span class="cm">/**
 * Using HashSet
 * Time Complexity: O(N)
 * Space Complexity: O(N)
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Input array is null"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">nums</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">num</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-sort-the-array-better">+++++ <code class="language-plaintext highlighter-rouge">Sort the array</code> better</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 25 ms, faster than 18.05% of Java online submissions for Contains Duplicate.</span>
<span class="c1">// Memory Usage: 69.3 MB, less than 49.48% of Java online submissions for Contains Duplicate.</span>
<span class="cm">/**
 * Sort the array
 * Time Complexity: O(N log N)
 * Space Complexity: O(Space used by sorting algorithm)
 */</span>
<span class="kd">class</span> <span class="nc">Solution2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><hr /><h3 id="300-longest-increasing-subsequence-最长递增子序列">300. Longest Increasing Subsequence 最长递增子序列</h3><p><a href="https://leetcode.com/problems/longest-increasing-subsequence/">300. Longest Increasing Subsequence</a></p><p>Given an integer array nums, return the length of the longest strictly increasing subsequence.</p><p>A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].</p><p>Example 1:</p><p>Input: nums = [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.</p><ol><li>动态规划解法</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLIS</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]&gt;</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]+</span><span class="mi">1</span><span class="o">,</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">dp</span><span class="o">)</span> <span class="n">res</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="1143-longest-common-subsequence-最长公共子序列">1143. Longest Common Subsequence 最长公共子序列</h3><p><a href="https://leetcode.com/problems/longest-common-subsequence/">1143. Longest Common Subsequence</a></p><p>Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.</p><p>A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p><p>For example, “ace” is a subsequence of “abcde”. A common subsequence of two strings is a subsequence that is common to both strings.</p><p>Example 1:</p><p>Input: text1 = “abcde”, text2 = “ace” Output: 3 Explanation: The longest common subsequence is “ace” and its length is 3.</p><ol><li>暴力算法<ol><li>把 s1 和 s2 的所有子序列都穷举出来，<li>看有没有公共的，<li>然后在所有公共子序列里面再寻找一个长度最大的。<li>复杂度就是指数级的，不实际。</ol><li><p>不考虑整个字符串，细化到s1和s2的每个字符</p><li>用memo备忘录消除子问题</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">// 备忘录，消除重叠子问题</span>
<span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span><span class="o">;</span>

<span class="cm">/* 主函数 */</span>
<span class="kt">int</span> <span class="nf">longestCommonSubsequence</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="c1">// 备忘录值为 -1 代表未曾计算</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">memo</span><span class="o">)</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="c1">// 计算 s1[0..] 和 s2[0..] 的 lcs 长度</span>
    <span class="k">return</span> <span class="nf">dp</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">s2</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/* 主函数 */</span>
<span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// base case</span>
    <span class="c1">// s1[i..]或s2[j..]就相当于空串了，最长公共子序列的长度显然是 0</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

    <span class="c1">// 如果之前计算过，则直接返回备忘录中的答案</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>

    <span class="c1">// 根据 s1[i] 和 s2[j] 的情况做选择</span>
    <span class="c1">// s1[i] 和 s2[j] 必然在 lcs 中</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dp</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">s2</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="c1">// s1[i] 和 s2[j] 至少有一个不在 lcs 中</span>
    <span class="k">else</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span> <span class="n">dp</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">s2</span><span class="o">,</span> <span class="n">j</span><span class="o">),</span> <span class="n">dp</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">s2</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">);</span>

    <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
  <span class="o">}</span>
</pre></table></code></div></div><ol><li>自底向上的迭代的动态规划思路</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 9 ms, faster than 89.16% of Java online submissions for Longest Common Subsequence.</span>
<span class="c1">// Memory Usage: 42.9 MB, less than 64.72% of Java online submissions for Longest Common Subsequence.</span>

<span class="kt">int</span> <span class="nf">longestCommonSubsequence</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="c1">// 定义：s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度为 dp[i][j]</span>
    <span class="c1">// 目标：s1[0..m-1] 和 s2[0..n-1] 的 lcs 长度，即 dp[m][n]</span>
    <span class="c1">// base case: dp[0][..] = dp[..][0] = 0</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>

            <span class="c1">// 现在 i 和 j 从 1 开始，所以要减一</span>

            <span class="c1">// s1[i-1] 和 s2[j-1] 必然在 lcs 中</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="c1">// s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中</span>
            <span class="k">else</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="583-delete-operation-for-two-strings-两个字符串的删除操作">583. Delete Operation for Two Strings 两个字符串的删除操作</h3><p><a href="https://leetcode.com/problems/delete-operation-for-two-strings/">583. Delete Operation for Two Strings</a></p><ul><li>Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.<li>In one step, you can delete exactly one character in either string.<li>要计算删除的次数，就可以通过最长公共子序列的长度推导出来<li>删除的结果就是它俩的最长公共子序列</ul><p>Example 1: Input: word1 = “sea”, word2 = “eat”</p><p>Output: 2 Explanation: You need one step to make “sea” to “ea” and another step to make “eat” to “ea”.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 7 ms, faster than 90.79% of Java online submissions for Delete Operation for Two Strings.</span>
<span class="c1">// Memory Usage: 39.2 MB, less than 97.09% of Java online submissions for Delete Operation for Two Strings.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minDistance</span><span class="o">(</span><span class="nc">String</span> <span class="n">word1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="c1">// 复用前文计算 lcs 长度的函数</span>
        <span class="kt">int</span> <span class="n">lcs</span> <span class="o">=</span> <span class="n">longestCommonSubsequence</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word2</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">m</span> <span class="o">-</span> <span class="n">lcs</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="n">lcs</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 最长公共子序列的长度</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestCommonSubsequence</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// 现在 i 和 j 从 1 开始，所以要减一</span>
                <span class="c1">// s1[i-1] 和 s2[j-1] 必然在 lcs 中</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
                <span class="c1">// s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中</span>
                <span class="k">else</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="712-minimum-ascii-delete-sum-for-two-strings-最小-ascii-删除和">712. Minimum ASCII Delete Sum for Two Strings 最小 ASCII 删除和</h3><p><a href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/submissions/">712. Minimum ASCII Delete Sum for Two Strings</a></p><p>Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings equal.</p><p>Example 1:</p><p>Input: s1 = “sea”, s2 = “eat” Output: 231 Explanation: Deleting “s” from “sea” adds the ASCII value of “s” (115) to the sum. Deleting “t” from “eat” adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 32 ms, faster than 36.57% of Java online submissions for Minimum ASCII Delete Sum for Two Strings.</span>
<span class="c1">// Memory Usage: 39.5 MB, less than 80.73% of Java online submissions for Minimum ASCII Delete Sum for Two Strings.</span>

<span class="c1">// 备忘录</span>
<span class="kt">int</span> <span class="n">memo</span><span class="o">[][];</span>

<span class="cm">/* 主函数 */</span>
<span class="kt">int</span> <span class="nf">minimumDeleteSum</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="c1">// 备忘录值为 -1 代表未曾计算</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">memo</span><span class="o">)</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="k">return</span> <span class="nf">dp</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">s2</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 定义：将 s1[i..] 和 s2[j..] 删除成相同字符串，</span>
<span class="c1">// 最小的 ASCII 码之和为 dp(s1, i, s2, j)。</span>
<span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// 如果 s1 到头了，那么 s2 剩下的都得删除</span>
        <span class="k">for</span> <span class="o">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="n">res</span> <span class="o">+=</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// 如果 s2 到头了，那么 s1 剩下的都得删除</span>
        <span class="k">for</span> <span class="o">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="n">res</span> <span class="o">+=</span> <span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>

    <span class="c1">// s1[i] 和 s2[j] 都是在 lcs 中的，不用删除</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">s2</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="c1">// s1[i] 和 s2[j] 至少有一个不在 lcs 中，删一个</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span>
            <span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="n">dp</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">s2</span><span class="o">,</span> <span class="n">j</span><span class="o">),</span>
            <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">+</span> <span class="n">dp</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">s2</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
        <span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
<span class="o">}</span>

</pre></table></code></div></div><hr /><h3 id="5-longest-palindromic-substring-最长回文子序列">5. Longest Palindromic Substring 最长回文子序列</h3><p>[5. Longest Palindromic Substring]</p><p>Given a string s, return the longest palindromic substring in s.</p><p>Example 1:</p><p>Input: s = “babad” Output: “bab” Note: “aba” is also a valid answer.</p><p>这个问题对 dp 数组的定义是：在子串s[i..j]中，最长回文子序列的长度为dp[i][j]。一定要记住这个定义才能理解算法。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">len</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">checkpalin</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">i</span><span class="o">);</span>
            <span class="n">checkpalin</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">lo</span><span class="o">,</span> <span class="n">lo</span><span class="o">+</span><span class="n">maxLen</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkpalin</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)==</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)){</span>
            <span class="n">i</span><span class="o">--;</span>
            <span class="n">j</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">maxLen</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">){</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="n">maxLen</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="516-longest-palindromic-subsequence-最长回文子序列长度">516. Longest Palindromic Subsequence 最长回文子序列长度</h3><p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/">516. Longest Palindromic Subsequence</a></p><ul><li>Given a string s, find the longest palindromic subsequences length in s.<li>A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</ul><p>Example 1:</p><p>Input: s = “bbbab” Output: 4 Explanation: One possible longest palindromic subsequence is “bbbb”.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 41 ms, faster than 67.06% of Java online submissions for Longest Palindromic Subsequence.</span>
<span class="c1">// Memory Usage: 49.1 MB, less than 71.59% of Java online submissions for Longest Palindromic Subsequence.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestPalindromeSubseq</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">m</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">--){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)==</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">;</span>
                <span class="k">else</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span>
                    <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span>
                    <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>
                <span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="494-target-sum-目标和">494. Target Sum 目标和</h3><p><a href="https://leetcode.com/problems/target-sum/">494. Target Sum</a></p><p>You are given an integer array nums and an integer target.</p><p>You want to build an expression out of nums by adding one of the symbols ‘+’ and ‘-‘ before each integer in nums and then concatenate all the integers.</p><p>For example, if nums = [2, 1], you can add a ‘+’ before 2 and a ‘-‘ before 1 and concatenate them to build the expression “+2-1”. Return the number of different expressions that you can build, which evaluates to target.</p><p>Example 1:</p><p>Input: nums = [1,1,1,1,1], target = 3 Output: 5 Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3. -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3</p><h4 id="回溯思路">回溯思路</h4><p>任何算法的核心都是穷举，回溯算法就是一个暴力穷举算法</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 556 ms, faster than 13.66% of Java online submissions for Target Sum.</span>
<span class="c1">// Memory Usage: 36.5 MB, less than 84.78% of Java online submissions for Target Sum.</span>

<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="cm">/* 主函数 */</span>
<span class="kt">int</span> <span class="nf">findTargetSumWays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">backtrack</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/* 回溯算法模板 */</span>
<span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">rest</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 说明恰好凑出 target</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rest</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">result</span><span class="o">++;</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 给 nums[i] 选择 - 号</span>
    <span class="n">rest</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="c1">// 穷举 nums[i + 1]</span>
    <span class="n">backtrack</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">rest</span><span class="o">);</span>
    <span class="c1">// 撤销选择</span>
    <span class="n">rest</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

    <span class="c1">// 给 nums[i] 选择 + 号</span>
    <span class="n">rest</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="c1">// 穷举 nums[i + 1]</span>
    <span class="n">backtrack</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">rest</span><span class="o">);</span>
    <span class="c1">// 撤销选择</span>
    <span class="n">rest</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="消除重叠子问题">消除重叠子问题</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">findTargetSumWays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">return</span> <span class="nf">dp</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 备忘录</span>
<span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

<span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">rest</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// base case</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rest</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 把它俩转成字符串才能作为哈希表的键</span>
    <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="s">","</span> <span class="o">+</span> <span class="n">rest</span><span class="o">;</span>
    <span class="c1">// 避免重复计算</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">memo</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 还是穷举</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">dp</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">rest</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">+</span> <span class="n">dp</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">rest</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="c1">// 记入备忘录</span>
    <span class="n">memo</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="72-edit-distance-编辑距离困难">72. Edit Distance 编辑距离（困难）</h3><p><img data-proofer-ignore data-src="https://i.imgur.com/JWV0ewv.jpg" alt="dp" /></p><p><a href="https://leetcode.com/problems/edit-distance/">72. Edit Distance</a></p><p>Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.</p><p>You have the following three operations permitted on a word:</p><p>Insert a character Delete a character Replace a character</p><p>Example 1:</p><p>Input: word1 = “horse”, word2 = “ros” Output: 3 Explanation: horse -&gt; rorse (replace ‘h’ with ‘r’) rorse -&gt; rose (remove ‘r’) rose -&gt; ros (remove ‘e’)</p><ol><li>暴力解法，存在重叠子问题，需要用动态规划技巧来优化。</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minDistance</span><span class="o">(</span><span class="nc">String</span> <span class="n">word1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">dp</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">,</span> <span class="n">word2</span><span class="o">,</span> <span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">dp</span><span class="o">(</span><span class="nc">String</span> <span class="n">word1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==-</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">j</span><span class="o">==-</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">word1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)==</span><span class="n">word2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="k">return</span> <span class="n">dp</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">word2</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">else</span> <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="n">min</span><span class="o">(</span>
            <span class="n">dp</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">word2</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">),</span>
            <span class="n">dp</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">word2</span><span class="o">,</span> <span class="n">j</span><span class="o">),</span>
            <span class="n">dp</span><span class="o">(</span><span class="n">word1</span><span class="o">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">word2</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
        <span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">min</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">z</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">y</span><span class="o">,</span><span class="n">z</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>动态规划优化 对于重叠子问题呢，前文 动态规划详解 详细介绍过，优化方法无非是备忘录或者 DP table。</ol><p>备忘录很好加，原来的代码稍加修改即可：</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 4 ms, faster than 91.95% of Java online submissions for Edit Distance.</span>
<span class="c1">// Memory Usage: 38.8 MB, less than 92.87% of Java online submissions for Edit Distance.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minDistance</span><span class="o">(</span><span class="nc">String</span> <span class="n">word1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="n">memo</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">word1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)==</span><span class="n">word2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
                <span class="k">else</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">min</span><span class="o">(</span>
                    <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span>
                    <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span>
                    <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>
                <span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">min</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">z</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">y</span><span class="o">,</span><span class="n">z</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>具体的操作</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// int[][] dp;</span>
<span class="nc">Node</span><span class="o">[][]</span> <span class="n">dp</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">choice</span><span class="o">;</span>
    <span class="c1">// 0 代表啥都不做</span>
    <span class="c1">// 1 代表插入</span>
    <span class="c1">// 2 代表删除</span>
    <span class="c1">// 3 代表替换</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="354-russian-doll-envelopes-俄罗斯套娃信封问题困难">354. Russian Doll Envelopes 俄罗斯套娃信封问题（困难）</h3><p><a href="https://leetcode.com/problems/russian-doll-envelopes/">354. Russian Doll Envelopes</a></p><p>You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.</p><p>One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope’s width and height.</p><p>Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).</p><p>Note: You cannot rotate an envelope.</p><p>Example 1:</p><p>Input: envelopes = [[5,4],[6,4],[6,7],[2,3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 148 ms, faster than 53.28% of Java online submissions for Russian Doll Envelopes.</span>
<span class="c1">// Memory Usage: 39.9 MB, less than 82.57% of Java online submissions for Russian Doll Envelopes.</span>

<span class="c1">// envelopes = [[w, h], [w, h]...]</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxEnvelopes</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">envelopes</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">envelopes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="c1">// 按宽度升序排列，如果宽度一样，则按高度降序排列</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span>
        <span class="n">envelopes</span><span class="o">,</span>
        <span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">?</span> <span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">:</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">);</span>
    <span class="c1">// 对高度数组寻找 LIS</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">height</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">envelopes</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
    <span class="k">return</span> <span class="nf">lengthOfLIS</span><span class="o">(</span><span class="n">height</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLIS</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">res</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">dp</span><span class="o">)</span> <span class="n">res</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="背包类型问题">背包类型问题</h2><ol><li>动规标准<ol><li>第一步要明确两点，「状态」和「选择」。<li>状态:「背包的容量」和「可选择的物品」。<ol><li>「状态」，有两个，也就是说我们需要一个二维 dp 数组。<li>dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。</ol><li>选择:「装进背包」或者「不装进背包」<ol><li>没有把这第 i 个物品装入背包: 最大价值 dp[i][w] 应该等于 dp[i-1][w]，继承之前的结果。<li>把这第 i 个物品装入了背包，那么 dp[i][w] = dp[i-1][w - wt[i-1]] + val[i-1]。</ol></ol></ol><div class="language-cpp highlighter-rouge"><div class="code-header" text-data="cpp"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">knapsack</span><span class="p">(</span><span class="kt">int</span> <span class="n">W</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">wt</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// base case 已初始化</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">W</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="n">W</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 这种情况下只能选择不装入背包</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">wt</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">w</span><span class="p">];</span>
            <span class="c1">// 装入或者不装入背包，择优</span>
            <span class="k">else</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">w</span> <span class="o">-</span> <span class="n">wt</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">w</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">W</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h3 id="子集背包问题">子集背包问题</h3><h4 id="416-partition-equal-subset-sum-分割等和子集中等">416. Partition Equal Subset Sum 分割等和子集（中等）</h4><p><a href="https://leetcode.com/problems/partition-equal-subset-sum/">416. Partition Equal Subset Sum</a></p><p>Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p>先对集合求和，得出 sum，把问题转化为背包问题：</p><p>给一个可装载重量为 sum / 2 的背包和 N 个物品，每个物品的重量为 nums[i]。 现在让你装物品，是否存在一种装法，能够恰好将背包装满？</p><ol><li>第一步要明确两点，「状态」和「选择」。<ol><li>状态就是「背包的容量」和「可选择的物品」，<li>选择就是「装进背包」或者「不装进背包」。</ol><li>第二步要明确 dp 数组的定义。</ol><ul><li>dp[i][j] = x 表示，<li>对于前 i 个物品，当前背包的容量为 j 时，<li>若 x 为 true，则说明可以恰好将背包装满，<li><p>若 x 为 false，则说明不能恰好将背包装满。</p><li>我们想求的最终答案就是 dp[N][sum/2]，<li>base case 就是<ul><li>dp[..][0] = true 因为背包没有空间的时候，就相当于装满了，<li>dp[0][..] = false，没有物品可选择的时候，肯定没办法装满背包。</ul></ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 77 ms, faster than 19.78% of Java online submissions for Partition Equal Subset Sum.</span>
<span class="c1">// Memory Usage: 51.4 MB, less than 20.88% of Java online submissions for Partition Equal Subset Sum.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canPartition</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">nums</span><span class="o">)</span> <span class="n">sum</span><span class="o">+=</span><span class="n">num</span><span class="o">;</span>
        <span class="c1">// 和为奇数时，不可能划分成两个和相等的集合</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sum</span><span class="o">%</span><span class="mi">2</span><span class="o">!=</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">sum</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

        <span class="c1">// base case</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">sum</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="kc">false</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">sum</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="c1">// 背包容量不足，不能装入第 i 个物品</span>
                <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="c1">// 装入或不装入背包</span>
                <span class="k">else</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">sum</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>状态压缩<ol><li>dp[i][j] 都是通过上一行 dp[i-1][..] 转移过来的</ol></ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kt">boolean</span> <span class="nf">canPartition</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>
    <span class="c1">// 和为奇数时，不可能划分成两个和相等的集合</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

    <span class="c1">// base case</span>
    <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]];</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">sum</span><span class="o">];</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="698-partition-to-k-equal-sum-subsets">698. Partition to K Equal Sum Subsets</h4><p>Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.</p><p>Example 1:</p><p>Input: nums = [4,3,2,3,5,2,1], k = 4 Output: true Explanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.</p><ol><li>backtracking</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canPartitionKSubsets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//if sum is not a multiple of K we can't divide</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">nums</span><span class="o">)</span> <span class="n">sum</span><span class="o">+=</span><span class="n">num</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sum</span><span class="o">%</span><span class="n">k</span><span class="o">!=</span><span class="mi">0</span> <span class="o">||</span> <span class="n">k</span><span class="o">&gt;</span><span class="n">n</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">sum</span><span class="o">=</span><span class="n">sum</span><span class="o">/</span><span class="n">k</span><span class="o">;</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">used</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">used</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">findPart</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">used</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">findPart</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">used</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cur_sum</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">k</span><span class="o">&lt;=</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">target</span><span class="o">==</span><span class="n">cur_sum</span><span class="o">)</span> <span class="k">return</span> <span class="n">findPart</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">used</span><span class="o">,</span> <span class="n">target</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">||</span> <span class="n">curr_sum</span><span class="o">+</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]&gt;</span><span class="n">target</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
            <span class="n">used</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span> <span class="n">findPart</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">used</span><span class="o">,</span> <span class="n">target</span><span class="o">,</span> <span class="n">cur_sum</span><span class="o">+</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> <span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">used</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>remove visited[], <code class="language-plaintext highlighter-rouge">each time used a number, nums[i]=0, undo: nums[i]=temp</code>.</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 90.92% of Java online submissions for Partition to K Equal Sum Subsets.</span>
<span class="c1">// Memory Usage: 36.3 MB, less than 80.51% of Java online submissions for Partition to K Equal Sum Subsets.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canPartitionKSubsets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Not possible to divide into equal subsets, if sum of all</span>
        <span class="c1">// nums[] is not a multiple of k.</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span>  <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">k</span><span class="o">&gt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">// Determine the target number that each subset must total.</span>
        <span class="c1">// Then start recursion to find if possible to have k equal subsets.</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="n">k</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">curSum</span><span class="o">,</span> <span class="kt">int</span> <span class="n">numsIdx</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>                      <span class="c1">// If no more subsets to fill, then done</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">numsIdx</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// Loop in nums[] values to find next unused</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">curSum</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="c1">// Mark this nums value as "used". If subset exactly filled, start new subset</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">curSum</span> <span class="o">+</span> <span class="n">temp</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">target</span><span class="o">))</span>  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// Else subset not filled, find more to fill it.</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">curSum</span> <span class="o">+</span> <span class="n">temp</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">target</span><span class="o">))</span>  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
                <span class="c1">// This nums[i] value didn't result in a good solution</span>
                <span class="c1">// so "unuse" this nums[] value and loop back to try another nums[] value</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="215-kth-largest-element-in-an-array">215. Kth Largest Element in an Array</h4><hr /><hr /><h1 id="-hash">🔒🔒 Hash</h1><hr /><h2 id="-hash---array-int">🔒 Hash - Array int[]</h2><hr /><h3 id="1-two-sum-easy-找两个数sumtarget">1. Two Sum (Easy) <code class="language-plaintext highlighter-rouge">找两个数sum=target</code></h3><p><a href="https://leetcode.com/problems/two-sum/">1. Two Sum</a> Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>You can return the answer in any order.</p><h4 id="-brute-force-穷举">+++++ brute force 穷举</h4><ul><li>时间复杂度 O(N^2)<li>空间复杂度 O(1)。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">};</span>
    <span class="c1">// 不存在这么两个数</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-two-pointer">+++++ two pointer</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 66 ms, faster than 29.51% of Java online submissions for Two Sum.</span>
<span class="c1">// Memory Usage: 45 MB, less than 60.12% of Java online submissions for Two Sum.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]==</span><span class="n">target</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">};</span>
                <span class="k">else</span> <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-hashmap">+++++ HashMap</h4><ul><li>减少时间复杂度<li>Time O(N)<li>Space O(N)</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 3 ms, faster than 79.66% of Java online submissions for Two Sum.</span>
<span class="c1">// Memory Usage: 45.8 MB, less than 10.23% of Java online submissions for Two Sum.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">target</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])};</span>
            <span class="k">else</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">target</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="n">res</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">ans</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">target</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ans</span><span class="o">==-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="n">res</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">ans</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="c1">// Runtime: 8 ms, faster than 45.82% of Java online submissions for Two Sum.</span>
<span class="c1">// Memory Usage: 43.6 MB, less than 6.09% of Java online submissions for Two Sum.</span>
<span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">index</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 构造一个哈希表：元素映射到相应的索引</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">index</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">other</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="c1">// 如果 other 存在且不是 nums[i] 本身</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">other</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">index</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">other</span><span class="o">)</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">i</span><span class="o">,</span> <span class="n">index</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">other</span><span class="o">)};</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="15-3-sum-medium">15. 3 sum (Medium)</h3><p><a href="https://leetcode.com/problems/3sum/">3 sum</a> Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.</p><p>Notice that the solution set must not contain duplicate triplets.</p><p>Example 1: Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]]</p><p>Example 2: Input: nums = [] Output: []</p><p>Example 3: Input: nums = [0] Output: []</p><ol><li>brute force</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">sort</span><span class="o">();</span>
<span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="n">k</span><span class="o">=</span><span class="n">target</span><span class="o">;</span>
<span class="n">use</span> <span class="n">set</span><span class="o">/</span><span class="n">hash</span> <span class="n">to</span> <span class="n">remove</span> <span class="n">duplicate</span>
</pre></table></code></div></div><h4 id="-i--2-sumhashset">++++++ <code class="language-plaintext highlighter-rouge">i + 2 sum(Hash+Set)</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1729 ms, faster than 5.01% of Java online submissions for 3Sum.</span>
<span class="c1">// Memory Usage: 148.5 MB, less than 7.69% of Java online submissions for 3Sum.</span>
<span class="c1">// time: O(n^2)</span>
<span class="c1">// space: O(n)</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">threeSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// if length is less than 3, return empty result set</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>

        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>

                <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>

                <span class="c1">// x y -&gt; find z (x&lt;y&lt;z)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">target</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target</span><span class="o">)&gt;</span><span class="n">j</span> <span class="o">){</span>

                    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">target</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ArrayList</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h5 id="-best-2-pointer">++++++ <code class="language-plaintext highlighter-rouge">best: 2 pointer</code></h5><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 27 ms, faster than 81.71% of Java online submissions for 3Sum.</span>
<span class="c1">// Memory Usage: 59.1 MB, less than 51.67% of Java online submissions for 3Sum.</span>
<span class="c1">// time: O(n^2)</span>
<span class="c1">// space: O(1)</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">threeSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">q1</span>    <span class="err">`````````````</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// if length is less than 3, return empty result set</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">res</span><span class="o">;</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>

        <span class="c1">// left to tight</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">){</span>
            <span class="c1">// if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])){</span>
                <span class="c1">//  i j ------ k</span>
                <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">while</span><span class="o">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">k</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="mi">0</span><span class="o">==</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">])</span> <span class="o">{</span>
                        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]));</span>
                        <span class="k">while</span><span class="o">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]==</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">])</span> <span class="n">j</span><span class="o">++;</span>
                        <span class="k">while</span><span class="o">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]==</span><span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="n">k</span><span class="o">--;</span>
                        <span class="n">j</span><span class="o">++;</span>
                        <span class="n">k</span><span class="o">--;</span>
                    <span class="o">}</span>
                    <span class="c1">// need smaller number</span>
                    <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="mi">0</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">])</span> <span class="n">k</span><span class="o">--;</span>
                    <span class="c1">// need biger number</span>
                    <span class="k">else</span> <span class="n">j</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h1 id="-prefix-sum">🔒🔒 Prefix Sum</h1><h2 id="-prefix-sum---array-数组">🔒 Prefix Sum - Array 数组</h2><ol><li>暴力穷举所有可能。<ol><li>对于 TwoSum 问题，一个难点就是给的数组无序。<li>对于一个无序的数组，我们似乎什么技巧也没有，只能暴力穷举所有可能。</ol></ol><p>一般情况下，我们会首先把数组排序再考虑双指针技巧。 HashMap 或者 HashSet 也可以帮助我们处理无序数组相关的简单问题。</p><ul><li>设计的核心在于权衡，利用不同的数据结构，可以得到一些针对性的加强。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">};</span>
        <span class="c1">// 让 sum 大一点</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">left</span><span class="o">++;</span>
        <span class="c1">// 让 sum 小一点</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">right</span><span class="o">--;</span>
    <span class="o">}</span>
    <span class="c1">// 不存在这样两个数</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="167-two-sum-ii---input-array-is-sorted">167. Two Sum II - Input Array Is Sorted</h3><p><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">167. Two Sum II - Input Array Is Sorted</a></p><p>Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order,</p><ul><li>find two numbers such that they add up to a specific target number.<li>Let these two numbers be numbers[index1] and numbers[index2] where <code class="language-plaintext highlighter-rouge">1 &lt;= index1 &lt; index2 &lt;= numbers.length</code>.<li>Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.</ul><p>The tests are generated such that there is exactly one solution. You may not use the same element twice.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="c1">// 题目要求的索引是从 1 开始的</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="o">};</span>
        <span class="c1">// 让 sum 大一点</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">left</span><span class="o">++;</span>
        <span class="c1">// 让 sum 小一点</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">right</span><span class="o">--;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-binarysearch">+++++ BinarySearch</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// Time : O(nlogn)</span>
<span class="c1">// space : O(1)</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
           <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">binarySearch</span><span class="o">(</span><span class="n">numbers</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">target</span><span class="o">-</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
           <span class="k">if</span><span class="o">(</span><span class="n">pos</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="o">};</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><h4 id="-hashmap-1">+++++ HashMap</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// Time : O(n)</span>
<span class="c1">// space : O(n)</span>
<span class="c1">// Runtime: 4 ms, faster than 16.01% of Java online submissions for Two Sum II - Input Array Is Sorted.</span>
<span class="c1">// Memory Usage: 42.3 MB, less than 7.27% of Java online submissions for Two Sum II - Input Array Is Sorted.</span>
<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">index</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 构造一个哈希表：元素映射到相应的索引</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">index</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">other</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="c1">// 如果 other 存在且不是 numbers[i] 本身</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">other</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">index</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">other</span><span class="o">)</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">index</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">other</span><span class="o">)+</span><span class="mi">1</span><span class="o">};</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{};</span>
<span class="o">}</span>

<span class="c1">// Runtime: 4 ms, faster than 20.33% of Java online submissions for Two Sum II - Input Array Is Sorted.</span>
<span class="c1">// Memory Usage: 50.5 MB, less than 13.31% of Java online submissions for Two Sum II - Input Array Is Sorted.</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">target</span><span class="o">-</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target</span><span class="o">-</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]),</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">};</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{};</span>
    <span class="o">}</span>

</pre></table></code></div></div><h4 id="-two-pointers-start-from-2-sides">+++++ Two pointers <code class="language-plaintext highlighter-rouge">start from 2 sides</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// Time : O(n)</span>
<span class="c1">// space : O(1)</span>
<span class="c1">// Runtime: 1 ms, faster than 53.58% of Java online submissions for Two Sum II - Input Array Is Sorted.</span>
<span class="c1">// Memory Usage: 41.5 MB, less than 14.83% of Java online submissions for Two Sum II - Input Array Is Sorted.</span>
<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="n">numbers</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">!=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="n">numbers</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">r</span><span class="o">--;</span>
        <span class="k">else</span> <span class="n">l</span><span class="o">++;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">l</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{};</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">};</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="653-two-sum-iv---input-is-a-bst-easy-1">653. Two Sum IV - Input is a BST (Easy)</h3><p><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/">653. Two Sum IV - Input is a BST (Easy)</a> Given the root of a Binary Search Tree and a target number k,</p><ul><li>return true if there exist two elements in the BST such that their sum is equal to the given target.</ul><p>Example 1: Input: root = [5,3,6,2,4,null,7], k = 9 Output: true</p><hr /><h3 id="238-product-of-array-except-self-medium">238. Product of Array Except Self (Medium)</h3><p><a href="https://leetcode.com/problems/product-of-array-except-self/">238. Product of Array Except Self</a> Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].</p><p>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</p><p>You must write an algorithm that runs in O(n) time and <strong>without using the division operation</strong>.</p><p>Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6]</p><p>Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0]</p><h4 id="-左乘-右乘-resulti--lefti--righti">+++++ <code class="language-plaintext highlighter-rouge">左乘 右乘 result[i] = left[i] * right[i];</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.</span>
<span class="c1">// Memory Usage: 51 MB, less than 82.69% of Java online submissions for Product of Array Except Self.</span>
<span class="c1">// O(N) time + O(N) space</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">productExceptSelf</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

        <span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">right</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">left</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">right</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-右边数字先计算-再参与计算">+++++ <code class="language-plaintext highlighter-rouge">右边数字先计算 再参与计算</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// O(N) time + O(1) space</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">productExceptSelf</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">*</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>

        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="n">right</span><span class="o">;</span>
            <span class="n">right</span> <span class="o">*=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-">+++++ ???????</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// O(N) time + O(1) space, single loop</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">productExceptSelf</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*=</span> <span class="n">left</span><span class="o">;</span>
            <span class="n">left</span> <span class="o">*=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">result</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">*=</span> <span class="n">right</span><span class="o">;</span>
            <span class="n">right</span> <span class="o">*=</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="724-find-pivot-index-easy">724. Find Pivot Index (Easy)</h3><p><a href="https://leetcode.com/problems/find-pivot-index/">724. Find Pivot Index</a> Given an array of integers nums, calculate the pivot index of this array.</p><p>The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index’s right.</p><p>If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.</p><p>Return the leftmost pivot index. If no such index exists, return -1.</p><p>Example 1: Input: nums = [1,7,3,6,5,6] Output: 3 Explanation: The pivot index is 3. Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 Right sum = nums[4] + nums[5] = 5 + 6 = 11</p><p>Example 2: Input: nums = [1,2,3] Output: -1 Explanation: There is no index that satisfies the conditions in the problem statement.</p><p>Example 3: Input: nums = [2,1,-1] Output: 0 Explanation: The pivot index is 0. Left sum = 0 (no elements to the left of index 0) Right sum = nums[1] + nums[2] = 1 + -1 = 0</p><h4 id="-brute-force-approach-for-i-adding-left-adding-right">++++++ Brute Force approach <code class="language-plaintext highlighter-rouge">for i: adding left, adding right</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 548 ms, faster than 5.02% of Java online submissions for Find Pivot Index.</span>
<span class="c1">// Memory Usage: 52.4 MB, less than 16.75% of Java online submissions for Find Pivot Index.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pivotIndex</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">++];</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">)</span> <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">--];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><h4 id="-2-pointer-left---numsi---right">++++++ <code class="language-plaintext highlighter-rouge">2 pointer, left - nums[i] - right</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 99.68% of Java online submissions for Find Pivot Index.</span>
<span class="c1">// Memory Usage: 52.6 MB, less than 14.35% of Java online submissions for Find Pivot Index.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pivotIndex</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">sum</span><span class="o">)</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">left</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Runtime: 2 ms, faster than 67.09% of Java online submissions for Find Pivot Index.</span>
<span class="c1">// Memory Usage: 51.7 MB, less than 28.06% of Java online submissions for Find Pivot Index.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pivotIndex</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">num</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="o">)</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">left</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-prefix-sum-for-i-sumi---numsi--sumn-1-sumi">++++++ <code class="language-plaintext highlighter-rouge">prefix sum. for i: sum[i] - nums[i] == sum[n-1]-sum[i]</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// TC : O(N)</span>
<span class="c1">// SC : O(1)</span>
<span class="c1">// Runtime: 1 ms, faster than 99.68% of Java online submissions for Find Pivot Index.</span>
<span class="c1">// Memory Usage: 42.8 MB, less than 72.79% of Java online submissions for Find Pivot Index.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">pivotIndex</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">sum</span><span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">sum</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">sum</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">sum</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">sum</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">]-</span><span class="n">sum</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="747-largest-number-at-least-twice-of-others-easy">747. Largest Number At Least Twice of Others (Easy)</h2><p><a href="https://leetcode.com/problems/largest-number-at-least-twice-of-others/">747. Largest Number At Least Twice of Others</a> You are given an integer array nums where the largest integer is unique.</p><p>Determine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise.</p><p>Example 1: Input: nums = [3,6,1,0] Output: 1 Explanation: 6 is the largest integer. For every other number in the array x, 6 is at least twice as big as x. The index of value 6 is 1, so we return 1.</p><p>Example 2: Input: nums = [1,2,3,4] Output: -1 Explanation: 4 is less than twice the value of 3, so we return -1.</p><p>Example 3: Input: nums = [1] Output: 0 Explanation: 1 is trivially at least twice the value as any other number because there are no other numbers.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>
</pre></table></code></div></div><hr /><h1 id="-one-pointer-左右指针">🔒🔒 One-pointer 左右指针</h1><hr /><h2 id="one-pointer">one pointer</h2><hr /><h3 id="oreo-count">oreo count</h3><p>Count down the Oreo.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Run</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">test</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count_o</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">count_re</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">original</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">point</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">point</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">point</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">point</span><span class="o">,</span> <span class="n">point</span><span class="o">+</span><span class="mi">4</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="s">"oreo"</span><span class="o">)){</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">point</span><span class="o">+</span><span class="mi">4</span><span class="o">;</span>
                <span class="n">original</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">point</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">point</span><span class="o">,</span> <span class="n">point</span><span class="o">+</span><span class="mi">2</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="s">"re"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">count_re</span><span class="o">++;</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">point</span><span class="o">+</span><span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">point</span><span class="o">)==</span><span class="sc">'o'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count_o</span><span class="o">++;</span>
                <span class="n">point</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// pair o is more than re, only care about o/2</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">count_o</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">count_re</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">){</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="n">count_o</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">count_o</span><span class="o">%</span><span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// re is more than pair o, only care about re</span>
        <span class="k">else</span> <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="n">count_re</span><span class="o">;</span>

        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"correct ans: 1 -&gt; "</span> <span class="o">+</span> <span class="s">"my: "</span> <span class="o">+</span> <span class="n">test</span><span class="o">(</span><span class="s">"o"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"correct ans: 2 -&gt; "</span> <span class="o">+</span> <span class="s">"my: "</span> <span class="o">+</span> <span class="n">test</span><span class="o">(</span><span class="s">"ooo"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"correct ans: 4 -&gt; "</span> <span class="o">+</span> <span class="s">"my: "</span> <span class="o">+</span> <span class="n">test</span><span class="o">(</span><span class="s">"rererereo"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"correct ans: 2 -&gt; "</span> <span class="o">+</span> <span class="s">"my: "</span> <span class="o">+</span> <span class="n">test</span><span class="o">(</span><span class="s">"oreoooo"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"correct ans: 2 -&gt; "</span> <span class="o">+</span> <span class="s">"my: "</span> <span class="o">+</span> <span class="n">test</span><span class="o">(</span><span class="s">"ooreoreoo"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"correct ans: 5 -&gt; "</span> <span class="o">+</span> <span class="s">"my: "</span> <span class="o">+</span> <span class="n">test</span><span class="o">(</span><span class="s">"ooooooorererereoore"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"correct ans: 15 -&gt; "</span> <span class="o">+</span> <span class="s">"my: "</span> <span class="o">+</span> <span class="n">test</span><span class="o">(</span><span class="s">"oooooooooooooooooooooooooooorererereoore"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"correct ans: 0 -&gt; "</span> <span class="o">+</span> <span class="s">"my: "</span> <span class="o">+</span> <span class="n">test</span><span class="o">(</span><span class="s">"oreooreooreo"</span><span class="o">));</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h1 id="-two-pointer-左右指针">🔒🔒 Two-pointer 左右指针</h1><ul><li><a href="https://leetcode.com/tag/two-pointers/">https://leetcode.com/tag/two-pointers/</a></ul><p>只要数组有序，就应该想到双指针技巧</p><hr /><h2 id="two-pointer--bs---二分查找--在有序数组中搜索指定元素">two pointer + BS - 二分查找 / 在有序数组中搜索指定元素</h2><p>最简单的二分算法，旨在突出它的双指针特性：</p><ul><li>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。<li>left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// int mid = (right + left) / 2;</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="153-find-minimum-in-rotated-sorted-array-medium">153. Find Minimum in Rotated Sorted Array Medium</h3><p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153. Find Minimum in Rotated Sorted Array</a></p><p>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:</p><ul><li>[4,5,6,7,0,1,2] if it was rotated 4 times.<li>[0,1,2,4,5,6,7] if it was rotated 7 times.<li>Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]].</ul><p>Given the sorted rotated array nums of unique elements, return the minimum element of this array.</p><p>You must write an algorithm that runs in <code class="language-plaintext highlighter-rouge">O(log n)</code> time.</p><p>Example 1: Input: nums = [3,4,5,1,2] Output: 1 Explanation: The original array was [1,2,3,4,5] rotated 3 times.</p><p>Example 2: Input: nums = [4,5,6,7,0,1,2] Output: 0 Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.</p><h4 id="-2-pointer--bs-lmr---numsmnumsm-1-return-numsm">+++++ <code class="language-plaintext highlighter-rouge">2 pointer + BS, l,m,r -&gt; nums[m]&lt;nums[m-1] return nums[m]</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Find Minimum in Rotated Sorted Array.</span>
<span class="c1">// Memory Usage: 41.6 MB, less than 94.52% of Java online submissions for Find Minimum in Rotated Sorted Array.</span>
<span class="cm">/**
 * Modified Binary Search
 *
 * Time Complexity: O(log N)
 *
 * Space Complexity: O(1)
 *
 * N = Length of the input array.
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMin</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">m</span><span class="o">=(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
            <span class="c1">// System.out.println(nums[l] + ", " + nums[m] + ", " + nums[r]);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">m</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">m</span><span class="o">]&lt;</span><span class="n">nums</span><span class="o">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="n">m</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]&lt;=</span><span class="n">nums</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">m</span><span class="o">]&gt;</span><span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">])</span> <span class="n">l</span><span class="o">=</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">else</span> <span class="n">r</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="寻找右侧边界的二分查找">寻找右侧边界的二分查找</h3><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">left_bound</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="c1">// 搜索区间为 [left, right]</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="c1">// 搜索区间变为 [mid+1, right]</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// 搜索区间变为 [left, mid-1]</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// 收缩右侧边界</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 检查出界情况</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">right</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">!=</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">right</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="33-search-in-rotated-sorted-array-medium">33. Search in Rotated Sorted Array (Medium)</h3><p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a></p><p>There is an integer array nums sorted in ascending order (with distinct values).</p><p>Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].</p><p>Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</p><p>You must write an algorithm with O(log n) runtime complexity.</p><p>Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4</p><p>Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1</p><p>Example 3: Input: nums = [1], target = 0 Output: -1</p><h4 id="-bs-chop">++++++ <code class="language-plaintext highlighter-rouge">BS chop</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 68.23% of Java online submissions for Search in Rotated Sorted Array.</span>
<span class="c1">// Memory Usage: 42.7 MB, less than 50.59% of Java online submissions for Search in Rotated Sorted Array.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">searchTarget</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">searchTarget</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">m</span><span class="o">=(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
            <span class="c1">// base case:</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">m</span><span class="o">]==</span><span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="n">m</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">])</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

            <span class="c1">// if left part in good order</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">m</span><span class="o">]){</span>
                <span class="c1">// l &lt; t &lt; m, drop right part</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">m</span><span class="o">])</span> <span class="n">r</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="c1">// l &lt; m &lt; t, drop left part</span>
                <span class="k">else</span> <span class="n">l</span><span class="o">=</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// if left part: small, 0 , big</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// m &lt; t &lt; r, drop left part</span>
                <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">])</span> <span class="n">l</span><span class="o">=</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
                <span class="c1">// t &lt; m &lt; r, drop right part</span>
                <span class="k">else</span> <span class="n">r</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">?</span> <span class="n">l</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="34-find-first-and-last-position-of-element-in-sorted-array-medium-寻找左右边界的二分搜索">34. Find First and Last Position of Element in Sorted Array (Medium) 寻找左右边界的二分搜索</h3><p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></p><p>Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.</p><p>If target is not found in the array, return [-1, -1].</p><p>You must write an algorithm with O(log n) runtime complexity.</p><p>Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]</p><h4 id="-bs-find-first--find-last">+++++ <code class="language-plaintext highlighter-rouge">BS: find first + find last</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Find First and Last Position of Element in Sorted Array.</span>
<span class="c1">// Memory Usage: 44.4 MB, less than 6.19% of Java online submissions for Find First and Last Position of Element in Sorted Array.</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">searchRange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">==</span><span class="kc">null</span> <span class="o">||</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">1</span><span class="o">,-</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">findFirst</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
        <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">findLast</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">findFirst</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">target</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">m</span><span class="o">])</span> <span class="n">r</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">else</span> <span class="n">l</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="n">res</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">findLast</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">)</span> <span class="n">l</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">else</span> <span class="n">r</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="n">res</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="704-binary-search-寻找一个数基本的二分搜索">704. Binary Search 寻找一个数（基本的二分搜索）</h3><ul><li>初始化 right 的赋值是 nums.length - 1，最后一个元素的索引，而不是 nums.length。<li><code class="language-plaintext highlighter-rouge">nums.length - 1</code> 两端都闭区间 [left, right]<ul><li>while(left &lt;= right) 的终止条件是 left == right + 1，<li>[right + 1, right]，<li>或者带个具体的数字进去 [3, 2]，可见这时候区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</ul><li><code class="language-plaintext highlighter-rouge">nums.length</code> 左闭右开区间 [left, right)<ul><li>while(left &lt; right) 的终止条件是 left == right [right, right]，<li>或者带个具体的数字进去 [2, 2]，这时候区间非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</ul></ul><p><a href="https://leetcode.com/problems/binary-search/">704. Binary Search</a></p><p>Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.</p><p>You must write an algorithm with O(log n) runtime complexity.</p><p>Example 1:</p><p>Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Binary Search.</span>
<span class="c1">// Memory Usage: 51.7 MB, less than 16.03% of Java online submissions for Binary Search.</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">right</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">left</span><span class="o">&lt;=</span><span class="n">right</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]==</span><span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]&lt;</span><span class="n">target</span><span class="o">)</span> <span class="n">left</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]&gt;</span><span class="n">target</span><span class="o">)</span> <span class="n">right</span><span class="o">=</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>这个算法存在局限性。<li>比如说给你有序数组 nums = [1,2,2,2,3]，target 为 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。</ul><hr /><h3 id="寻找左侧边界的二分搜索">寻找左侧边界的二分搜索</h3><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">left_bound</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="c1">// 注意</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 注意</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span> <span class="c1">// 注意</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="nf">left_bound</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="c1">// 搜索区间为 [left, right]</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="c1">// 搜索区间变为 [mid+1, right]</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// 搜索区间变为 [left, mid-1]</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// 收缩右侧边界</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 检查出界情况</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">!=</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="278-first-bad-version">278. First Bad Version</h3><p><a href="https://leetcode.com/problems/first-bad-version/">278. First Bad Version</a></p><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p><p>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</p><p>You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p><p>Example 1:</p><p>Input: n = 5, bad = 4 Output: 4 Explanation: call isBadVersion(3) -&gt; false call isBadVersion(5) -&gt; true call isBadVersion(4) -&gt; true Then 4 is the first bad version.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 13 ms, faster than 49.29% of Java online submissions for First Bad Version.</span>
<span class="c1">// Memory Usage: 36.1 MB, less than 29.13% of Java online submissions for First Bad Version.</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">firstBadVersion</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isBadVersion</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">right</span><span class="o">=</span><span class="n">n</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">left</span><span class="o">&lt;</span><span class="n">right</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span><span class="o">+(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isBadVersion</span><span class="o">(</span><span class="n">mid</span><span class="o">))</span> <span class="n">right</span><span class="o">=</span><span class="n">mid</span><span class="o">;</span>
        <span class="k">else</span> <span class="n">left</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="二分搜索算法运用">二分搜索算法运用</h3><p>二分搜索的原型就是在「有序数组」中搜索一个元素target，返回该元素对应的索引。</p><ul><li><p>如果该元素不存在，那可以返回一个什么特殊值，这种细节问题只要微调算法实现就可实现。</p><li><p>还有一个重要的问题，如果「有序数组」中存在多个target元素，那么这些元素肯定挨在一起，这里就涉及到算法应该返回最左侧的那个target元素的索引还是最右侧的那个target元素的索引，「搜索左侧边界」和「搜索右侧边界」</p></ul><p>从题目中抽象出一个自变量 x，一个关于 x 的函数 f(x)，以及一个目标值 target。</p><ul><li><p>同时，x, f(x), target 还要满足以下条件：</p><li><p>1、f(x) 必须是在 x 上的单调函数（单调增单调减都可以）。</p><li><p>2、题目是让你计算满足约束条件 f(x) == target 时的 x 的值。</p></ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">f</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="nf">left_bound</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="c1">// 当找到 target 时，收缩右侧边界</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">mid</span><span class="o">,</span> <span class="n">nums</span><span class="o">)</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">mid</span><span class="o">,</span> <span class="n">nums</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">mid</span><span class="o">,</span> <span class="n">nums</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
<span class="o">}</span>


<span class="c1">// 主函数，在 f(x) == target 的约束下求 x 的最值</span>
<span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="c1">// 问自己：自变量 x 的最小值是多少？</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="o">...;</span>
    <span class="c1">// 问自己：自变量 x 的最大值是多少？</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="o">...</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">mid</span><span class="o">)</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 问自己：题目是求左边界还是右边界？</span>
            <span class="c1">// ...</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">mid</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 问自己：怎么让 f(x) 大一点？</span>
            <span class="c1">// ...</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">mid</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 问自己：怎么让 f(x) 小一点？</span>
            <span class="c1">// ...</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="875-koko-eating-bananas">875. Koko Eating Bananas</h3><p><a href="https://leetcode.com/problems/koko-eating-bananas/">875. Koko Eating Bananas</a></p><p>Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.</p><p>Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.</p><p>Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.</p><p>Return the minimum integer k such that she can eat all the bananas within h hours.</p><p>Example 1:</p><p>Input: piles = [3,6,7,11], h = 8 Output: 4</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 21 ms, faster than 37.05% of Java online submissions for Koko Eating Bananas.</span>
<span class="c1">// Memory Usage: 52.4 MB, less than 7.41% of Java online submissions for Koko Eating Bananas.</span>

<span class="c1">// 定义：速度为 x 时，需要 f(x) 小时吃完所有香蕉</span>
<span class="c1">// f(x) 随着 x 的增加单调递减</span>
<span class="kt">int</span> <span class="nf">f</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">piles</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">hours</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">piles</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">hours</span> <span class="o">+=</span> <span class="n">piles</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">/</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">piles</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">%</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">hours</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">hours</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">minEatingSpeed</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">piles</span><span class="o">,</span> <span class="kt">int</span> <span class="no">H</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">1000000000</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

        <span class="c1">// // 搜索左侧边界，则需要收缩右侧边界</span>
        <span class="c1">// if (f(piles, mid) == H) right = mid;</span>
        <span class="c1">// // 需要让 f(x) 的返回值大一些</span>
        <span class="c1">// else if (f(piles, mid) &lt; H) right = mid;</span>
        <span class="c1">// // 需要让 f(x) 的返回值小一些</span>
        <span class="c1">// else if (f(piles, mid) &gt; H) left = mid + 1;</span>

        <span class="c1">// if (f(piles, mid) &lt;= H) right = mid;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">piles</span><span class="o">,</span> <span class="n">mid</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="no">H</span><span class="o">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">// 需要让 f(x) 的返回值小一些</span>
        <span class="k">else</span> <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="运送货物">运送货物？？？？？？？？？？？？？？</h3><p><a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/">1011. Capacity To Ship Packages Within D Days</a></p><p>A conveyor belt has packages that must be shipped from one port to another within days days.</p><p>The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.</p><p>Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.</p><p>Example 1:</p><p>Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5 Output: 15</p><p>x = capacity target = D weights[i]</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">f</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">weights</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">days</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">wei</span> <span class="o">:</span> <span class="n">weights</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">wei</span><span class="o">&gt;</span><span class="n">x</span><span class="o">)</span>
        <span class="n">days</span> <span class="o">+=</span> <span class="o">(</span><span class="n">left</span><span class="o">+</span><span class="n">wei</span><span class="o">)/</span><span class="n">x</span><span class="o">;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span><span class="o">+</span><span class="n">wei</span><span class="o">)%</span><span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">days</span><span class="o">;</span>
<span class="o">}</span>



<span class="kd">public</span> <span class="kt">int</span> <span class="nf">shipWithinDays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">weights</span><span class="o">,</span> <span class="kt">int</span> <span class="n">days</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">right</span><span class="o">=</span>
<span class="o">}</span>


</pre></table></code></div></div><hr /><h3 id="httpslabuladonggithubioalgo22159-">https://labuladong.github.io/algo/2/21/59/ ？？？？</h3><hr /><hr /><h3 id="344-reverse-string-反转数组">344. Reverse String 反转数组</h3><p>一般编程语言都会提供 reverse 函数</p><p><a href="https://leetcode.com/problems/reverse-string/">344. Reverse String</a></p><p>Write a function that reverses a string. The input string is given as an array of characters s.</p><p>You must do this by modifying the input array in-place with O(1) extra memory.</p><p>反转一个 char[] 类型的字符数组</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 95.40% of Java online submissions for Reverse String.</span>
<span class="c1">// Memory Usage: 45.6 MB, less than 89.34% of Java online submissions for Reverse String.</span>

<span class="kt">void</span> <span class="nf">reverseString</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 交换 arr[left] 和 arr[right]</span>
        <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="n">left</span><span class="o">++;</span> <span class="n">right</span><span class="o">--;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="滑动窗口技巧-right-missing0-left">滑动窗口技巧 <code class="language-plaintext highlighter-rouge">right++, missing==0, left++</code></h3><p>维护一个窗口，不断滑动，然后更新答案么。</p><p>该算法的大致逻辑, 时间复杂度是 O(N)，比字符串暴力算法要高效得多。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
    <span class="c1">// 增大窗口</span>
    <span class="n">window</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="n">right</span><span class="o">]);</span>
    <span class="n">right</span><span class="o">++;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">window</span> <span class="n">needs</span> <span class="n">shrink</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 缩小窗口</span>
        <span class="n">window</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="n">left</span><span class="o">]);</span>
        <span class="n">left</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="cm">/* 滑动窗口算法框架 */</span>
<span class="kt">void</span> <span class="nf">slidingWindow</span><span class="o">(</span><span class="n">string</span> <span class="n">s</span><span class="o">,</span> <span class="n">string</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">need</span><span class="o">,</span> <span class="n">window</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">t</span><span class="o">)</span> <span class="n">need</span><span class="o">[</span><span class="n">c</span><span class="o">]++;</span>

    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// c 是将移入窗口的字符</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="c1">// 右移窗口</span>
        <span class="n">right</span><span class="o">++;</span>
        <span class="c1">// 进行窗口内数据的一系列更新</span>
        <span class="o">...</span>

        <span class="cm">/*** debug 输出的位置 ***/</span>
        <span class="n">printf</span><span class="o">(</span><span class="s">"window: [%d, %d)\n"</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
        <span class="cm">/********************/</span>

        <span class="c1">// 判断左侧窗口是否要收缩</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">window</span> <span class="n">needs</span> <span class="n">shrink</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// d 是将移出窗口的字符</span>
            <span class="kt">char</span> <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
            <span class="c1">// 左移窗口</span>
            <span class="n">left</span><span class="o">++;</span>
            <span class="c1">// 进行窗口内数据的一系列更新</span>
            <span class="o">...</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="76-minimum-window-substring-最小覆盖子串">76. Minimum Window Substring 最小覆盖子串</h3><p><a href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring</a></p><ul><li>Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window.<li>If there is no such substring, return the empty string “”.<li>The testcases will be generated such that the answer is unique.<li>A substring is a contiguous sequence of characters within the string.</ul><p>暴力解法，代码大概是这样的：</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">[</span><span class="nl">i:</span><span class="n">j</span><span class="o">]</span> <span class="n">包含</span> <span class="n">t</span> <span class="nl">的所有字母:</span>
            <span class="n">更新答案</span>

</pre></table></code></div></div><p>滑动窗口算法的思路:</p><ol><li><p>我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」。</p><li><p>我们先不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。</p><li><p>此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</p><li><p>重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</p></ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">minWindow</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">need</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="nl">i:</span><span class="n">t</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="n">need</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">need</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// {A:2, B:1}</span>

    <span class="kt">int</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()+</span><span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">right</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">valid</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">missing</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="c1">//The number of chars are missing.</span>

    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">win</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="k">while</span><span class="o">(</span><span class="n">right</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
        <span class="n">right</span><span class="o">++;</span>

        <span class="kt">char</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">need</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">x</span><span class="o">)){</span>
            <span class="n">win</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">win</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">win</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">==</span> <span class="n">need</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="n">valid</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="k">while</span><span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="n">need</span><span class="o">.</span><span class="na">size</span><span class="o">()){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">){</span>
                <span class="n">start</span><span class="o">=</span><span class="n">left</span><span class="o">;</span>
                <span class="n">len</span> <span class="o">=</span> <span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="kt">char</span> <span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
            <span class="n">left</span><span class="o">++;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">need</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">y</span><span class="o">)){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">win</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">==</span> <span class="n">need</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="n">valid</span><span class="o">--;</span>
                <span class="n">win</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">win</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">y</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">len</span><span class="o">==</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()+</span><span class="mi">1</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span><span class="n">start</span><span class="o">+</span><span class="n">len</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// Runtime: 10 ms, faster than 70.54% of Java online submissions for Minimum Window Substring.</span>
<span class="c1">// Memory Usage: 39.1 MB, less than 82.86% of Java online submissions for Minimum Window Substring.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">minWindow</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">==</span><span class="kc">null</span> <span class="o">||</span> <span class="n">t</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Input string is null"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">();</span><span class="n">i</span><span class="o">++)</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">right</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">len</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">missing</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">right</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="kt">char</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">x</span><span class="o">)){</span>
                <span class="kt">int</span> <span class="n">countX</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">countX</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">missing</span><span class="o">--;</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">countX</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">right</span><span class="o">++;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">missing</span><span class="o">==</span><span class="mi">0</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">){</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">left</span><span class="o">;</span>
                    <span class="n">len</span> <span class="o">=</span> <span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="kt">char</span> <span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">y</span><span class="o">)){</span>
                    <span class="kt">int</span> <span class="n">countY</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">countY</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">missing</span><span class="o">++;</span>
                    <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">countY</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">len</span><span class="o">==</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">start</span><span class="o">+</span><span class="n">len</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="567-permutation-in-string-字符串排列">567. Permutation in String 字符串排列</h3><p><a href="https://leetcode.com/problems/permutation-in-string/">567. Permutation in String</a></p><p>Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.</p><p>In other words, return true if one of s1’s permutations is the substring of s2.</p><p>Example 1:</p><p>Input: s1 = “ab”, s2 = “eidbaooo” Output: true Explanation: s2 contains one permutation of s1 (“ba”).</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
</pre><td class="rouge-code"><pre><span class="c1">// 判断 s 中是否存在 t 的排列</span>
<span class="n">bool</span> <span class="nf">checkInclusion</span><span class="o">(</span><span class="n">string</span> <span class="n">t</span><span class="o">,</span> <span class="n">string</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">need</span><span class="o">,</span> <span class="n">window</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">t</span><span class="o">)</span> <span class="n">need</span><span class="o">[</span><span class="n">c</span><span class="o">]++;</span>

    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="n">right</span><span class="o">++;</span>
        <span class="c1">// 进行窗口内数据的一系列更新</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">need</span><span class="o">.</span><span class="na">count</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">window</span><span class="o">[</span><span class="n">c</span><span class="o">]++;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">window</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">==</span> <span class="n">need</span><span class="o">[</span><span class="n">c</span><span class="o">])</span>
                <span class="n">valid</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">// 判断左侧窗口是否要收缩</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 在这里判断是否找到了合法的子串</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="n">need</span><span class="o">.</span><span class="na">size</span><span class="o">())</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="kt">char</span> <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
            <span class="n">left</span><span class="o">++;</span>
            <span class="c1">// 进行窗口内数据的一系列更新</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">need</span><span class="o">.</span><span class="na">count</span><span class="o">(</span><span class="n">d</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">window</span><span class="o">[</span><span class="n">d</span><span class="o">]</span> <span class="o">==</span> <span class="n">need</span><span class="o">[</span><span class="n">d</span><span class="o">])</span>
                    <span class="n">valid</span><span class="o">--;</span>
                <span class="n">window</span><span class="o">[</span><span class="n">d</span><span class="o">]--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 未找到符合条件的子串</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// Runtime: 12 ms, faster than 48.78% of Java online submissions for Permutation in String.</span>
<span class="c1">// Memory Usage: 38.9 MB, less than 91.88% of Java online submissions for Permutation in String.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">checkInclusion</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">==</span><span class="kc">null</span> <span class="o">||</span> <span class="n">s2</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Input string is null"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()&gt;</span><span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">right</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">=</span><span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">missing</span><span class="o">=</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span><span class="n">i</span><span class="o">++)</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>

        <span class="k">while</span><span class="o">(</span><span class="n">right</span><span class="o">&lt;</span><span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="kt">char</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">x</span><span class="o">)){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">missing</span><span class="o">--;</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">right</span><span class="o">++;</span>

            <span class="k">while</span><span class="o">(</span><span class="n">missing</span><span class="o">==</span><span class="mi">0</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">==</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="kt">char</span> <span class="n">y</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">y</span><span class="o">)){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">y</span><span class="o">)==</span><span class="mi">0</span><span class="o">)</span> <span class="n">missing</span><span class="o">++;</span>
                    <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">y</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="438-find-all-anagrams-in-a-string-找所有字母异位词">438. Find All Anagrams in a String 找所有字母异位词</h3><p><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">438. Find All Anagrams in a String</a></p><ul><li>Given two strings s and p,<li>return an array of all the start indices of <code class="language-plaintext highlighter-rouge">p's anagrams in s</code>.<li>You may return the answer in any order.<li>An <code class="language-plaintext highlighter-rouge">Anagram</code> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</ul><p>Example 1:</p><p>Input: s = “cbaebabacd”, p = “abc” Output: [0,6]</p><ol><li>size same<li>missing==0</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 29 ms, faster than 34.79% of Java online submissions for Find All Anagrams in a String.</span>
<span class="c1">// Memory Usage: 45.6 MB, less than 10.47% of Java online submissions for Find All Anagrams in a String.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">findAnagrams</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span><span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">right</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">missing</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

        <span class="k">while</span><span class="o">(</span><span class="n">right</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="kt">char</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">x</span><span class="o">)){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">missing</span><span class="o">--;</span>
                <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">right</span><span class="o">++;</span>

            <span class="k">while</span><span class="o">(</span><span class="n">missing</span><span class="o">==</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">left</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">==</span><span class="n">p</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
                <span class="kt">char</span> <span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">y</span><span class="o">)){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">y</span><span class="o">)==</span><span class="mi">0</span><span class="o">)</span> <span class="n">missing</span><span class="o">++;</span>
                    <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">y</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="3-longest-substring-without-repeating-characters-最长无重复子串">3. Longest Substring Without Repeating Characters 最长无重复子串</h3><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters</a></p><p>Given a string s, find the length of the longest substring without repeating characters.</p><p>Example 1:</p><p>Input: s = “abcabcbb” Output: 3 Explanation: The answer is “abc”, with the length of 3.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">right</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">res</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>

    <span class="k">while</span><span class="o">(</span><span class="n">right</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
        <span class="kt">char</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">right</span><span class="o">++;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)&gt;</span><span class="mi">1</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
            <span class="n">left</span><span class="o">++;</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">y</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">res</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">res</span><span class="o">,</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="-two-pointer---array-数组">🔒 two pointer - Array 数组</h2><p>原地修改数组</p><p>数组</p><ul><li>在尾部插入、删除元素是比较高效的，时间复杂度是<code class="language-plaintext highlighter-rouge">1</code>，<li>在中间或者开头插入、删除元素，就会涉及数据的搬移，时间复杂度为<code class="language-plaintext highlighter-rouge">O(N)</code>，效率较低。</ul><p>Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.</p><p>如何在原地修改数组，避免数据的搬移。</p><ul><li>如果不是原地修改的话，直接 new 一个 int[] 数组，把去重之后的元素放进这个新数组中，然后返回这个新数组即可。<li>原地删除不允许 new 新数组，只能在原数组上操作，然后返回一个长度，这样就可以通过返回的长度和原始数组得到我们去重后的元素有哪些了。</ul><hr /><h3 id="11-container-with-most-water-medium">11. Container With Most Water (Medium)</h3><p><a href="https://leetcode.com/problems/container-with-most-water/">11. Container With Most Water</a> You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).</p><p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p><p>Return the maximum amount of water a container can store.</p><p>Notice that you may not slant the container.</p><p>Input: height = [1,8,6,2,5,4,8,3,7] Output: 49</p><ol><li>Brute Force<ol><li>the total states is C(n, 2)= n * (n - 1) / 2, we have to enumerate all these states to get the max area.</ol></ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// Time Complexity: O(n^2)</span>
<span class="c1">// Space Complexity: O(1)</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxArea</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">curxa</span> <span class="o">=</span> <span class="n">i</span><span class="o">,</span> <span class="n">curya</span><span class="o">=</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">curxb</span> <span class="o">=</span> <span class="n">j</span><span class="o">,</span> <span class="n">curyb</span><span class="o">=</span><span class="n">height</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="o">(</span><span class="n">curxb</span><span class="o">-</span><span class="n">curxa</span><span class="o">)</span> <span class="o">*</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">curya</span><span class="o">,</span><span class="n">curyb</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
</pre></table></code></div></div><h4 id="-2-pointer-l-r--">+++++ 2 pointer <code class="language-plaintext highlighter-rouge">l++, r--</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="c1">// Time Complexity: O(n)</span>
<span class="c1">// Space Complexity: O(1)</span>


<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

<span class="c1">// Runtime: 4 ms, faster than 70.57% of Java online submissions for Container With Most Water.</span>
<span class="c1">// Memory Usage: 73.6 MB, less than 64.81% of Java online submissions for Container With Most Water.</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxArea</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="n">j</span><span class="o">=</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">j</span><span class="o">;</span> <span class="o">){</span>
            <span class="c1">// get current area</span>
            <span class="kt">int</span> <span class="n">area</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">height</span><span class="o">[</span><span class="n">j</span><span class="o">])*(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">);</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">area</span><span class="o">,</span><span class="n">result</span><span class="o">);</span>
            <span class="c1">//move the pointers</span>
            <span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]&lt;</span><span class="n">height</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">i</span><span class="o">++;</span>
            <span class="k">else</span> <span class="n">j</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

<span class="c1">// Runtime: 3 ms, faster than 93.93% of Java online submissions for Container With Most Water.</span>
<span class="c1">// Memory Usage: 81.4 MB, less than 25.65% of Java online submissions for Container With Most Water.</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxArea</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">max</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="n">ar</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">=</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">r</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">r</span><span class="o">]&lt;</span><span class="n">height</span><span class="o">[</span><span class="n">l</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">ar</span><span class="o">=(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">)*(</span><span class="n">height</span><span class="o">[</span><span class="n">r</span><span class="o">]);</span>
                <span class="n">r</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">ar</span><span class="o">=(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">)*(</span><span class="n">height</span><span class="o">[</span><span class="n">l</span><span class="o">]);</span>
                <span class="n">l</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// max=Math.max(max,ar);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ar</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="n">max</span> <span class="o">=</span> <span class="n">ar</span><span class="o">;</span> <span class="c1">// better</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="121-best-time-to-buy-and-sell-stock-easy">121. Best Time to Buy and Sell Stock (Easy)</h3><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">121. Best Time to Buy and Sell Stock</a> You are given an array prices where prices[i] is the price of a given stock on the ith day.</p><p>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.</p><p>Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.</p><p>Example 1: Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</p><h4 id="-brute-force">+++++ brute force</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// O(n^2) time,</span>
<span class="c1">// O(1) space</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">profit</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">profit</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">profit</span><span class="o">,</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="n">prices</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">profit</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-2-pointer-求出最小前数算数求最大">+++++ <code class="language-plaintext highlighter-rouge">2 pointer 求出最小前数，算数求最大</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 83.90% of Java online submissions for Best Time to Buy and Sell Stock.</span>
<span class="c1">// Memory Usage: 83.7 MB, less than 55.95% of Java online submissions for Best Time to Buy and Sell Stock.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">lsf</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">lsf</span> <span class="o">&gt;</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="n">lsf</span> <span class="o">=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">lsf</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="n">cur</span><span class="o">)</span> <span class="n">res</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Runtime: 1 ms, faster than 100.00% of Java online submissions for Best Time to Buy and Sell Stock.</span>
<span class="c1">// Memory Usage: 59 MB, less than 72.76% of Java online submissions for Best Time to Buy and Sell Stock.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">walk:</span><span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">walk</span><span class="o">);</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">walk</span><span class="o">-</span><span class="n">min</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="83-remove-duplicates-from-sorted-list-有序链表去重-快慢指针前后走">83. Remove Duplicates from Sorted List 有序链表去重 <code class="language-plaintext highlighter-rouge">快慢指针前后走</code></h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/submissions/">83. Remove Duplicates from Sorted List</a></p><p>Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.</p><p>Input: head = [1,1,2] Output: [1,2]</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nc">ListNode</span> <span class="nf">deleteDuplicates</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span> <span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fast</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">slow</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">slow</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">fast</span><span class="o">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 断开与后面重复元素的连接</span>
    <span class="n">slow</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="python">python</h4><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">basic</span> <span class="kn">import</span> <span class="n">LinkedList</span><span class="p">,</span> <span class="n">Node</span>

<span class="c1"># 两个指针
# Runtime: 40 ms, faster than 84.87% of Python3 online submissions for Remove Duplicates from Sorted List.
# Memory Usage: 14.2 MB, less than 56.16% of Python3 online submissions for Remove Duplicates from Sorted List.
</span><span class="k">def</span> <span class="nf">deleteDuplicates</span><span class="p">(</span><span class="n">LL</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">LL</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="n">slow</span><span class="p">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">LL</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="n">LL</span><span class="p">.</span><span class="n">head</span>
    <span class="k">if</span> <span class="n">LL</span><span class="p">.</span><span class="n">head</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">LL</span><span class="p">.</span><span class="n">head</span>
    <span class="k">while</span> <span class="n">fast</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">slow</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">fast</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">slow</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">fast</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span>
    <span class="n">slow</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="c1"># print(LL.val)
</span>    <span class="k">return</span> <span class="n">LL</span>

<span class="c1"># 一个指针
</span><span class="k">def</span> <span class="nf">deleteDuplicates</span><span class="p">(</span><span class="n">LL</span><span class="p">):</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">LL</span><span class="p">.</span><span class="n">head</span>
    <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="ow">and</span> <span class="n">cur</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>     <span class="c1"># skip duplicated node
</span>        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>     <span class="c1"># not duplicate of current node, move to next node
</span>    <span class="k">return</span> <span class="n">LL</span>

<span class="c1"># nice for if the values weren't sorted in the linked list
</span><span class="k">def</span> <span class="nf">deleteDuplicates</span><span class="p">(</span><span class="n">LL</span><span class="p">):</span>
    <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">LL</span><span class="p">.</span><span class="n">head</span>
    <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">dic</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">LL</span><span class="p">.</span><span class="n">head</span>
    <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">dic</span><span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">]):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span>
    <span class="k">return</span> <span class="n">LL</span>

<span class="c1"># recursive
</span><span class="k">def</span> <span class="nf">deleteDuplicates</span><span class="p">(</span><span class="n">LL</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">LL</span><span class="p">.</span><span class="n">head</span><span class="p">:</span> <span class="k">return</span> <span class="n">LL</span>
    <span class="k">if</span> <span class="n">LL</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">LL</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">LL</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">LL</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">LL</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
            <span class="nf">deleteDuplicates</span><span class="p">(</span><span class="n">LL</span><span class="p">.</span><span class="n">head</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nf">deleteDuplicates</span><span class="p">(</span><span class="n">LL</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LL</span>

<span class="n">LL</span> <span class="o">=</span> <span class="nc">LinkedList</span><span class="p">()</span>
<span class="n">list_num</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">list_num</span><span class="p">:</span>
    <span class="n">LL</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="n">LL</span><span class="p">.</span><span class="nf">printLL</span><span class="p">()</span>

<span class="n">LL</span> <span class="o">=</span> <span class="nf">deleteDuplicates</span><span class="p">(</span><span class="n">LL</span><span class="p">)</span>
<span class="n">LL</span><span class="p">.</span><span class="nf">printLL</span><span class="p">()</span>
</pre></table></code></div></div><hr /><h3 id="26-remove-duplicates-from-sorted-array-有序数组去重简单快慢指针前后走">26. Remove Duplicates from Sorted Array 有序数组去重（简单）<code class="language-plaintext highlighter-rouge">快慢指针前后走</code></h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">26. Remove Duplicates from Sorted Array</a></p><p><img data-proofer-ignore data-src="https://i.imgur.com/71PNcPT.png" alt="Screen Shot 2021-10-10 at 10.21.49 PM" /></p><p>在数组相关的算法题中时非常常见的，通用解法就是使用快慢指针技巧。</p><ul><li>让慢指针 slow 走在后面，快指针 fast 走在前面探路<li>找到一个不重复的元素就告诉 slow 并让 slow 前进一步。<li>这样当 fast 指针遍历完整个数组 nums 后，<code class="language-plaintext highlighter-rouge">nums[0..slow]</code> 就是不重复元素。</ul><p>Input: nums = [1,1,2] Output: 2, nums = [1,2,_]</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 82.01% of Java online submissions for Remove Duplicates from Sorted Array.</span>
<span class="c1">// Memory Usage: 45.1 MB, less than 6.26% of Java online submissions for Remove Duplicates from Sorted Array.</span>
<span class="cm">/**
 * Using 2 pointers.
 *
 * Time Complexity: O(N)
 *
 * Space Complexity: O(1)
 *
 * N = Length of input array.
 */</span>
<span class="kt">int</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Input is invalid"</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">fast</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">slow</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">slow</span><span class="o">++;</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">slow</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">fast</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">fast</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">slow</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>



<span class="c1">// Runtime: 1 ms, faster than 82.01% of Java online submissions for Remove Duplicates from Sorted Array.</span>
<span class="c1">// Memory Usage: 44.3 MB, less than 23.95% of Java online submissions for Remove Duplicates from Sorted Array.</span>
<span class="kt">int</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Input is invalid"</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">slow</span><span class="o">])</span> <span class="n">nums</span><span class="o">[++</span><span class="n">slow</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="c1">// 数组长度为索引 + 1</span>
    <span class="k">return</span> <span class="n">slow</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 82.01% of Java online submissions for Remove Duplicates from Sorted Array.</span>
<span class="c1">// Memory Usage: 40.2 MB, less than 80.01% of Java online submissions for Remove Duplicates from Sorted Array.</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nums</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="python-1">python</h4><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="c1"># Method 1 +++++ new list
</span><span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="n">test_list</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">test_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
            <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="c1"># Method 2 +++++ new list
</span><span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="n">test_list</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="p">[</span><span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">test_list</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>

<span class="c1"># Method 3 -+++++ set(x)
</span><span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="n">test_list</span><span class="p">):</span>
    <span class="c1"># the ordering of the element is lost
</span>    <span class="n">test_list</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="n">test_list</span><span class="p">))</span>

<span class="c1"># Method 4 -+++++ Using list comprehension + enumerate()
</span><span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="n">test_list</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">test_list</span><span class="p">)]</span>

<span class="c1"># Method 5 : Using collections.OrderedDict.fromkeys()
</span><span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="n">test_list</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">.</span><span class="nf">fromkeys</span><span class="p">(</span><span class="n">test_list</span><span class="p">))</span>
    <span class="c1"># maintain the insertion order as well
</span>    <span class="n">res</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nb">dict</span><span class="p">.</span><span class="nf">fromkeys</span><span class="p">(</span><span class="n">test_list</span><span class="p">))</span>

<span class="c1"># Method 6 -+++++ 快慢指针
</span><span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="n">test_list</span><span class="p">):</span>
    <span class="c1"># Runtime: 72 ms, faster than 99.60% of Python3 online submissions for Remove Duplicates from Sorted Array.
</span>    <span class="c1"># Memory Usage: 15.7 MB, less than 45.93% of Python3 online submissions for Remove Duplicates from Sorted Array.
</span>    <span class="n">fast</span><span class="p">,</span> <span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">test_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">fast</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">test_list</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">test_list</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">test_list</span><span class="p">[</span><span class="n">fast</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">test_list</span><span class="p">[</span><span class="n">slow</span><span class="p">]</span> <span class="o">!=</span> <span class="n">test_list</span><span class="p">[</span><span class="n">fast</span><span class="p">]:</span>
            <span class="n">slow</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="n">test_list</span><span class="p">[</span><span class="n">slow</span><span class="p">]</span> <span class="o">=</span> <span class="n">test_list</span><span class="p">[</span><span class="n">fast</span><span class="p">]</span>
        <span class="n">fast</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">test_list</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">slow</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">slow</span><span class="o">+</span><span class="mi">1</span>

<span class="c1"># removeDuplicates([0,0,1,2,2,3,3])
</span></pre></table></code></div></div><hr /><h3 id="80-remove-duplicates-from-sorted-array-ii-numsinumsi-2">80. Remove Duplicates from Sorted Array II <code class="language-plaintext highlighter-rouge">nums[i]!=nums[i-2]</code></h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/">80. Remove Duplicates from Sorted Array II</a></p><p>Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.</p><p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.</p><p>Return k after placing the final result in the first k slots of nums.</p><p>Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.</p><p>Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_]</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Duplicates from Sorted Array II.</span>
<span class="c1">// Memory Usage: 39.3 MB, less than 39.45% of Java online submissions for Remove Duplicates from Sorted Array II.</span>
<span class="cm">/**
 * In place, one pass solution using 2 pointers
 *
 * Time Complexity: O(N)
 *
 * Space Complexity: O(1)
 *
 * N = Length of input array.
 */</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Input array is null"</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">insertPos</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">insertPos</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">nums</span><span class="o">[++</span><span class="n">insertPos</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">insertPos</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="fu-each-unique-element-should-appear-at-most-k-times">FU. Each unique element should appear at most K times</h3><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Follow-Up: Each unique element should appear at most K times.
 *
 * In place, one pass solution using 2 pointers
 *
 * Time Complexity: O(N-K)
 *
 * Space Complexity: O(1)
 *
 * N = Length of input array.
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">removeDuplicatesMoreThanK</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeDuplicatesMoreThanK</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Invalid Input"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="o">)</span> <span class="k">return</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">insertPos</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">insertPos</span> <span class="o">-</span> <span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)])</span> <span class="o">{</span>
                <span class="n">nums</span><span class="o">[++</span><span class="n">insertPos</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">insertPos</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="27-remove-element-移除元素-简单快慢指针前后走">27. Remove Element 移除元素 （简单）<code class="language-plaintext highlighter-rouge">快慢指针前后走</code></h3><p>把 nums 中所有值为 val 的元素原地删除，依然需要使用 <code class="language-plaintext highlighter-rouge">双指针技巧</code> 中的 <code class="language-plaintext highlighter-rouge">快慢指针</code>：</p><ul><li>如果 fast 遇到需要去除的元素，则直接跳过，<li>否则就告诉 slow 指针，并让 slow 前进一步。</ul><p><a href="https://leetcode.com/problems/remove-element/">27. Remove Element</a></p><p>Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.</p><p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.</p><p>Return k after placing the final result in the first k slots of nums.</p><p><code class="language-plaintext highlighter-rouge">Do not allocate extra space</code> for another array. You must do this by modifying the input array in-place with O(1) extra memory.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Element.</span>
<span class="c1">// Memory Usage: 38.9 MB, less than 24.52% of Java online submissions for Remove Element.</span>
<span class="cm">/**
 * Using Two Pointers. Output array maintains the order of the input array.
 *
 * Time Complexity: O(N)
 *
 * Space Complexity: O(1)
 *
 * N = Length of input array.
 */</span>
<span class="kt">int</span> <span class="nf">removeElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">fast</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">fast</span><span class="o">]</span> <span class="o">!=</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">slow</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">fast</span><span class="o">];</span>
            <span class="n">slow</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="n">fast</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Element.</span>
<span class="c1">// Memory Usage: 38.4 MB, less than 25.52% of Java online submissions for Remove Element.</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Input array is null"</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">slow</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]!=</span><span class="n">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">slow</span><span class="o">++]=</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="python-2">python</h4><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1"># Runtime: 32 ms, faster than 81.50% of Python3 online submissions for Remove Element.
# Memory Usage: 14.2 MB, less than 47.25% of Python3 online submissions for Remove Element.
</span><span class="k">def</span> <span class="nf">removeElement</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">slow</span><span class="p">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
    <span class="k">while</span> <span class="n">fast</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]</span>
            <span class="n">slow</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">fast</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># removeElement([0,0,1,2,2,3,3], 2)
</span></pre></table></code></div></div><hr /><h3 id="283-move-zeroes-移除0-快慢指针前后走">283. Move Zeroes 移除0 <code class="language-plaintext highlighter-rouge">快慢指针前后走</code></h3><p><a href="https://leetcode.com/problems/move-zeroes/">283. Move Zeroes</a></p><p>Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p><p>Note that you must do this in-place without making a copy of the array.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">moveZeroes</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 去除 nums 中的所有 0</span>
    <span class="c1">// 返回去除 0 之后的数组长度</span>
    <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">removeElement</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="c1">// 将 p 之后的所有元素赋值为 0</span>
    <span class="k">for</span> <span class="o">(;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">p</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 见上文代码实现</span>
<span class="kt">int</span> <span class="nf">removeElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">fast</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">fast</span><span class="o">]</span> <span class="o">!=</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">slow</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">fast</span><span class="o">];</span>
            <span class="n">slow</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="n">fast</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre><td class="rouge-code"><pre>
<span class="c1">#  = 移除0
# 两个指针
</span><span class="k">def</span> <span class="nf">moveZeroes</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="c1"># Runtime: 188 ms, faster than 17.89% of Python3 online submissions for Move Zeroes.
</span>    <span class="c1"># Memory Usage: 15.6 MB, less than 7.33% of Python3 online submissions for Move Zeroes.
</span>    <span class="n">slow</span><span class="p">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
    <span class="k">if</span> <span class="n">nums</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">fast</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]</span>
            <span class="n">slow</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">fast</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">slow</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

<span class="c1"># 一个指针
</span><span class="k">def</span> <span class="nf">moveZeroes</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="c1"># Runtime: 172 ms, faster than 25.48% of Python3 online submissions for Move Zeroes.
</span>    <span class="c1"># Memory Usage: 15.4 MB, less than 24.21% of Python3 online submissions for Move Zeroes.
</span>    <span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">nums</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">slow</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">slow</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">moveZeroes</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="c1"># Runtime: 248 ms, faster than 13.91% of Python3 online submissions for Move Zeroes.
</span>    <span class="c1"># Memory Usage: 15.2 MB, less than 88.67% of Python3 online submissions for Move Zeroes.
</span>    <span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">leng</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nums</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">leng</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">slow</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">slow</span><span class="p">,</span> <span class="n">leng</span><span class="p">):</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">nums</span>

<span class="c1"># Runtime: 260 ms, faster than 13.33% of Python3 online submissions for Move Zeroes.
# Memory Usage: 15.5 MB, less than 24.34% of Python3 online submissions for Move Zeroes.
</span><span class="k">def</span> <span class="nf">moveZeroes</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">]</span>
            <span class="n">slow</span> <span class="o">+=</span><span class="mi">1</span>

<span class="c1"># moveZeroes([0,1,0,3,12])
</span></pre></table></code></div></div><hr /><h3 id="349-intersection-of-two-arrays-easy">349. Intersection of Two Arrays (Easy)</h3><p><a href="https://leetcode.com/problems/intersection-of-two-arrays/">349. Intersection of Two Arrays</a> Given two integer arrays nums1 and nums2,</p><ul><li>return an array of their intersection.<li>Each element in the result must be unique and you may return the result in any order.</ul><p>Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2]</p><h4 id="-hashnum1-had-hashremovenum2-has-best">+++++ <code class="language-plaintext highlighter-rouge">Hash(num1 had), Hash.remove(num2 has)</code> BEST</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 95.44% of Java online submissions for Intersection of Two Arrays.</span>
<span class="c1">// Memory Usage: 38.9 MB, less than 87.06% of Java online submissions for Intersection of Two Arrays.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersection</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">nums1</span><span class="o">)</span> <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span> <span class="c1">// no repeat</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">num</span><span class="o">)){</span>
                <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
                <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">ans</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ans</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">ans</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-sorting-compare-get-the-same">+++++ <code class="language-plaintext highlighter-rouge">sorting, compare, get the same</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 95.33% of Java online submissions for Intersection of Two Arrays.</span>
<span class="c1">// Memory Usage: 38.9 MB, less than 86.77% of Java online submissions for Intersection of Two Arrays.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersection</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">pt1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">pt2</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">pt1</span> <span class="o">&lt;</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">pt2</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">pt1</span><span class="o">]&lt;</span><span class="n">nums2</span><span class="o">[</span><span class="n">pt2</span><span class="o">])</span> <span class="n">pt1</span> <span class="o">=</span> <span class="n">nextPT</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">pt1</span><span class="o">);</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">pt1</span><span class="o">]&gt;</span><span class="n">nums2</span><span class="o">[</span><span class="n">pt2</span><span class="o">])</span> <span class="n">pt2</span> <span class="o">=</span> <span class="n">nextPT</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">pt2</span><span class="o">);</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">pt1</span><span class="o">]);</span>
                <span class="n">pt1</span> <span class="o">=</span> <span class="n">nextPT</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">pt1</span><span class="o">);</span>
                <span class="n">pt2</span> <span class="o">=</span> <span class="n">nextPT</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">pt2</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">ans</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">res</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">ans</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">nextPT</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pt</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">pt</span><span class="o">];</span>
        <span class="k">while</span><span class="o">(</span><span class="n">pt</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">pt</span><span class="o">]</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="n">pt</span><span class="o">++;</span>
        <span class="k">return</span> <span class="n">pt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="350-intersection-of-two-arrays-ii-easy">350. Intersection of Two Arrays II (Easy)</h3><p><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/">350. Intersection of Two Arrays II (Easy)</a> Given two integer arrays nums1 and nums2,</p><ul><li>return an array of their intersection.<li>Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.</ul><p>Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2]</p><h4 id="2-pointer-arrayssort-左右指针arrayscopyofrangenums10k">2 pointer <code class="language-plaintext highlighter-rouge">Arrays.sort(); 左右指针，Arrays.copyOfRange(nums1,0,k);</code></h4><ol><li><code class="language-plaintext highlighter-rouge">Arrays.sort(); 左右指针，Arrays.copyOfRange(nums1,0,k);</code></ol><p>O(nlogn) time without extra space</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 98.65% of Java online submissions for Intersection of Two Arrays II.</span>
<span class="c1">// Memory Usage: 39.3 MB, less than 64.43% of Java online submissions for Intersection of Two Arrays II.</span>
<span class="c1">// O(nlogn) time without extra space</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersect</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums1</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">nums1</span><span class="o">[</span><span class="n">k</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">j</span><span class="o">++;</span>
            <span class="k">else</span> <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">k</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 94.32% of Java online submissions for Intersection of Two Arrays II.</span>
<span class="c1">// Memory Usage: 42.5 MB, less than 11.68% of Java online submissions for Intersection of Two Arrays II.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersect</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums1</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums2</span><span class="o">);</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">h</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums1</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">h</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="n">i</span><span class="o">++;</span> <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">j</span><span class="o">++;</span>
            <span class="k">else</span> <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">h</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">index</span><span class="o">++)</span> <span class="n">res</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>O(n) time and extra space 100% faster</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersect</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">map</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">1001</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">res</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">1001</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span><span class="n">nums1</span><span class="o">)</span>
        <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">]++;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span><span class="n">nums2</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">]&gt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">count</span><span class="o">++]=</span><span class="n">i</span><span class="o">;</span>
            <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">]--;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">res</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">count</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li>map</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 5 ms, faster than 38.46% of Java online submissions for Intersection of Two Arrays II.</span>
<span class="c1">// Memory Usage: 44.9 MB, less than 5.36% of Java online submissions for Intersection of Two Arrays II.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">intersect</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">nums1</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">k</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="1089-duplicate-zeros-easy">1089. Duplicate Zeros (Easy)</h3><p><a href="https://leetcode.com/problems/duplicate-zeros/">1089. Duplicate Zeros</a> Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right.</p><p>Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.</p><p>Example 1:</p><p>Input: arr = [1,0,2,3,0,4,5,0] Output: [1,0,0,2,3,0,0,4] Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]</p><p>Example 2: Input: arr = [1,2,3] Output: [1,2,3] Explanation: After calling your function, the input array is modified to: [1,2,3]</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 66.89% of Java online submissions for Duplicate Zeros.</span>
<span class="c1">// Memory Usage: 43.6 MB, less than 12.50% of Java online submissions for Duplicate Zeros.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">duplicateZeros</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]==</span><span class="mi">0</span><span class="o">){</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">index</span><span class="o">++)</span> <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 19 ms, faster than 26.93% of Java online submissions for Duplicate Zeros.</span>
<span class="c1">// Memory Usage: 45.4 MB, less than 10.80% of Java online submissions for Duplicate Zeros.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">duplicateZeros</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]==</span><span class="mi">0</span><span class="o">){</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">--){</span>
                    <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="1385-find-the-distance-value-between-two-arrays-easy">1385. Find the Distance Value Between Two Arrays (Easy)</h3><p><a href="https://leetcode.com/problems/find-the-distance-value-between-two-arrays/">1385. Find the Distance Value Between Two Arrays</a> Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.</p><div class="table-wrapper"><table><tbody><tr><td>The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where<td>arr1[i]-arr2[j]<td>&lt;= d.</table></div><p>Example 1: Input: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2 Output: 2</p><p>Explanation: For arr1[0]=4 we have: |4-10|=6 &gt; d=2 |4-9|=5 &gt; d=2 |4-1|=3 &gt; d=2 |4-8|=4 &gt; d=2</p><p>For arr1[1]=5 we have: |5-10|=5 &gt; d=2 |5-9|=4 &gt; d=2 |5-1|=4 &gt; d=2 |5-8|=3 &gt; d=2</p><p>For arr1[2]=8 we have: |8-10|=2 &lt;= d=2 |8-9|=1 &lt;= d=2 |8-1|=7 &gt; d=2 |8-8|=0 &lt;= d=2</p><h4 id="brute-force">brute force</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 3 ms, faster than 75.47% of Java online submissions for Find the Distance Value Between Two Arrays.</span>
<span class="c1">// Memory Usage: 38.5 MB, less than 70.69% of Java online submissions for Find the Distance Value Between Two Arrays.</span>
<span class="c1">// O(n^2)</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findTheDistanceValue</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">arr1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">nums1:</span><span class="n">arr1</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">nums2:</span><span class="n">arr2</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">nums1</span><span class="o">-</span><span class="n">nums2</span><span class="o">)&lt;=</span><span class="n">d</span><span class="o">){</span>
                    <span class="n">count</span><span class="o">--;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><h4 id="binary-search">Binary Search</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 3 ms, faster than 76.94% of Java online submissions for Find the Distance Value Between Two Arrays.</span>
<span class="c1">// Memory Usage: 38.6 MB, less than 56.39% of Java online submissions for Find the Distance Value Between Two Arrays.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findTheDistanceValue</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr1</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr2</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">closeDis</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">nums1:</span><span class="n">arr1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">closeDis</span> <span class="o">=</span> <span class="n">bs</span><span class="o">(</span><span class="n">arr2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">arr2</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">,</span> <span class="n">nums1</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">closeDis</span><span class="o">&gt;</span><span class="n">d</span><span class="o">)</span> <span class="n">count</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">bs</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span> <span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="n">lo</span><span class="o">&gt;</span><span class="n">hi</span><span class="o">)</span> <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">dis</span><span class="o">=</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">arr2</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">-</span> <span class="n">value</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">arr2</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">value</span><span class="o">)</span> <span class="n">dis</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dis</span><span class="o">,</span> <span class="n">bs</span><span class="o">(</span><span class="n">arr2</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span> <span class="o">,</span> <span class="n">value</span><span class="o">));</span>
        <span class="k">else</span> <span class="n">dis</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dis</span><span class="o">,</span> <span class="n">bs</span><span class="o">(</span><span class="n">arr2</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hi</span> <span class="o">,</span> <span class="n">value</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">dis</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4>???</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">// O(nlogm)</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findTheDistanceValue</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">TreeSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">number:</span> <span class="n">arr2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">tree</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arr1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">leftValue</span> <span class="o">=</span> <span class="n">arr1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">d</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">rightValue</span> <span class="o">=</span> <span class="n">arr1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">d</span><span class="o">;</span>
            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">subSet</span><span class="o">(</span><span class="n">leftValue</span><span class="o">,</span> <span class="n">rightValue</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="sort--sliding-window-best"><code class="language-plaintext highlighter-rouge">sort + sliding window</code> BEST</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// O(NLogN)</span>

<span class="c1">// Runtime: 2 ms, faster than 96.65% of Java online submissions for Find the Distance Value Between Two Arrays.</span>
<span class="c1">// Memory Usage: 38.6 MB, less than 68.97% of Java online submissions for Find the Distance Value Between Two Arrays.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findTheDistanceValue</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr1</span><span class="o">);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr2</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">arr1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">arr1</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="n">d</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">arr1</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">d</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">arr2</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">arr2</span><span class="o">[</span><span class="n">j</span><span class="o">]&lt;</span><span class="n">min</span><span class="o">)</span> <span class="n">j</span><span class="o">++;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">outband</span><span class="o">(</span><span class="n">arr2</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">min</span><span class="o">,</span> <span class="n">max</span><span class="o">))</span> <span class="n">count</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">outband</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">,</span> <span class="kt">int</span> <span class="n">min</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">j</span><span class="o">==</span><span class="n">arr2</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="o">!(</span><span class="n">min</span><span class="o">&lt;=</span><span class="n">arr2</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">arr2</span><span class="o">[</span><span class="n">j</span><span class="o">]&lt;=</span><span class="n">max</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="696-count-binary-substrings-easy-找00110011成对项">696. Count Binary Substrings (Easy) 找00110011成对项</h3><p>Give a binary string s, return the number of non-empty substrings that have the same number of 0’s and 1’s, and all the 0’s and all the 1’s in these substrings are grouped consecutively.</p><p>Substrings that occur multiple times are counted the number of times they occur.</p><p>Example 1: Input: s = “00110011” Output: 6</p><p>Explanation: There are 6 substrings that have equal number of consecutive 1’s and 0’s: “0011”, “01”, “1100”, “10”, “0011”, and “01”. Notice that some of these substrings repeat and are counted the number of times they occur. Also, “00110011” is not a valid substring because all the 0’s (and 1’s) are not grouped together.</p><p>the number that we should add to ans is equal to min(zeros, ones), or pre count</p><h4 id="-brute-force-resmathminpre-cur">+++++ Brute Force <code class="language-plaintext highlighter-rouge">res+=Math.min(pre, cur);</code></h4><p>Check for every substring either they are valid substring or not. if valid increase the count but time complexity :<code class="language-plaintext highlighter-rouge">O(n^3)</code></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 21 ms, faster than 7.53% of Java online submissions for Count Binary Substrings.</span>
<span class="c1">// Memory Usage: 46 MB, less than 15.02% of Java online submissions for Count Binary Substrings.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countBinarySubstrings</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">pre</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">cur</span><span class="o">=</span><span class="mi">1</span><span class="o">,</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">)!=</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)){</span>
                <span class="n">res</span><span class="o">+=</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">cur</span><span class="o">);</span>
                <span class="n">pre</span><span class="o">=</span><span class="n">cur</span><span class="o">;</span>
                <span class="n">cur</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="n">cur</span><span class="o">++;</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">+=</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">cur</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="1346-check-if-n-and-its-double-exist-easy">1346. Check If N and Its Double Exist (Easy)</h3><p><a href="https://leetcode.com/problems/check-if-n-and-its-double-exist/">1346. Check If N and Its Double Exist</a> Given an array arr of integers, check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M).</p><p>Example 1: Input: arr = [10,2,5,3] Output: true Explanation: N = 10 is the double of M = 5,that is, 10 = 2 * 5</p><h4 id="-bruteforce-放入hashsetrotate看出现">+++++ Bruteforce <code class="language-plaintext highlighter-rouge">放入HashSet，rotate看出现</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 73.80% of Java online submissions for Check If N and Its Double Exist.</span>
<span class="c1">// Memory Usage: 43.5 MB, less than 13.50% of Java online submissions for Check If N and Its Double Exist.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">checkIfExist</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">arr</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">num</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">num</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">num</span><span class="o">/</span><span class="mi">2</span><span class="o">)))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">else</span> <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-bs">+++++ BS</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">checkIfExist</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">res</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">check_binarySearch</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]*</span><span class="mi">2</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">res</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">res</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">check_binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">start</span><span class="o">&lt;=</span><span class="n">end</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">else</span> <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="33-search-in-rotated-sorted-array-">33. Search in Rotated Sorted Array !!!!!!</h3><hr /><h3 id="81-search-in-rotated-sorted-array-ii-">81. Search in Rotated Sorted Array II !!!!!!</h3><hr /><h3 id="154-find-minimum-in-rotated-sorted-array-ii--followup-">154. Find Minimum in Rotated Sorted Array II + FollowUp !!!!!!</h3><hr /><h2 id="-two-pointer---链表">🔒 two pointer - 链表</h2><hr /><h3 id="203-remove-linked-list-elements-easy">203. Remove Linked List Elements (Easy)</h3><p><a href="https://leetcode.com/problems/remove-linked-list-elements/">203. Remove Linked List Elements</a></p><p>Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.</p><p>Input: head = [1,2,6,3,4,5,6], val = 6 Output: [1,2,3,4,5]</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
  * int val;
  * ListNode next;
  * ListNode() {}
  * ListNode(int val) { this.val = val; }
  * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */</span>

<span class="c1">// Runtime: 1 ms, faster than 74.37% of Java online submissions for Remove Linked List Elements.</span>
<span class="c1">// Memory Usage: 39.4 MB, less than 98.31% of Java online submissions for Remove Linked List Elements.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeElements</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">val</span><span class="o">)</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">else</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Linked List Elements.</span>
<span class="c1">// Memory Usage: 40.6 MB, less than 18.70% of Java online submissions for Remove Linked List Elements.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeElements</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">val</span><span class="o">==</span><span class="n">val</span><span class="o">)</span> <span class="k">return</span> <span class="n">removeElements</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">,</span>  <span class="n">val</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">val</span><span class="o">)</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">else</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><h4 id="-recursive-solution">+++++ recursive solution</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeElements</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">removeElements</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">val</span> <span class="o">?</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">:</span> <span class="n">head</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="237-delete-node-in-a-linked-list-easy">237. Delete Node in a Linked List (Easy)</h3><p><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/">237. Delete Node in a Linked List</a> Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly.</p><p>It is guaranteed that the node to be deleted is not a tail node in the list.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
  * int val;
  * ListNode next;
  * ListNode(int x) { val = x; }
 * }
 */</span>
<span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Delete Node in a Linked List.</span>
<span class="c1">// Memory Usage: 40.9 MB, less than 12.23% of Java online submissions for Delete Node in a Linked List.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteNode</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="876-middle-of-the-linked-list-寻找单链表的中点">876. Middle of the Linked List 寻找单链表的中点</h3><p>point: 无法直接得到单链表的长度 n，</p><ul><li>常规方法也是先遍历链表计算 n，再遍历一次得到第 n / 2 个节点，也就是中间节点。</ul><p>solution:</p><ul><li>两个指针 slow 和 fast 分别指向链表头结点 head。<li>每当慢指针 slow 前进一步，快指针 fast 就前进两步，<li>这样当 fast 走到链表末尾时，slow 就指向了链表中点。</ul><blockquote><p>如果链表长度为偶数，中点有两个的时候，返回的节点是靠后的那个节点。 这段代码稍加修改就可以直接用到判断链表成环的算法题上。</p></blockquote><p>让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。</p><p><a href="https://leetcode.com/problems/middle-of-the-linked-list/">876. Middle of the Linked List</a></p><ul><li>Given the head of a singly linked list, return the middle node of the linked list.<li>If there are two middle nodes, return the second middle node.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Middle of the Linked List.</span>
<span class="c1">// Memory Usage: 36.4 MB, less than 67.08% of Java online submissions for Middle of the Linked List.</span>

<span class="nc">ListNode</span> <span class="nf">middleNode</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">fast</span><span class="o">,</span> <span class="n">slow</span><span class="o">;</span>
    <span class="n">fast</span> <span class="o">=</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// slow 就在中间位置</span>
    <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="2095-delete-the-middle-node-of-a-linked-list-medium">2095. Delete the Middle Node of a Linked List (Medium)</h3><p><a href="https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/">2095. Delete the Middle Node of a Linked List</a> You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.</p><p>The middle node of a linked list of size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.</p><p>For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.</p><p>Input: head = [1,3,4,7,1,2,6] Output: [1,3,4,1,2,6]</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
  * int val;
  * ListNode next;
  * ListNode() {}
  * ListNode(int val) { this.val = val; }
  * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */</span>
<span class="c1">// O(n), O(1)</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">deleteMiddle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span><span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 0 or 1 nodes</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">),</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">,</span> <span class="n">slow</span><span class="o">=</span><span class="n">dummy</span><span class="o">;</span>
        <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">=</span><span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span><span class="kc">null</span><span class="o">&amp;&amp;</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">=</span><span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="寻找单链表的倒数n节点">寻找单链表的倒数n节点</h3><p>point: 算法题一般只给你一个 ListNode 头结点代表一条单链表，</p><ul><li>不能直接得出这条链表的长度 n，<li>而需要先遍历一遍链表算出 n 的值，<li>然后再遍历链表计算第 n - k 个节点。</ul><p><strong>只遍历一次链表</strong></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// 返回链表的倒数第 k 个节点</span>
<span class="nc">ListNode</span> <span class="nf">findFromEnd</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="c1">// fast 先走 k 步</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="c1">// 让慢指针和快指针同步向前</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// slow 现在指向第 n - k 个节点</span>
    <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>时间复杂度</p><ul><li>无论遍历一次链表和遍历两次链表的时间复杂度都是 O(N)，但上述这个算法更有技巧性。</ul><hr /><h3 id="19-remove-nth-node-from-end-of-list-remove倒数n节点-删除倒数n找倒数n1">19. Remove Nth Node From End of List remove倒数n节点 <code class="language-plaintext highlighter-rouge">删除倒数n,找倒数n+1</code></h3><p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a></p><p>Given the head of a linked list, remove the nth node from the end of the list and return its head.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Nth Node From End of List.</span>
<span class="c1">// Memory Usage: 37 MB, less than 75.59% of Java online submissions for Remove Nth Node From End of List.</span>
<span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeNthFromEnd</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="c1">// 虚拟头结点</span>
    <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="c1">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span>
    <span class="nc">ListNode</span> <span class="n">x</span> <span class="o">=</span> <span class="n">findFromEnd</span><span class="o">(</span><span class="n">dummy</span><span class="o">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="c1">// 删掉倒数第 n 个节点</span>
    <span class="n">x</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 返回链表的倒数第 k 个节点</span>
<span class="kd">private</span> <span class="nc">ListNode</span> <span class="nf">findFromEnd</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
    <span class="nc">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="c1">// fast 先走 k 步</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="c1">// 让慢指针和快指针同步向前</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// slow 现在指向第 n - k 个节点</span>
    <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 24.37% of Java online submissions for Remove Nth Node From End of List.</span>
<span class="c1">// Memory Usage: 38.6 MB, less than 26.69% of Java online submissions for Remove Nth Node From End of List.</span>
<span class="c1">// O(1) space</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeNthFromEnd</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">head</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">fast</span><span class="o">=</span><span class="n">dummy</span><span class="o">,</span> <span class="n">slow</span><span class="o">=</span><span class="n">dummy</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(</span><span class="n">fast</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">slow</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="delete-n-nodes-after-m-nodes-of-a-linked-list-">Delete N Nodes After M Nodes of a Linked List ??????????</h3><p>Given a linked list and two integers M and N. Traverse the linked list such that you retain M nodes then delete next N nodes, continue the same till end of the linked list.</p><p>Input: M = 2, N = 2 Linked List: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8 Output: Linked List: 1-&gt;2-&gt;5-&gt;6</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// Function to skip M nodes and then</span>
<span class="c1">// delete N nodes of the linked list.</span>
<span class="kd">static</span> <span class="kt">void</span> <span class="nf">skipMdeleteN</span><span class="o">(</span> <span class="nc">Node</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="no">M</span><span class="o">,</span> <span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">,</span> <span class="n">t</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
    <span class="c1">// The main loop that traverses through the whole list</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">curr</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">// Skip M nodes</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="no">M</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">count</span><span class="o">++)</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

        <span class="c1">// If we reached end of list, then return</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">curr</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

        <span class="c1">// Start from next node and delete N nodes</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">count</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Link the previous list with remaining nodes</span>
        <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>

        <span class="c1">// Set current pointer for next iteration</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="160-判断两个单链表是否相交并找出交点">160. 判断两个单链表是否相交并找出交点</h3><p>160 题「相交链表」</p><ul><li>给你输入两个链表的头结点 headA 和 headB，这两个链表可能存在相交。<li>如果相交，你的算法应该返回相交的那个节点；如果没相交，则返回 null。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 98.52% of Java online submissions for Intersection of Two Linked Lists.</span>
<span class="c1">// Memory Usage: 42.2 MB, less than 57.90% of Java online submissions for Intersection of Two Linked Lists.</span>

<span class="nc">ListNode</span> <span class="nf">getIntersectionNode</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">headA</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">headB</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span>
    <span class="nc">ListNode</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">headA</span><span class="o">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">headB</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">headB</span><span class="o">;</span>
        <span class="k">else</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="c1">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">headA</span><span class="o">;</span>
        <span class="k">else</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">p1</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h2 id="-two-pointer---palindrome-回文">🔒 two pointer - palindrome 回文</h2><p>寻找回文串的核心思想是从中心向两端扩展：</p><ul><li>回文串是对称的，所以正着读和倒着读应该是一样的，这一特点是解决回文串问题的关键。<li>因为回文串长度可能为奇数也可能是偶数，长度为奇数时只存在一个中心点，而长度为偶数时存在两个中心点，所以上面这个函数需要传入l和r。<li>「双指针技巧」，从两端向中间逼近即可：</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">string</span> <span class="nf">palindrome</span><span class="o">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 防止索引越界</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">==</span> <span class="n">s</span><span class="o">[</span><span class="n">r</span><span class="o">])</span> <span class="o">{</span>
        <span class="c1">// 向两边展开</span>
        <span class="n">l</span><span class="o">--;</span> <span class="n">r</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="c1">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">substr</span><span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="2108-find-first-palindromic-string-in-the-array-easy">2108. Find First Palindromic String in the Array (Easy)</h3><p><a href="https://leetcode.com/problems/find-first-palindromic-string-in-the-array/">2108. Find First Palindromic String in the Array</a></p><p>Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string “”.</p><p>A string is palindromic if it reads the same forward and backward.</p><h4 id="-2-pointer-check-each-word">+++++ 2 pointer Check each word</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 83.75% of Java online submissions for Find First Palindromic String in the Array.</span>
<span class="c1">// Memory Usage: 39.1 MB, less than 86.28% of Java online submissions for Find First Palindromic String in the Array.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">firstPalindrome</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
        <span class="nl">outers:</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">w</span> <span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">;</span> <span class="n">i</span><span class="o">++,</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">w</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="k">continue</span> <span class="n">outers</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">w</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Runtime: 2 ms, faster than 83.75% of Java online submissions for Find First Palindromic String in the Array.</span>
<span class="c1">// Memory Usage: 39 MB, less than 86.28% of Java online submissions for Find First Palindromic String in the Array.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">firstPalindrome</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">wd</span> <span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">checkPali</span><span class="o">(</span><span class="n">wd</span><span class="o">))</span> <span class="k">return</span> <span class="n">wd</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">checkPali</span><span class="o">(</span><span class="nc">String</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">;</span> <span class="n">i</span><span class="o">++,</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">w</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-stringbuilderreverseequals">+++++ StringBuilder.reverse.equals</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">firstPalindrome</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">reverse</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span> <span class="nf">toString</span><span class="o">()))</span> <span class="k">return</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="832-flipping-an-image-easy-only-same-values-flip-both">832. Flipping an Image (Easy) <code class="language-plaintext highlighter-rouge">only same values flip both.</code></h3><p><a href="https://leetcode.com/problems/flipping-an-image/">832. Flipping an Image</a> Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.</p><p>To flip an image horizontally means that each row of the image is reversed.</p><p>For example, flipping [1,1,0] horizontally results in [0,1,1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.</p><p>For example, inverting [0,1,1] results in [1,0,0].</p><p>Example 1: Input: image = [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Optimal one-pass in-place solution
 * If the values are not same, swap and flip will not change anything.
 * If the values are same, we will flip both.
 *
 * Time Complexity: O(N^2)
 * Space Complexity: O(1)
 * N = Matrix Size
 */</span>
<span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Flipping an Image.</span>
<span class="c1">// Memory Usage: 39.1 MB, less than 70.53% of Java online submissions for Flipping an Image.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">flipAndInvertImage</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">image</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">image</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">image</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">image</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">image</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">image</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">end</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">start</span><span class="o">&lt;=</span><span class="n">end</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">row</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">==</span> <span class="n">row</span><span class="o">[</span><span class="n">end</span><span class="o">]){</span>
                    <span class="n">row</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">^=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// XOR operate</span>
                    <span class="n">row</span><span class="o">[</span><span class="n">end</span><span class="o">]</span> <span class="o">=</span> <span class="n">row</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>
                <span class="o">}</span>
                <span class="n">start</span><span class="o">++;</span>
                <span class="n">end</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">image</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="1332-remove-palindromic-subsequences-easy">1332. Remove Palindromic Subsequences (Easy)</h3><p><a href="https://leetcode.com/problems/remove-palindromic-subsequences/">1332. Remove Palindromic Subsequences</a> You are given a string s consisting only of letters ‘a’ and ‘b’. In a single step you can remove one palindromic subsequence from s.</p><p>Return the minimum number of steps to make the given string empty.</p><p>A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous.</p><p>A string is called palindrome if is one that reads the same backward as well as forward.</p><h4 id="-只有012-三种答案aaabbb最多两下消完-best">+++++ <code class="language-plaintext highlighter-rouge">只有0，1，2 三种答案，aaabbb最多两下消完</code> Best</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Palindromic Subsequences.</span>
<span class="c1">// Memory Usage: 37.1 MB, less than 38.55% of Java online submissions for Remove Palindromic Subsequences.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removePalindromeSub</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">j</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">j</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)!=</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="k">return</span> <span class="mi">2</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>
            <span class="n">j</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removePalindromeSub</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>
	<span class="c1">//palindrome check</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">++)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">--))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="reverse-logic-also">reverse logic also</h4><p>check if the string is same as the reverse string then return 1 otherwise return 2</p><hr /><h3 id="125-valid-palindrome-判断回文链表string">125. Valid Palindrome 判断回文链表String</h3><p><a href="https://leetcode.com/problems/valid-palindrome/">125. Valid Palindrome</a></p><ul><li>A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.<li>Given a string s, return true if it is a palindrome, or false otherwise.</ul><p>Example:</p><p>Input: “aba” Output: True</p><p>Input: “race a car” Output: false</p><h4 id="-brute-force-1">+++++ Brute-Force</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1263 ms, faster than 5.01% of Java online submissions for Valid Palindrome.</span>
<span class="c1">// Memory Usage: 47.2 MB, less than 26.08% of Java online submissions for Valid Palindrome.</span>

<span class="c1">// 2 pointer + s.replaceAll("[^a-zA-Z0-9]", "").toLowerCase()</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"[^A-Za-z0-9]"</span><span class="o">,</span> <span class="s">""</span><span class="o">).</span><span class="na">toLowerCase</span><span class="o">();</span>   <span class="c1">// most time consumming.</span>
        <span class="kt">int</span> <span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">l</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">r</span><span class="o">&lt;</span><span class="n">l</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">r</span><span class="o">)==</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">l</span><span class="o">)){</span>
                <span class="n">r</span><span class="o">++;</span> <span class="n">l</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// Time: O(N)</span>
<span class="c1">// Space: O(N)</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">();</span> <span class="c1">// for later comparisons</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">// remove non-letter character</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
        <span class="c1">// letter or digit</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetterOrDigit</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span> <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// not letter</span>
        <span class="k">else</span> <span class="n">s</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="c1">// update length</span>
    <span class="c1">// right-leaning</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-2-pointer--x--y--characterisletterordigitscharatx--best">+++++ <code class="language-plaintext highlighter-rouge">2 pointer + (x &lt;= y &amp;&amp; !Character.isLetterOrDigit(s.charAt(x)) )</code> best</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 4 ms, faster than 87.40% of Java online submissions for Valid Palindrome.</span>
<span class="c1">// Memory Usage: 44 MB, less than 45.98% of Java online submissions for Valid Palindrome.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetterOrDigit</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span> <span class="n">x</span><span class="o">++;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetterOrDigit</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">y</span><span class="o">)))</span> <span class="n">y</span><span class="o">--;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="nc">Character</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">!=</span> <span class="nc">Character</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">y</span><span class="o">)))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">x</span><span class="o">++;</span> <span class="n">y</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="c1">// Runtime: 4 ms, faster than 76.59% of Java online submissions for Valid Palindrome.</span>
<span class="c1">// Memory Usage: 43.4 MB, less than 30.46% of Java online submissions for Valid Palindrome.</span>
<span class="c1">// Time: O(N)</span>
<span class="c1">// Space: O(1)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isValid</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">lo</span><span class="o">)))</span> <span class="n">lo</span><span class="o">++;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isValid</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">hi</span><span class="o">)))</span> <span class="n">hi</span><span class="o">--;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span> <span class="o">&amp;&amp;</span> <span class="n">isCharDiff</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">lo</span><span class="o">),</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">hi</span><span class="o">)))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">lo</span><span class="o">++;</span> <span class="n">hi</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nc">Character</span><span class="o">.</span><span class="na">isLetterOrDigit</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isCharDiff</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch1</span><span class="o">,</span> <span class="kt">char</span> <span class="n">ch2</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nc">Character</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">(</span><span class="n">ch1</span><span class="o">)</span> <span class="o">!=</span> <span class="nc">Character</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">(</span><span class="n">ch2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">){</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">charMap</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">256</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">charMap</span><span class="o">[</span><span class="sc">'0'</span><span class="o">+</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="o">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
        <span class="c1">// numeric - don't use 0 as it's reserved for illegal chars</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">charMap</span><span class="o">[</span><span class="sc">'a'</span><span class="o">+</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">charMap</span><span class="o">[</span><span class="sc">'A'</span><span class="o">+</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="o">(</span><span class="mi">11</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
        <span class="c1">//alphabetic, ignore cases, continue from 11</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">;)</span> <span class="o">{</span>
        <span class="c1">// illegal chars</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">charMap</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">start</span><span class="o">)]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">start</span><span class="o">++;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">charMap</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">end</span><span class="o">)]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">end</span><span class="o">--;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">charMap</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">start</span><span class="o">++)]</span> <span class="o">!=</span> <span class="n">charMap</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">end</span><span class="o">--)])</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>


<span class="c1">// Runtime: 864 ms, faster than 19.35% of Java online submissions for Valid Palindrome.</span>
<span class="c1">// Memory Usage: 47.5 MB, less than 19.37% of Java online submissions for Valid Palindrome.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">actual</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"[^A-Za-z0-9]"</span><span class="o">,</span> <span class="s">""</span><span class="o">).</span><span class="na">toLowerCase</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">rev</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">(</span><span class="n">actual</span><span class="o">).</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">actual</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">rev</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><hr /><h3 id="680-valid-palindrome-ii-easy-可去掉一个字母查看palindrome">680. Valid Palindrome II (Easy) 可去掉一个字母查看Palindrome</h3><p><a href="https://leetcode.com/problems/valid-palindrome-ii/">680. Valid Palindrome II</a> Given a string s, return true if the s can be palindrome after deleting at most one character from it.</p><p>Example 1: Input: s = “aba” Output: true</p><p>Example 2: Input: s = “abca” Output: true Explanation: You could delete the character ‘c’.</p><p>Example 3: Input: s = “abc” Output: false</p><h4 id="brute-force-validpalindromevalidsubpalindrome">Brute-Force <code class="language-plaintext highlighter-rouge">validPalindrome+validSubPalindrome</code></h4><p>Delete each character and then test palindromicity.</p><p>When detecting the first mismatch we should consider two cases:</p><p>Case 1: Delete the character on the left, and move on. Case 2: Delete the character on the right, and move on.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// Time: O(N^2)</span>
<span class="c1">// Space: O(1)</span>
<span class="c1">// Runtime: 6 ms, faster than 85.93% of Java online submissions for Valid Palindrome II.</span>
<span class="c1">// Memory Usage: 42.9 MB, less than 66.51% of Java online submissions for Valid Palindrome II.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">validPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="o">{</span>
          <span class="k">return</span> <span class="nf">validSubPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">||</span> <span class="n">validSubPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">validSubPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">i</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">right</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="recursive-version">recursive version</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 23 ms, faster than 7.26% of Java online submissions for Valid Palindrome II.</span>
<span class="c1">// Memory Usage: 58.8 MB, less than 5.14% of Java online submissions for Valid Palindrome II.</span>
<span class="c1">// Time: O(N)</span>
<span class="c1">// Space: O(N)</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">validPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">validSubPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">validSubPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">chance</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// base case</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&gt;=</span> <span class="n">hi</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">lo</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">hi</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">chance</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nf">validSubPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span> <span class="o">||</span> <span class="n">validSubPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">validSubPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">chance</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Runtime: 8 ms, faster than 65.71% of Java online submissions for Valid Palindrome II.</span>
<span class="c1">// Memory Usage: 54.5 MB, less than 14.01% of Java online submissions for Valid Palindrome II.</span>
<span class="c1">// Time: O(n), where n is the length of the string</span>
<span class="c1">// Space: O(1), in-place</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">validPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">chance</span><span class="o">){</span>
        <span class="k">while</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">y</span><span class="o">)){</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">chance</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">return</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span> <span class="o">||</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">x</span><span class="o">++;</span>
            <span class="n">y</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="判断回文单链表---把原始链表反转存入一条新的链表然后比较">判断回文单链表 - 把原始链表反转存入一条新的链表，然后比较</h4><p>point: 单链表无法倒着遍历，无法使用双指针技巧。</p><p>把原始链表反转存入一条新的链表，然后比较这两条链表是否相同。</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>
</pre></table></code></div></div><hr /><h4 id="判断回文单链表---二叉树后序遍历">判断回文单链表 - 二叉树后序遍历</h4><p>借助二叉树后序遍历的思路，不需要显式反转原始链表也可以倒序遍历链表</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 前序遍历代码</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="c1">// 中序遍历代码</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="c1">// 后序遍历代码</span>
<span class="o">}</span>
</pre></table></code></div></div><p>链表其实也有前序遍历和后序遍历：</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 前序遍历代码</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
    <span class="c1">// 后序遍历代码</span>
<span class="o">}</span>
</pre></table></code></div></div><p>正序打印链表中的 val 值，可以在前序遍历位置写代码； 反之，如果想倒序遍历链表，就可以在后序遍历位置操作：</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cm">/* 倒序打印单链表中的元素值 */</span>
<span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
    <span class="n">traverse</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
    <span class="c1">// 后序遍历代码</span>
    <span class="n">print</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="判断回文单链表---用栈结构倒序处理单链表">判断回文单链表 - 用栈结构倒序处理单链表</h4><p>模仿双指针实现回文判断的功能：</p><ul><li>把链表节点放入一个栈，然后再拿出来，<li>这时候元素顺序就是反的，只不过我们利用的是递归函数的堆栈而已。</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// 左侧指针</span>
<span class="nc">ListNode</span> <span class="n">left</span><span class="o">;</span>

<span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">return</span> <span class="nf">traverse</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
<span class="o">}</span>

<span class="kt">boolean</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">res</span> <span class="o">=</span> <span class="n">traverse</span><span class="o">(</span><span class="n">right</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
    <span class="c1">// 后序遍历代码</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">right</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">left</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="判断回文单链表---不完全反转链表仅仅反转部分链表空间复杂度o1">判断回文单链表 - 不完全反转链表，仅仅反转部分链表，空间复杂度O(1)。</h4><p>更好的思路是这样的：</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="c1">// 1234 5 6789</span>
<span class="c1">// 1 23 45 67 89</span>
<span class="c1">// 1 2  3  4</span>
<span class="c1">// 先通过 双指针技巧 中的快慢指针来找到链表的中点：</span>
<span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">){</span>
    <span class="nc">ListNode</span> <span class="n">slow</span><span class="o">=</span><span class="n">head</span><span class="o">,</span> <span class="n">fast</span><span class="o">=</span><span class="n">head</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">fast</span><span class="o">!=</span><span class="kc">null</span><span class="o">&amp;&amp;</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
        <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">fast</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
        <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">ListNode</span> <span class="n">right</span><span class="o">=</span><span class="n">head</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">left</span><span class="o">=</span><span class="n">reverse</span><span class="o">(</span><span class="n">slow</span><span class="o">);</span>
    <span class="k">while</span><span class="o">(</span><span class="n">right</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="na">val</span><span class="o">!=</span><span class="n">right</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="o">.</span><span class="na">next</span><span class="o">,</span> <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>

<span class="nc">ListNode</span> <span class="nf">reverse</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>时间复杂度 O(N)，<li>空间复杂度 O(1)，已经是最优的了。</ul><hr /><h2 id="-two-pointer---string">🔒 two pointer - String</h2><hr /><h3 id="917-reverse-only-letters-easy-只反转字母">917. Reverse Only Letters (Easy) 只反转字母</h3><p><a href="https://leetcode.com/problems/reverse-only-letters/">917. Reverse Only Letters</a></p><p>Given a string s, reverse the string according to the following rules:</p><p>All the characters that are not English letters remain in the same position. All the English letters (lowercase or uppercase) should be reversed. Return s after reversing it.</p><p>Example 1: Input: s = “ab-cd” Output: “dc-ba”</p><p>2 pointer</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="c1">// string</span>
<span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Only Letters.</span>
<span class="c1">// Memory Usage: 37.5 MB, less than 54.56% of Java online submissions for Reverse Only Letters.</span>

<span class="c1">// while 左全部一遍 右全部一遍</span>
<span class="c1">// while(i &lt; S.length() &amp;&amp; !Character.isLetter(chars[i])) i++;</span>
<span class="c1">// while(j&gt;=0 &amp;&amp; !Character.isLetter(chars[j])) j--;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseOnlyLetters</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">rp</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">lp</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">rp</span><span class="o">&gt;=</span><span class="n">lp</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span><span class="n">res</span><span class="o">[</span><span class="n">lp</span><span class="o">]))</span> <span class="n">lp</span><span class="o">++;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span><span class="n">res</span><span class="o">[</span><span class="n">rp</span><span class="o">]))</span> <span class="n">rp</span><span class="o">--;</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="kt">char</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">res</span><span class="o">[</span><span class="n">rp</span><span class="o">];</span>
                <span class="n">res</span><span class="o">[</span><span class="n">rp</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">[</span><span class="n">lp</span><span class="o">];</span>
                <span class="n">res</span><span class="o">[</span><span class="n">lp</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
                <span class="n">lp</span><span class="o">++;</span>
                <span class="n">rp</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// stringbuilder</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseOnlyLetters</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">ch1</span><span class="o">=</span><span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="kt">char</span> <span class="n">ch2</span><span class="o">=</span><span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span><span class="n">ch1</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span><span class="n">ch2</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">--;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">setCharAt</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">ch2</span><span class="o">);</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">setCharAt</span><span class="o">(</span><span class="n">j</span><span class="o">,</span><span class="n">ch1</span><span class="o">);</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="n">j</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>all loop once</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 63.68% of Java online submissions for Reverse Only Letters.</span>
<span class="c1">// Memory Usage: 38.9 MB, less than 22.38% of Java online submissions for Reverse Only Letters.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseOnlyLetters</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuilder</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
            <span class="k">if</span><span class="o">(</span> <span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="n">res</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span> <span class="o">!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isLetter</span><span class="o">(</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="n">res</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="2000-reverse-prefix-of-word-easy-到si之前反转">2000. Reverse Prefix of Word (Easy) 到s[i]之前反转</h3><p><a href="https://leetcode.com/problems/reverse-prefix-of-word/">2000. Reverse Prefix of Word</a> Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.</p><p>For example, if word = “abcdefd” and ch = “d”, then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be “dcbaefd”. Return the resulting string.</p><p>Example 1:</p><p>Input: word = “abcdefd”, ch = “d” Output: “dcbaefd” Explanation: The first occurrence of “d” is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is “dcbaefd”.</p><h4 id="-char">+++++ <code class="language-plaintext highlighter-rouge">char[]</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Prefix of Word.</span>
<span class="c1">// Memory Usage: 37.2 MB, less than 88.30% of Java online submissions for Reverse Prefix of Word.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reversePrefix</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">,</span> <span class="kt">char</span> <span class="n">ch</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">loc</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">word</span><span class="o">;</span> <span class="c1">// not in</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">chr</span><span class="o">=</span><span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">j</span><span class="o">=</span><span class="n">loc</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">j</span><span class="o">;</span> <span class="n">i</span><span class="o">++,</span> <span class="n">j</span><span class="o">--){</span>
            <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">chr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">chr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">chr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">chr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">chr</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-stringbuilder">+++++ <code class="language-plaintext highlighter-rouge">StringBuilder</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Prefix of Word.</span>
<span class="c1">// Memory Usage: 37.2 MB, less than 77.86% of Java online submissions for Reverse Prefix of Word.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reversePrefix</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">,</span> <span class="kt">char</span> <span class="n">ch</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">loc</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">word</span><span class="o">;</span> <span class="c1">// not in</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">loc</span><span class="o">+</span><span class="mi">1</span><span class="o">));</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">reverse</span><span class="o">();</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">loc</span><span class="o">+</span><span class="mi">1</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="557-reverse-words-in-a-string-iii-easy-一句话单词各自反转">557. Reverse Words in a String III (Easy) 一句话单词各自反转</h3><p><a href="https://leetcode.com/problems/reverse-words-in-a-string-iii/">557. Reverse Words in a String III</a></p><p>Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p><p>Example 1:</p><p>Input: s = “Let’s take LeetCode contest” Output: “s’teL ekat edoCteeL tsetnoc” Example 2:</p><p>Input: s = “God Ding” Output: “doG gniD”</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 3 ms, faster than 87.03% of Java online submissions for Reverse Words in a String III.</span>
<span class="c1">// Memory Usage: 39.5 MB, less than 74.19% of Java online submissions for Reverse Words in a String III.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseWords</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">str</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">wd</span> <span class="o">:</span> <span class="n">str</span><span class="o">)</span> <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">" "</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">reverse</span><span class="o">(</span><span class="n">wd</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverse</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseWords</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span><span class="o">&lt;</span><span class="n">right</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">swapCharUsingCharArray</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
                <span class="n">left</span> <span class="o">++;</span>
                <span class="n">right</span> <span class="o">--;</span>
            <span class="o">}</span>
            <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">" "</span><span class="o">,</span> <span class="n">array</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">swapCharUsingCharArray</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
        <span class="n">chars</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="n">chars</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">chars</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="541-reverse-string-ii-easy-2134-6578-k个一组反转">541. Reverse String II (Easy) <code class="language-plaintext highlighter-rouge">2134 6578</code> k个一组反转</h3><p><a href="https://leetcode.com/problems/reverse-string-ii/">541. Reverse String II</a></p><p>Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.</p><p>If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.</p><p>Example 1: Input: s = “abcdefg”, k = 2 Output: “bacdfeg”</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse String II.</span>
<span class="c1">// Memory Usage: 38.9 MB, less than 76.53% of Java online submissions for Reverse String II.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseStr</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">end</span> <span class="o">=</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">reverse</span><span class="o">(</span><span class="n">chars</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">chars</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseStr</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">end</span> <span class="o">=</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">reverse</span><span class="o">(</span><span class="n">chars</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">chars</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
            <span class="n">chars</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
            <span class="n">i</span><span class="o">++;</span>
            <span class="n">k</span><span class="o">--;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="942-di-string-match-easy-increase-l-decrease-r--">942. DI String Match (Easy) <code class="language-plaintext highlighter-rouge">Increase l++; Decrease r--</code></h3><p><a href="https://leetcode.com/problems/di-string-match/">942. DI String Match</a> A permutation perm of n + 1 integers of all the integers in the range [0, n] can be represented as a string s of length n where:</p><p>s[i] == ‘I’ if perm[i] &lt; perm[i + 1], and s[i] == ‘D’ if perm[i] &gt; perm[i + 1]. Given a string s, reconstruct the permutation perm and return it. If there are multiple valid permutations perm, return any of them.</p><p>Example 1: Input: s = “IDID” Output: [0,4,1,3,2]</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 95.15% of Java online submissions for DI String Match.</span>
<span class="c1">// Memory Usage: 40.2 MB, less than 69.63% of Java online submissions for DI String Match.</span>
<span class="c1">// O(n) time, O(n) space, n is length of S</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">diStringMatch</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()+</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)==</span><span class="sc">'I'</span><span class="o">)</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">++;</span>
            <span class="k">else</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="n">res</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()]=(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">)==</span><span class="sc">'I'</span><span class="o">)?</span><span class="nl">l:</span><span class="n">r</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">diStringMatch</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()+</span><span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++</span> <span class="o">)</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)==</span><span class="sc">'I'</span> <span class="o">?</span> <span class="n">l</span><span class="o">++:</span><span class="n">r</span><span class="o">--;</span>
        <span class="n">res</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()]=(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">)==</span><span class="sc">'I'</span><span class="o">)?</span><span class="nl">l:</span><span class="n">r</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="905-sort-array-by-parity-easy">905. Sort Array By Parity (Easy)</h3><p>Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.</p><p>Return any array that satisfies this condition.</p><p>Example 1: Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</p><h4 id="-new-inti--numslr">+++++ <code class="language-plaintext highlighter-rouge">new int[i] = nums[l/r]</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortArrayByParity</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">arr</span><span class="o">[]=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">=</span><span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]=</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">]=</span><span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">k</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// O(n)</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortArrayByParity</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="n">r</span><span class="o">=</span><span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">a:</span> <span class="no">A</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">res</span><span class="o">[</span><span class="n">l</span><span class="o">++]=</span><span class="n">a</span><span class="o">;</span>
            <span class="k">else</span> <span class="n">res</span><span class="o">[</span><span class="n">r</span><span class="o">--]=</span><span class="n">a</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-in-place-solution-best">+++++ In Place Solution Best</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 98.86% of Java online submissions for Sort Array By Parity.</span>
<span class="c1">// Memory Usage: 39.7 MB, less than 81.43% of Java online submissions for Sort Array By Parity.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortArrayByParity</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">fast</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">slow</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">slow</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">slow</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">slow</span><span class="o">]%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">slow</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">slow</span><span class="o">]=</span><span class="n">nums</span><span class="o">[</span><span class="n">fast</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">fast</span><span class="o">]=</span><span class="n">temp</span><span class="o">;</span>
                <span class="n">fast</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="1768-merge-strings-alternately-easy-穿插st加字母">1768. Merge Strings Alternately (Easy) 穿插s,t加字母</h3><p>You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.</p><p>Return the merged string.</p><p>Example 1:</p><p>Input: word1 = “abc”, word2 = “pqr” Output: “apbqcr” Explanation: The merged string will be merged as so: word1: a b c word2: p q r merged: a p b q c r</p><h4 id="-for-int-i0-imathmaxs1s2-i-">+++++ <code class="language-plaintext highlighter-rouge">for (int i=0; i&lt;Math.max(s1,s2); i++); </code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Merge Strings Alternately.</span>
<span class="c1">// Memory Usage: 36.8 MB, less than 99.89% of Java online submissions for Merge Strings Alternately.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">mergeAlternately</span><span class="o">(</span><span class="nc">String</span> <span class="n">word1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">stop</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span><span class="n">s2</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">stop</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">s1</span><span class="o">)</span> <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">word1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">s2</span><span class="o">)</span> <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">word2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-substring">+++++ substring</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Merge Strings Alternately.</span>
<span class="c1">// Memory Usage: 37.3 MB, less than 81.03% of Java online submissions for Merge Strings Alternately.</span>
<span class="c1">// Java O(n)class</span>
<span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">mergeAlternately</span><span class="o">(</span><span class="nc">String</span> <span class="n">word1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">stop</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span><span class="n">s2</span><span class="o">);</span>

        <span class="nc">String</span> <span class="n">bigger</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">==</span> <span class="n">s1</span><span class="o">?</span> <span class="nl">word2:</span><span class="n">word1</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">stop</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">word1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">word2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">()+</span><span class="n">bigger</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">stop</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="977-squares-of-a-sorted-array-easy-每个数字操作后排序">977. Squares of a Sorted Array (Easy) 每个数字操作后排序</h3><p><a href="https://leetcode.com/problems/squares-of-a-sorted-array/discuss/410331/Java-O(N)-two-pointer.-w-comments.-beats-100">977. Squares of a Sorted Array</a> Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.</p><p>Example 1:</p><p>Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100].</p><h4 id="-brute-force-approach">+++++ Brute Force Approach</h4><p>Squares of sorted array seems like the easiest problem</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// O(nlogn)</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortedSquares</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span>
        <span class="o">{</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-mathabsnumsl--mathabsnumsr-best">+++++ <code class="language-plaintext highlighter-rouge">Math.abs(nums[l]) &gt; Math.abs(nums[r])</code> Best</h4><ol><li>can the values in the array be negative.<li>can square of values can exceed Integer.MAX_VALUE.<li>values are in long or Integer.<li>is given array sorted.(even if the example are sorted) this helped me in google interview interviewer told me that this is nice question. (I was not asked this question but a question where sample cases where sorted )</ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 100.00% of Java online submissions for Squares of a Sorted Array.</span>
<span class="c1">// Memory Usage: 40.6 MB, less than 90.34% of Java online submissions for Squares of a Sorted Array.</span>
<span class="c1">// O(N)</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortedSquares</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">])</span> <span class="o">&gt;</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]))</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]*</span><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">++];</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]*</span><span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">--];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="821-shortest-distance-to-a-character-easy-到特定字母距离">821. Shortest Distance to a Character (Easy) 到特定字母距离</h3><p><a href="https://leetcode.com/problems/shortest-distance-to-a-character/">821. Shortest Distance to a Character</a> Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.</p><p>The distance between two indices i and j is abs(i - j), where abs is the absolute value function.</p><p>Example 1:</p><p>Input: s = “loveleetcode”, c = “e” Output: [3,2,1,0,1,0,0,1,2,2,1,0] Explanation: The character ‘e’ appears at indices 3, 5, 6, and 11 (0-indexed). The closest occurrence of ‘e’ for index 0 is at index 3, so the distance is abs(0 - 3) = 3. The closest occurrence of ‘e’ for index 1 is at index 3, so the distance is abs(1 - 3) = 2. For index 4, there is a tie between the ‘e’ at index 3 and the ‘e’ at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1. The closest occurrence of ‘e’ for index 8 is at index 6, so the distance is abs(8 - 6) = 2.</p><h4 id="-mathminfromleft-fromright">+++++ ``Math.min(fromLeft, fromRight)`</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">// Time Complexity: Forward loop &amp; Backward Loop : O(N) + O(N) ~ O(N)</span>
<span class="c1">// Space Complexity: Without considering answer array : O(1)</span>
<span class="c1">// Runtime: 1 ms, faster than 96.28% of Java online submissions for Shortest Distance to a Character.</span>
<span class="c1">// Memory Usage: 38.9 MB, less than 92.57% of Java online submissions for Shortest Distance to a Character.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">shortestToChar</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">char</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span><span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="c1">// forward</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)==</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">prev</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">prev</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// backward</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)==</span><span class="n">c</span><span class="o">)</span> <span class="n">prev</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
            <span class="k">else</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="o">++</span><span class="n">prev</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-when-scharc-ji-1-ji1">+++++ <code class="language-plaintext highlighter-rouge">when s.char==c, j=i-1; j=i+1</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 96.28% of Java online submissions for Shortest Distance to a Character.</span>
<span class="c1">// Memory Usage: 38.8 MB, less than 97.27% of Java online submissions for Shortest Distance to a Character.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">shortestToChar</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">char</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">j</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span><span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="c1">// forward</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)==</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span>
                <span class="c1">// backforward</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">while</span><span class="o">(</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">res</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="o">){</span>
                    <span class="n">res</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="o">;</span>
                    <span class="n">j</span><span class="o">--;</span>
                <span class="o">}</span>
                <span class="c1">// forward</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">while</span><span class="o">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">){</span>
                    <span class="n">res</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">;</span>
                    <span class="n">j</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-combine-2-best">+++++ <code class="language-plaintext highlighter-rouge">combine 2</code> BEST</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 96.28% of Java online submissions for Shortest Distance to a Character.</span>
<span class="c1">// Memory Usage: 38.9 MB, less than 84.76% of Java online submissions for Shortest Distance to a Character.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">shortestToChar</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">char</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">n</span><span class="o">,</span> <span class="n">j</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span><span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="c1">// forward</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)==</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span>
                <span class="n">prev</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
                <span class="c1">// backforward</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">while</span><span class="o">(</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">res</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="o">){</span>
                    <span class="n">res</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="o">;</span>
                    <span class="n">j</span><span class="o">--;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]=++</span><span class="n">prev</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="922-sort-array-by-parity-ii-easy-按奇偶排序">922. Sort Array By Parity II (Easy) 按奇偶排序</h3><p><a href="https://leetcode.com/problems/sort-array-by-parity-ii/">922. Sort Array By Parity II</a> Given an array of integers nums, half of the integers in nums are odd, and the other half are even.</p><p>Sort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even.</p><p>Return any answer array that satisfies this condition.</p><p>Example 1:</p><p>Input: nums = [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.</p><h4 id="-new-res-numsi20-resoddindex-oddindex-resevenindex-evenindex">+++++ <code class="language-plaintext highlighter-rouge">new res, nums[i]%2==0?; res[oddindex] oddindex++, res[evenindex] evenindex++</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 98.92% of Java online submissions for Sort Array By Parity II.</span>
<span class="c1">// Memory Usage: 41.6 MB, less than 47.17% of Java online submissions for Sort Array By Parity II.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortArrayByParityII</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">oddindex</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">evenindex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">evenindex</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">evenindex</span><span class="o">+=</span><span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">res</span><span class="o">[</span><span class="n">oddindex</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">oddindex</span><span class="o">+=</span><span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]=</span><span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]=</span><span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-forint-i0in-i2-should-be-even-if-odd-check-prev-numodd-best">+++++ <code class="language-plaintext highlighter-rouge">for(int i=0;i&lt;n; i+=2) should be even, if (odd), check prev num[odd]</code> BEST</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 98.92% of Java online submissions for Sort Array By Parity II.</span>
<span class="c1">// Memory Usage: 39.9 MB, less than 89.85% of Java online submissions for Sort Array By Parity II.</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortArrayByParityII</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">oddindex</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]%</span><span class="mi">2</span><span class="o">!=</span><span class="mi">0</span><span class="o">){</span>
                <span class="k">while</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">oddindex</span><span class="o">]%</span><span class="mi">2</span><span class="o">!=</span><span class="mi">0</span><span class="o">)</span> <span class="n">oddindex</span><span class="o">+=</span><span class="mi">2</span><span class="o">;</span>
                <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">oddindex</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]=</span><span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]=</span><span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="392-is-subsequence-easy-abc-inside-ahbgdc-">392. Is Subsequence (Easy) <code class="language-plaintext highlighter-rouge">abc inside ahbgdc ?</code></h3><p><a href="https://leetcode.com/problems/is-subsequence/">392. Is Subsequence</a> Given two strings s and t, return true if s is a subsequence of t, or false otherwise.</p><p>A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not).</p><p>Example 1:</p><p>Input: s = “abc”, t = “ahbgdc” Output: true Example 2:</p><p>Input: s = “axc”, t = “ahbgdc” Output: false</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 86.20% of Java online submissions for Is Subsequence.</span>
<span class="c1">// Memory Usage: 42.3 MB, less than 6.45% of Java online submissions for Is Subsequence.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSubsequence</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)==</span><span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="n">i</span><span class="o">++;</span>
            <span class="n">j</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">i</span><span class="o">==</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="28-implement-strstr-easy-ll在hello里">28. Implement strStr() (Easy) ll在hello里</h3><p><a href="https://leetcode.com/problems/implement-strstr/">28. Implement strStr()</a> Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p><p>Clarification:</p><p>What should we return when needle is an empty string? This is a great question to ask during an interview.</p><p>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().</p><p>Example 1: Input: haystack = “hello”, needle = “ll” Output: 2</p><p>Example 2: Input: haystack = “aaaaa”, needle = “bba” Output: -1</p><p>Example 3: Input: haystack = “”, needle = “” Output: 0</p><h4 id="-brute-force-string-matching">+++++ Brute Force string matching</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1385 ms, faster than 21.45% of Java online submissions for Implement strStr().</span>
<span class="c1">// Memory Usage: 41.7 MB, less than 40.16% of Java online submissions for Implement strStr().</span>
<span class="cm">/**
 * Brute Force string matching.
 * Time Complexity: O(M * N)
 * Space Complexity: O(1)
 * M = Length of haystack string.
 * N = length of needle string.
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">strStr</span><span class="o">(</span><span class="nc">String</span> <span class="n">haystack</span><span class="o">,</span> <span class="nc">String</span> <span class="n">needle</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">haystack</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">needle</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Input strings are null"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">hLen</span> <span class="o">=</span> <span class="n">haystack</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">nLen</span> <span class="o">=</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nLen</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">hLen</span> <span class="o">&lt;</span> <span class="n">nLen</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hLen</span> <span class="o">-</span> <span class="n">nLen</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">nLen</span> <span class="o">&amp;&amp;</span> <span class="n">haystack</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">)</span> <span class="o">==</span> <span class="n">needle</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="n">j</span><span class="o">++;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">nLen</span><span class="o">)</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-use-haystacksubstringiil2equalsneedle">+++++ <code class="language-plaintext highlighter-rouge">use haystack.substring(i,i+l2).equals(needle)</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1009 ms, faster than 28.40% of Java online submissions for Implement strStr().</span>
<span class="c1">// Memory Usage: 117.9 MB, less than 19.54% of Java online submissions for Implement strStr().</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">strStr</span><span class="o">(</span><span class="nc">String</span> <span class="n">haystack</span><span class="o">,</span> <span class="nc">String</span> <span class="n">needle</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">haystack</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">l2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">l1</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">-</span> <span class="n">l2</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">haystack</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">i</span><span class="o">+</span><span class="n">l2</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="n">needle</span><span class="o">))</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">strStr1</span><span class="o">(</span><span class="nc">String</span> <span class="n">haystack</span><span class="o">,</span> <span class="nc">String</span> <span class="n">needle</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">haystack</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">needle</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">strStr</span><span class="o">(</span><span class="nc">String</span> <span class="n">haystack</span><span class="o">,</span> <span class="nc">String</span> <span class="n">needle</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">haystack</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">needle</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">haystack</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l1</span><span class="o">-</span><span class="n">l2</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">l2</span> <span class="o">&amp;&amp;</span> <span class="n">haystack</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="n">count</span><span class="o">)</span> <span class="o">==</span> <span class="n">needle</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">count</span><span class="o">))</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">l2</span><span class="o">)</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">strStr</span><span class="o">(</span><span class="nc">String</span> <span class="n">haystack</span><span class="o">,</span> <span class="nc">String</span> <span class="n">needle</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">haystack</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">needle</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Input strings are null"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">needle</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">haystack</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">needle</span><span class="o">))</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">hLen</span> <span class="o">=</span> <span class="n">haystack</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">nLen</span> <span class="o">=</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nLen</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">hLen</span> <span class="o">&lt;</span> <span class="n">nLen</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hLen</span> <span class="o">-</span> <span class="n">nLen</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">evalString</span> <span class="o">=</span> <span class="n">haystack</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nLen</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">evalString</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">needle</span><span class="o">))</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><h4 id="-kmp-solution-backlog">+++++ KMP solution <code class="language-plaintext highlighter-rouge">Backlog</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">strStr</span><span class="o">(</span><span class="nc">String</span> <span class="n">haystack</span><span class="o">,</span> <span class="nc">String</span> <span class="n">needle</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">haystack</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">needle</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">nLen</span> <span class="o">=</span> <span class="n">needle</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">hLen</span> <span class="o">=</span> <span class="n">haystack</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nLen</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">hLen</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">table</span> <span class="o">=</span> <span class="n">kmpLookupTable</span><span class="o">(</span><span class="n">needle</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">hLen</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nLen</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">haystack</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">needle</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">j</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
                <span class="k">else</span> <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">nLen</span><span class="o">)</span> <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="o">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">kmpLookupTable</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">index</span><span class="o">++;</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">index</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">i</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">table</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="925-long-pressed-name-easy-alex对比aaleex">925. Long Pressed Name (Easy) “alex”对比”aaleex”</h3><p><a href="https://leetcode.com/problems/long-pressed-name/">925. Long Pressed Name</a> Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.</p><p>You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.</p><p>Example 1:</p><p>Input: name = “alex”, typed = “aaleex” Output: true Explanation: ‘a’ and ‘e’ in ‘alex’ were long pressed.</p><p>Example 2: Input: name = “saeed”, typed = “ssaaedd” Output: false Explanation: ‘e’ must have been pressed twice, but it was not in the typed output.</p><h4 id="-1">+++++</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 73.39% of Java online submissions for Long Pressed Name.</span>
<span class="c1">// Memory Usage: 42.4 MB, less than 6.21% of Java online submissions for Long Pressed Name.</span>
<span class="c1">// time complexity: O(m + n)</span>
<span class="c1">// space complexity: O(1)</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isLongPressedName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">typed</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">typed</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">){</span>
            <span class="kt">char</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">typed</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// we are handling different chars, no!</span>

			<span class="c1">// count of consecutive c1/c2</span>
            <span class="kt">int</span> <span class="n">count1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">name</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">c1</span><span class="o">){</span>
                <span class="n">count1</span><span class="o">++;</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>

			<span class="c1">// count of consecutive c1/c2</span>
            <span class="kt">int</span> <span class="n">count2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">typed</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">==</span> <span class="n">c2</span><span class="o">){</span>
                <span class="n">count2</span><span class="o">++;</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">count2</span> <span class="o">&lt;</span> <span class="n">count1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
		<span class="c1">// they both reach the end</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-2-pointer-iterate">+++++ 2 pointer iterate</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 73.39% of Java online submissions for Long Pressed Name.</span>
<span class="c1">// Memory Usage: 42.4 MB, less than 6.21% of Java online submissions for Long Pressed Name.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isLongPressedName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">typed</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">nlen</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">tlen</span> <span class="o">=</span> <span class="n">typed</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tlen</span> <span class="o">&lt;</span> <span class="n">nlen</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">nlen</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">&lt;</span><span class="n">tlen</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">==</span> <span class="n">typed</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">x</span><span class="o">++;</span>
                <span class="n">y</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">typed</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">y</span><span class="o">)))</span> <span class="n">y</span><span class="o">++;</span>
                <span class="k">else</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="n">nlen</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">==</span><span class="n">tlen</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">x</span><span class="o">!=</span><span class="n">nlen</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">==</span><span class="n">tlen</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="k">while</span><span class="o">(</span><span class="n">y</span><span class="o">&lt;</span><span class="n">tlen</span><span class="o">){</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">typed</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">typed</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="n">y</span><span class="o">++;</span>
                    <span class="k">else</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="c1">// Time Complexity : O(n)</span>
<span class="c1">// T/S: O(n)/O(1)</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isLongPressedName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">typed</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">typed</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">typed</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">typed</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">name</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">==</span> <span class="n">typed</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>   <span class="n">c</span><span class="o">++;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">typed</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">typed</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span>  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">==</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="844-backspace-string-compare-easy-abcd">844. Backspace String Compare (Easy) <code class="language-plaintext highlighter-rouge">"ab##"=="c#d#"?</code></h3><p><a href="https://leetcode.com/problems/backspace-string-compare/">844. Backspace String Compare</a> Given two strings s and t, return true if they are equal when both are typed into empty text editors. ‘#’ means a backspace character.</p><p>Note that after backspacing an empty text, the text will continue empty.</p><p>Example 1: Input: s = “ab#c”, t = “ad#c” Output: true Explanation: Both s and t become “ac”.</p><p>Example 2: Input: s = “ab##”, t = “c#d#” Output: true Explanation: Both s and t become “”.</p><p>Example 3: Input: s = “a#c”, t = “b” Output: false Explanation: s becomes “c” while t becomes “b”.</p><h4 id="-2-pointer-stringbuilderadd-stringbuilderdeletecharati">+++++ <code class="language-plaintext highlighter-rouge">2 pointer, StringBuilder.add StringBuilder.deleteCharAt(i)</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 2 ms, faster than 52.02% of Java online submissions for Backspace String Compare.</span>
<span class="c1">// Memory Usage: 42.3 MB, less than 5.04% of Java online submissions for Backspace String Compare.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">backspaceCompare</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">strEditor</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="n">strEditor</span><span class="o">(</span><span class="n">t</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">strEditor</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuilder</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">()){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">!=</span> <span class="sc">'#'</span><span class="o">)</span> <span class="n">res</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span><span class="mi">0</span><span class="o">)</span> <span class="n">res</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-2-pointer-stackpush--stackpop">+++++ <code class="language-plaintext highlighter-rouge">2 pointer, Stack.push / Stack.pop</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 4 ms, faster than 27.04% of Java online submissions for Backspace String Compare.</span>
<span class="c1">// Memory Usage: 42.3 MB, less than 5.04% of Java online submissions for Backspace String Compare.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">backspaceCompare</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">strEditor</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="n">strEditor</span><span class="o">(</span><span class="n">t</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">strEditor</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Stack</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="nl">c:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">()){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">c</span> <span class="o">!=</span> <span class="sc">'#'</span><span class="o">)</span> <span class="n">res</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span><span class="mi">0</span><span class="o">)</span> <span class="n">res</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-2-pointer-stackpush--stackpop-1">+++++ <code class="language-plaintext highlighter-rouge">2 pointer, Stack.push / Stack.pop</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Backspace String Compare.</span>
<span class="c1">// Memory Usage: 40.3 MB, less than 17.60% of Java online submissions for Backspace String Compare.</span>
<span class="c1">// T: O(n)</span>
<span class="c1">// S: O(1)</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">backspaceCompare</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="nc">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">pointers</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">pointert</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">pointers</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pointert</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">pointers</span> <span class="o">=</span> <span class="n">movePointer</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">pointers</span><span class="o">);</span>
            <span class="n">pointert</span> <span class="o">=</span> <span class="n">movePointer</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">pointert</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pointers</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pointert</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pointers</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">pointert</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pointers</span><span class="o">)</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pointert</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">pointers</span><span class="o">--;</span>
            <span class="n">pointert</span><span class="o">--;</span>
        <span class="o">}</span>
	    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">movePointer</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pointer</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">move</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">pointer</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">pointer</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">){</span>
                <span class="n">move</span><span class="o">++;</span>
                <span class="n">pointer</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">move</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">move</span><span class="o">--;</span>
                <span class="n">pointer</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">pointer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="345-reverse-vowels-of-a-string-easy">345. Reverse Vowels of a String (Easy)</h3><p><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/">345. Reverse Vowels of a String</a></p><p>Given a string s, reverse only all the vowels in the string and return it.</p><p>The vowels are ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’, and they can appear in both cases.</p><p>Example 1:</p><p>Input: s = “hello” Output: “holle” Example 2:</p><p>Input: s = “leetcode” Output: “leotcede”</p><p><code class="language-plaintext highlighter-rouge">Set&lt;Character&gt; vowels = new HashSet&lt;&gt;();</code> faster</p><p><code class="language-plaintext highlighter-rouge">List&lt;Character&gt; vowels = Arrays.asList('a','e','i','o','u','A','E','I','O','U');</code></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 9 ms, faster than 45.23% of Java online submissions for Reverse Vowels of a String.</span>
<span class="c1">// Memory Usage: 42.4 MB, less than 37.36% of Java online submissions for Reverse Vowels of a String.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseVowels</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">vowels</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="sc">'a'</span><span class="o">,</span><span class="sc">'e'</span><span class="o">,</span><span class="sc">'i'</span><span class="o">,</span><span class="sc">'o'</span><span class="o">,</span><span class="sc">'u'</span><span class="o">,</span><span class="sc">'A'</span><span class="o">,</span><span class="sc">'E'</span><span class="o">,</span><span class="sc">'I'</span><span class="o">,</span><span class="sc">'O'</span><span class="o">,</span><span class="sc">'U'</span><span class="o">);</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">str</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">vowels</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="n">x</span><span class="o">]))</span> <span class="n">x</span><span class="o">++;</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">vowels</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="n">y</span><span class="o">]))</span> <span class="n">y</span><span class="o">--;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">vowels</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="n">x</span><span class="o">])</span> <span class="o">&amp;&amp;</span> <span class="n">vowels</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="n">y</span><span class="o">])){</span>
                <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">str</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
                <span class="n">str</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">str</span><span class="o">[</span><span class="n">y</span><span class="o">];</span>
                <span class="n">str</span><span class="o">[</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
                <span class="n">x</span><span class="o">++;</span>
                <span class="n">y</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Runtime: 10 ms, faster than 39.23% of Java online submissions for Reverse Vowels of a String.</span>
<span class="c1">// Memory Usage: 45.1 MB, less than 24.97% of Java online submissions for Reverse Vowels of a String.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseVowels</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">vowels</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="sc">'a'</span><span class="o">,</span><span class="sc">'e'</span><span class="o">,</span><span class="sc">'i'</span><span class="o">,</span><span class="sc">'o'</span><span class="o">,</span><span class="sc">'u'</span><span class="o">,</span><span class="sc">'A'</span><span class="o">,</span><span class="sc">'E'</span><span class="o">,</span><span class="sc">'I'</span><span class="o">,</span><span class="sc">'O'</span><span class="o">,</span><span class="sc">'U'</span><span class="o">);</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">str</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="o">){</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vowels</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="n">x</span><span class="o">]))</span> <span class="n">x</span><span class="o">++;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vowels</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="n">y</span><span class="o">]))</span> <span class="n">y</span><span class="o">--;</span>
            <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">str</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
            <span class="n">str</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">str</span><span class="o">[</span><span class="n">y</span><span class="o">];</span>
            <span class="n">str</span><span class="o">[</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
            <span class="n">x</span><span class="o">++;</span>
            <span class="n">y</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Runtime: 3 ms, faster than 91.36% of Java online submissions for Reverse Vowels of a String.</span>
<span class="c1">// Memory Usage: 42.4 MB, less than 37.36% of Java online submissions for Reverse Vowels of a String.</span>
<span class="c1">// O(n)</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reverseVowels</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>

        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">vowels</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">vowels</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'a'</span><span class="o">);</span>
        <span class="n">vowels</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'e'</span><span class="o">);</span>
        <span class="n">vowels</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'i'</span><span class="o">);</span>
        <span class="n">vowels</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'o'</span><span class="o">);</span>
        <span class="n">vowels</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'u'</span><span class="o">);</span>
        <span class="n">vowels</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'A'</span><span class="o">);</span>
        <span class="n">vowels</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'E'</span><span class="o">);</span>
        <span class="n">vowels</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'I'</span><span class="o">);</span>
        <span class="n">vowels</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'O'</span><span class="o">);</span>
        <span class="n">vowels</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'U'</span><span class="o">);</span>

        <span class="kt">char</span><span class="o">[]</span> <span class="n">str</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="o">){</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vowels</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="n">x</span><span class="o">]))</span> <span class="n">x</span><span class="o">++;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vowels</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="n">y</span><span class="o">]))</span> <span class="n">y</span><span class="o">--;</span>
            <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">str</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
            <span class="n">str</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">str</span><span class="o">[</span><span class="n">y</span><span class="o">];</span>
            <span class="n">str</span><span class="o">[</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
            <span class="n">x</span><span class="o">++;</span>
            <span class="n">y</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h1 id="-bit-operation">🔒🔒 bit operation</h1><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>

<span class="c1">// 1         00000001    (same as 1&lt;&lt;0)</span>
<span class="c1">// n&lt;&lt;1      00000010</span>
<span class="c1">// n&lt;&lt;2      00000100</span>
<span class="c1">// n&lt;&lt;3      00001000</span>
<span class="c1">// n&lt;&lt;4      00010000</span>
<span class="c1">// n&lt;&lt;5      00100000</span>
<span class="c1">// n&lt;&lt;6      01000000</span>
<span class="c1">// n&lt;&lt;7      10000000</span>


<span class="c1">// ~1        11111110  (same as ~(1&lt;&lt;0))</span>
<span class="c1">// ~(n&lt;&lt;1)   11111101</span>
<span class="c1">// ~(n&lt;&lt;2)   11111011</span>
<span class="c1">// ~(n&lt;&lt;3)   11110111</span>
<span class="c1">// ~(n&lt;&lt;4)   11101111</span>
<span class="c1">// ~(n&lt;&lt;5)   11011111</span>
<span class="c1">// ~(n&lt;&lt;6)   10111111</span>
<span class="c1">// ~(n&lt;&lt;7)   01111111</span>

</pre></table></code></div></div><hr /><h2 id="-bit-operation---basic">🔒 bit operation - basic</h2><hr /><h3 id="bit-hack-1-check-if-the-integer-is-even-or-odd-x10-even-odd"><strong>Bit Hack #1. Check if the integer is even or odd.</strong> <code class="language-plaintext highlighter-rouge">x&amp;1==0? even: odd</code></h3><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">((</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="n">is</span> <span class="n">even</span>
<span class="k">else</span> <span class="n">x</span> <span class="n">is</span> <span class="n">odd</span>
</pre></table></code></div></div><ul><li>the binary representation of ‘x’, <code class="language-plaintext highlighter-rouge">bit _b0_ contributes to either 1 or 0</code>.<li>By AND-ing ‘x’ with 1 it <code class="language-plaintext highlighter-rouge">eliminate all the other bits than _b0_</code>.<ul><li>an integer is odd, only if the <code class="language-plaintext highlighter-rouge">least significant bit _b0_ is 1</code>.<li>If the result 0, <code class="language-plaintext highlighter-rouge">bit _b0_ was 0</code>, ‘x’ was even,</ul></ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// take integer 43, which is odd.</span>
<span class="c1">// the least significant bit _b0_ is 1 (in bold)</span>
    <span class="mo">00101011</span>
<span class="o">&amp;</span>   <span class="mo">00000001</span>   <span class="o">(</span><span class="nl">note:</span> <span class="mi">1</span> <span class="n">is</span> <span class="n">the</span> <span class="n">same</span> <span class="n">as</span> <span class="mo">00000001</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000001</span>


<span class="c1">// look at -43. Just as a reminder, a quick way to find negative of a given number in two's complement representation is to invert all bits and add one.</span>
<span class="c1">// the last bit is 1, and the integer is odd.</span>


<span class="c1">// integer 98. In binary 98 is 1100010.</span>
<span class="c1">// the bit _b0_ of original integer 98 was 0. Thus the given integer is even.</span>
    <span class="mo">01100010</span>
<span class="o">&amp;</span>   <span class="mo">00000001</span>
    <span class="o">--------</span>
    <span class="mo">00000000</span>


<span class="c1">// negative -98. It's 10011110.</span>
<span class="c1">// bit _b0_ is 0, the result is 0, meaning -98 is even</span>
</pre></table></code></div></div><hr /><h3 id="bit-hack-2-test-if-the-n-th-bit-is-set-x--1n-"><strong>Bit Hack #2. Test if the n-th bit is set.</strong> <code class="language-plaintext highlighter-rouge">x &amp; (1&lt;&lt;n) ?</code></h3><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="o">))</span> <span class="n">n</span><span class="o">-</span><span class="n">th</span> <span class="n">bit</span> <span class="n">is</span> <span class="n">set</span>
<span class="k">else</span> <span class="n">n</span><span class="o">-</span><span class="n">th</span> <span class="n">bit</span> <span class="n">is</span> <span class="n">not</span> <span class="n">set</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">(x &amp; 1)</code> tests if the <strong>first bit</strong> is set.<li>to tests if n-th bit is set.<ul><li>shifting that first 1-bit n positions to the left and then doing the same AND operation<li>it eliminates all bits but n-th.</ul></ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="c1">// when shift 1 several positions to the left:</span>
<span class="mi">1</span>         <span class="mo">00000001</span>    <span class="o">(</span><span class="n">same</span> <span class="n">as</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="o">)</span>
<span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span>      <span class="mo">00000010</span>
<span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span>      <span class="mo">00000100</span>
<span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span>      <span class="mo">00001000</span>
<span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span>      <span class="mo">00010000</span>
<span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span>      <span class="mo">00100000</span>
<span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span>      <span class="mo">01000000</span>
<span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">7</span>      <span class="mi">10000000</span>

<span class="c1">// Now if we AND 'x' with 1 shifted n positions to the left we effectively eliminate all the bits but n-th bit in 'x'.</span>
<span class="c1">// If the result after AND-ing is 0, then that bit must have been 0, otherwise that bit was set.</span>

<span class="c1">// examples.</span>

<span class="c1">// Does 122 have 3rd bit set?</span>
<span class="mi">122</span> <span class="o">&amp;</span> <span class="o">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="o">)</span>
<span class="c1">// 122 is 01111010 in binary</span>
<span class="c1">// (1&lt;&lt;3) is 00001000.</span>
    <span class="mo">01111010</span>
<span class="o">&amp;</span>   <span class="mo">00001000</span>
    <span class="o">--------</span>
    <span class="mo">00001000</span>
<span class="c1">// the result is not 0, so yes, 122 has the 3rd bit set.</span>


<span class="c1">// What about -33? Does it have the 5th bit set?</span>
    <span class="mi">11011111</span>      <span class="o">(-</span><span class="mi">33</span> <span class="n">in</span> <span class="n">binary</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mo">00100000</span>     <span class="o">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000000</span>
<span class="c1">// Result is 0, so the 5th bit is not set.</span>
</pre></table></code></div></div><hr /><h3 id="bit-hack-3-set-the-n-th-bit-x--1n"><strong>Bit Hack #3. Set the n-th bit.</strong> <code class="language-plaintext highlighter-rouge">x | (1&lt;&lt;n)</code></h3><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|</span> <span class="o">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="o">)</span>


<span class="c1">// The result of OR-ing a variable with a value that has n-th bit set is turning that n-th bit on.</span>

<span class="c1">// OR-ing any value with 0 leaves the value the same;</span>
<span class="c1">// but OR-ing it with 1 changes it to 1 (if it wasn't already).</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// value 120, to turn on the 2nd bit.</span>
    <span class="mo">01111000</span>    <span class="o">(</span><span class="mi">120</span> <span class="n">in</span> <span class="n">binary</span><span class="o">)</span>
<span class="o">|</span>   <span class="mo">00000100</span>    <span class="o">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">01111100</span>

<span class="c1">// -120 and 6th bit?</span>
    <span class="mi">10001000</span>   <span class="o">(-</span><span class="mi">120</span> <span class="n">in</span> <span class="n">binary</span><span class="o">)</span>
<span class="o">|</span>   <span class="mo">01000000</span>   <span class="o">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mi">11001000</span>
</pre></table></code></div></div><hr /><h3 id="bit-hack-4-unset-the-n-th-bit-x--1n"><strong>Bit Hack #4. Unset the n-th bit.</strong> <code class="language-plaintext highlighter-rouge">x &amp; ~(1&lt;&lt;n)</code></h3><p>make nth bit 0.</p><ul><li>helper: all 1 and nth bit 0</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="o">~(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="o">)</span>

<span class="c1">// ~(1&lt;&lt;n)</span>
<span class="c1">// turns on (0) all the bits except n-th.</span>
<span class="c1">// ~1        11111110  (same as ~(1&lt;&lt;0))</span>
<span class="c1">// ~(1&lt;&lt;1)   11111101</span>
<span class="c1">// ~(1&lt;&lt;2)   11111011</span>
<span class="c1">// ~(1&lt;&lt;3)   11110111</span>
<span class="c1">// ~(1&lt;&lt;4)   11101111</span>
<span class="c1">// ~(1&lt;&lt;5)   11011111</span>
<span class="c1">// ~(1&lt;&lt;6)   10111111</span>
<span class="c1">// ~(1&lt;&lt;7)   01111111</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// The effect of AND-ing variable 'x' with this quantity is eliminating n-th bit.</span>
<span class="c1">// It does not matter if the n-th bit was 0 or 1, AND-ing it with 0 sets it to 0.</span>

<span class="c1">// unset 4th bit in 127:</span>
    <span class="mo">01111111</span>    <span class="o">(</span><span class="mi">127</span> <span class="n">in</span> <span class="n">binary</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mi">11101111</span>    <span class="o">(~(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="o">))</span>
    <span class="o">--------</span>
    <span class="mo">01101111</span>
</pre></table></code></div></div><h3 id="bit-hack-5-toggle-the-n-th-bit-x--1n"><strong>Bit Hack #5. Toggle the n-th bit.</strong> <code class="language-plaintext highlighter-rouge">x ^ (1&lt;&lt;n)</code></h3><p>nth</p><ul><li>if 1 -&gt; 0,<li>if 0 -&gt; 1,</ul><p>rest as same &amp;1</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="o">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="o">)</span>

<span class="c1">// The result of XOR-ing something with something else is that if both bits are the same, the result is 0, otherwise it's 1.</span>
<span class="c1">// if n-th bit was 1, XOR-ing it with 1 changes it to 0;</span>
<span class="c1">// if it was 0, then XOR-ing with with 1 changes it to 1;</span>

<span class="c1">// toggle 5th bit in value 01110101:</span>
    <span class="mo">01110101</span>
<span class="o">^</span>   <span class="mo">00100000</span>
    <span class="o">--------</span>
    <span class="mo">01010101</span>

<span class="c1">// 5th bit originally 0</span>
    <span class="mo">01010101</span>
<span class="o">^</span>   <span class="mo">00100000</span>
    <span class="o">--------</span>
    <span class="mo">01110101</span>
</pre></table></code></div></div><h3 id="bit-hack-6-turn-off-the-rightmost-1-bit-x--x-1"><strong>Bit Hack #6. Turn off the rightmost 1-bit.</strong> <code class="language-plaintext highlighter-rouge">x &amp; (x-1)</code></h3><p>1010 1001 -&gt; 1000</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>

<span class="c1">// For example,</span>
<span class="c1">// given 001010**1**0 (the rightmost 1-bit in bold) it turns it into 00101000.</span>
<span class="c1">// given 00010000 it turns it into 0, as there is just a single 1-bit.</span>

    <span class="mo">01010111</span>    <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mo">01010110</span>    <span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">01010110</span>

    <span class="mo">01011000</span>    <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mo">01010111</span>    <span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">01010000</span>

    <span class="mi">10000000</span>    <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mo">01111111</span>    <span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">127</span> <span class="o">(</span><span class="n">with</span> <span class="n">overflow</span><span class="o">))</span>
    <span class="o">--------</span>
    <span class="mo">00000000</span>

    <span class="mi">11111111</span>    <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">all</span> <span class="n">bits</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mi">11111110</span>    <span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mi">11111110</span>

    <span class="mo">00000000</span>    <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">no</span> <span class="n">rightmost</span> <span class="mi">1</span><span class="o">-</span><span class="n">bits</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mi">11111111</span>    <span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000000</span>
</pre></table></code></div></div><hr /><h3 id="bit-hack-7-isolate-the-rightmost-1-bit-x---x"><strong>Bit Hack #7. Isolate the rightmost 1-bit.</strong> <code class="language-plaintext highlighter-rouge">x &amp; (-x)</code></h3><p>1010</p><p>1001 x-1 0110 -(x-1)</p><p>0010</p><p>1010 0101 ~x 0110 ~x+1</p><p>0010</p><pre><code class="language-JAVA">y = x &amp; (-x)
</code></pre><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="c1">// finds the rightmost 1-bit and sets all the other bits to 0.</span>
<span class="c1">// The end result has only that one rightmost 1-bit set.</span>
<span class="c1">// For example, 01010**1**00 (rightmost bit in bold) gets turned into 00000100.</span>

<span class="c1">// 01010100</span>
<span class="c1">// 01010011</span>

<span class="c1">// 00000100</span>

<span class="c1">// Here are some more examples:</span>

    <span class="mi">10111100</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mo">01000100</span>  <span class="o">(-</span><span class="n">x</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000100</span>

    <span class="mo">01110000</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mi">10010000</span>  <span class="o">(-</span><span class="n">x</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00010000</span>

    <span class="mo">00000001</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mi">11111111</span>  <span class="o">(-</span><span class="n">x</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000001</span>

    <span class="mi">10000000</span>  <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mi">10000000</span>  <span class="o">(-</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mi">10000000</span>

    <span class="mi">11111111</span>  <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">all</span> <span class="n">bits</span> <span class="n">one</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mo">00000001</span>  <span class="o">(-</span><span class="n">x</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000001</span>

    <span class="mo">00000000</span>  <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">all</span> <span class="n">bits</span> <span class="mi">0</span><span class="o">,</span> <span class="n">no</span> <span class="n">rightmost</span> <span class="mi">1</span><span class="o">-</span><span class="n">bit</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mo">00000000</span>  <span class="o">(-</span><span class="n">x</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000000</span>
</pre></table></code></div></div><hr /><h3 id="bit-hack-8-right-propagate-the-rightmost-1-bit-x--x-1"><strong>Bit Hack #8. Right propagate the rightmost 1-bit.</strong> <code class="language-plaintext highlighter-rouge">x | (x-1)</code></h3><p>01010000 01001111 x-1 -&gt; 01011111</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|</span> <span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>

<span class="c1">// Given a value 01010000</span>
<span class="c1">// turns it into 01011111.</span>
<span class="c1">// All the 0-bits right to the rightmost 1-bit got turned into ones.</span>

    <span class="mi">10111100</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">|</span>   <span class="mi">10111011</span>  <span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mi">10111111</span>

    <span class="mo">01110111</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">|</span>   <span class="mo">01110110</span>  <span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">01110111</span>

    <span class="mo">00000001</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">|</span>   <span class="mo">00000000</span>  <span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000001</span>

    <span class="mi">10000000</span>  <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span><span class="o">)</span>
<span class="o">|</span>   <span class="mo">01111111</span>  <span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">127</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mi">11111111</span>

    <span class="mi">11111111</span>  <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
<span class="o">|</span>   <span class="mi">11111110</span>  <span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mi">11111111</span>

    <span class="mo">00000000</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">|</span>   <span class="mi">11111111</span>  <span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mi">11111111</span>
</pre></table></code></div></div><hr /><h3 id="bit-hack-9-isolate-the-rightmost-0-bit-x--x1"><strong>Bit Hack #9. Isolate the rightmost 0-bit.</strong> <code class="language-plaintext highlighter-rouge">~x &amp; (x+1)</code></h3><p>10101011 10101100 x+1 01010100 ~x</p><p>00000100</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="n">y</span> <span class="o">=</span> <span class="o">~</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
<span class="c1">// finds the rightmost 0-bit, turns off all bits, and sets this bit to 1 in the result.</span>
<span class="c1">// number 10101**0**11,</span>
<span class="c1">// producing 00000100.</span>

<span class="nc">More</span> <span class="nl">examples:</span>

    <span class="mi">10111100</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">01000011</span>  <span class="o">(~</span><span class="n">x</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mi">10111101</span>  <span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000001</span>

    <span class="mo">01110111</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mi">10001000</span>  <span class="o">(~</span><span class="n">x</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mo">01111000</span>  <span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00001000</span>

    <span class="mo">00000001</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mi">11111110</span>  <span class="o">(~</span><span class="n">x</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mo">00000010</span>  <span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000010</span>

    <span class="mi">10000000</span>  <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">01111111</span>  <span class="o">(~</span><span class="n">x</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mi">10000001</span>  <span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000001</span>

    <span class="mi">11111111</span>  <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">no</span> <span class="n">rightmost</span> <span class="mi">0</span><span class="o">-</span><span class="n">bit</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000000</span>  <span class="o">(~</span><span class="n">x</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mo">00000000</span>  <span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000000</span>

    <span class="mo">00000000</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mi">11111111</span>  <span class="o">(~</span><span class="n">x</span><span class="o">)</span>
<span class="o">&amp;</span>   <span class="mo">00000001</span>  <span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000001</span>
</pre></table></code></div></div><h3 id="bit-hack-10-turn-on-the-rightmost-0-bit-x--x1"><strong>Bit Hack #10. Turn on the rightmost 0-bit.</strong> <code class="language-plaintext highlighter-rouge">x | (x+1)</code></h3><p>10100011</p><p>10100100 x+1</p><p>10100111</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|</span> <span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>

<span class="c1">// This hack changes the rightmost 0-bit into 1.</span>
<span class="c1">// given an integer 10100011 it turns it into 10100111.</span>

<span class="c1">// More examples:</span>

    <span class="mi">10111100</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">|</span>   <span class="mi">10111101</span>  <span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mi">10111101</span>

    <span class="mo">01110111</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">|</span>   <span class="mo">01111000</span>  <span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">01111111</span>

    <span class="mo">00000001</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">|</span>   <span class="mo">00000010</span>  <span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000011</span>

    <span class="mi">10000000</span>  <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span><span class="o">)</span>
<span class="o">|</span>   <span class="mi">10000001</span>  <span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mi">10000001</span>

    <span class="mi">11111111</span>  <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">no</span> <span class="n">rightmost</span> <span class="mi">0</span><span class="o">-</span><span class="n">bit</span><span class="o">)</span>
<span class="o">|</span>   <span class="mo">00000000</span>  <span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mi">11111111</span>

    <span class="mo">00000000</span>  <span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">|</span>   <span class="mo">00000001</span>  <span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">--------</span>
    <span class="mo">00000001</span>
</pre></table></code></div></div><h3 id="bonus-stuff">Bonus stuff</h3><p>utility functions to print binary values of <strong>8 bit signed integers</strong> in Perl, Python and C.</p><ol><li>Print binary representation in Perl:</ol><pre><code class="language-Perl">sub int_to_bin {
  my $num = shift;
  print unpack "B8", pack "c", $num;
}

#print it from command
# perl -wle 'print unpack "B8", pack "c", shift' &lt;integer&gt;

# For example:
perl -wle 'print unpack &amp;#34;B8&amp;#34;, pack &amp;#34;c&amp;#34;, shift' 113
01110001

perl -wle 'print unpack &amp;#34;B8&amp;#34;, pack &amp;#34;c&amp;#34;, shift' -128
10000000
</code></pre><ol><li>Print binary number in Python:</ol><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">int_to_bin</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">bits</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="s">''</span>
    <span class="k">while</span> <span class="n">bits</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="s">'1'</span> <span class="k">if</span> <span class="n">num</span><span class="o">&amp;</span><span class="mi">1</span> <span class="k">else</span> <span class="s">'0'</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
    <span class="k">print</span> <span class="n">r</span>
</pre></table></code></div></div><ol><li>Print binary representation in C:</ol><div class="language-c highlighter-rouge"><div class="code-header" text-data="c"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">int_to_bin</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">str</span><span class="err">\</span><span class="p">[</span><span class="mi">9</span><span class="err">\</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">str</span><span class="err">\</span><span class="p">[</span><span class="n">i</span><span class="err">\</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="sc">'1'</span><span class="o">:</span><span class="sc">'0'</span><span class="p">;</span>
    <span class="n">num</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><h2 id="-bit-operation---binary">🔒 bit operation - Binary</h2><hr /><h3 id="268-missing-number-easy">268. Missing Number (Easy)</h3><p>Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.</p><p>Example 1: Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.</p><p>Example 2: Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.</p><h4 id="xor">XOR</h4><h4 id="sum">SUM</h4><h4 id="binary-search-1">Binary Search</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>

</pre></table></code></div></div><hr /><h3 id="338-counting-bits-easy">338. Counting Bits (Easy)</h3><p><a href="https://leetcode.com/problems/counting-bits/">338. Counting Bits</a> Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1’s in the binary representation of i.</p><p>Example 1: Input: n = 2 Output: [0,1,1] Explanation: 0 –&gt; 0 1 –&gt; 1 2 –&gt; 10</p><p>Example 2: Input: n = 5 Output: [0,1,1,2,1,2] Explanation: 0 –&gt; 0 1 –&gt; 1 2 –&gt; 10 3 –&gt; 11 4 –&gt; 100 5 –&gt; 101</p><h4 id="-check-each-integarbitcountn">+++++ <code class="language-plaintext highlighter-rouge">check each, Integar.bitCount(n)</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 99.96% of Java online submissions for Counting Bits.</span>
<span class="c1">// Memory Usage: 46.6 MB, less than 78.95% of Java online submissions for Counting Bits.</span>


<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">countBits</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">bitCount</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-dp--bit-operation">+++++ <code class="language-plaintext highlighter-rouge">DP + bit operation</code></h4><p>Explanation. Take number X for example, 10011001. Divide it in 2 parts:</p><ol><li>the last digit ( 1 or 0, which is “ i&amp;1 “, equivalent to “ i%2 “ )<li>the other digits ( the number of 1, which is “ f[i » 1] “, equivalent to “ f[i/2] “ )</ol><p>10011001 = 1001100 + 1 = res[i»1] + 1?</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 3 ms, faster than 45.42% of Java online submissions for Counting Bits.</span>
<span class="c1">// Memory Usage: 48.3 MB, less than 32.29% of Java online submissions for Counting Bits.</span>
<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">countBits</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">num</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">[</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">);</span>
    <span class="c1">// for (int i=1; i&lt;=num; i++) f[i] = f[i/2] + (i%2);</span>
    <span class="k">return</span> <span class="n">f</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="191-number-of-1-bits-easy">191. Number of 1 Bits (Easy)</h3><p><a href="https://leetcode.com/problems/number-of-1-bits/">191. Number of 1 Bits</a> Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight).</p><p>Note:</p><ul><li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.<li>In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3, the input represents the signed integer. -3. s Example 1: Input: n = 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three ‘1’ bits.</ul><p>Example 2: Input: n = 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one ‘1’ bit.</p><h4 id="-brian-kernighan-algorithm">+++++ <strong>Brian Kernighan Algorithm</strong></h4><ul><li>Using Brian Kernighan Algorithm, we will not check/compare or loop through all the 32 bits present but only count the set bits<li>Suppose we have a number 10000000000000010000000000000001 (32 bits), now using this algorithm we will skip the 0’s bit and directly jump to set bit(1’s bit) and we don’t have to go through each bit to count set bits i.e. the loop will be executed only for 3 times for the mentioned example and not for 32 times.</ul><h4 id="-检查每一个-last-1然后carry">+++++ <code class="language-plaintext highlighter-rouge">&amp;检查每一个 last 1，然后carry</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// Time: O(m), where m is the number of set bits</span>
<span class="c1">// Space: O(1), in-place</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">// you need to treat n as an unsigned value</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hammingWeight</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">n</span><span class="o">!=</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="o">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span><span class="o">);</span>
            <span class="c1">// need to use bit shifting unsigned operation &gt;&gt;&gt;</span>
            <span class="c1">// &gt;&gt; depends on sign extension</span>
            <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">&gt;&gt;&gt;</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-use-integerbitcountn">+++++ <code class="language-plaintext highlighter-rouge">use Integer.bitCount(n);</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 1 ms, faster than 78.81% of Java online submissions for Number of 1 Bits.</span>
<span class="c1">// Memory Usage: 41.3 MB, less than 47.87% of Java online submissions for Number of 1 Bits.</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">// you need to treat n as an unsigned value</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hammingWeight</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">bitCount</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h3 id="371-sum-of-two-integers-medium">371. Sum of Two Integers (Medium)</h3><p><a href="https://leetcode.com/problems/sum-of-two-integers/">371. Sum of Two Integers</a> Given two integers a and b, return the sum of the two integers without using the operators + and -.</p><p>Example 1: Input: a = 1, b = 2 Output: 3</p><p>Example 2: Input: a = 2, b = 3 Output: 5</p><h4 id="-bit-operation-carry">+++++ <code class="language-plaintext highlighter-rouge">bit operation carry</code></h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Sum of Two Integers.</span>
<span class="c1">// Memory Usage: 41.5 MB, less than 13.39% of Java online submissions for Sum of Two Integers.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">xor</span><span class="o">=</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="o">,</span> <span class="n">carry</span><span class="o">=</span><span class="n">a</span><span class="o">&amp;</span><span class="n">b</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">carry</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">xor</span><span class="o">;</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">carry</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">xor</span> <span class="o">=</span> <span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="o">;</span>
            <span class="n">carry</span> <span class="o">=</span> <span class="n">a</span><span class="o">&amp;</span><span class="n">b</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">xor</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Sum of Two Integers.</span>
<span class="c1">// Memory Usage: 40.9 MB, less than 41.89% of Java online submissions for Sum of Two Integers.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">xor</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
            <span class="n">xor</span><span class="o">=</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="o">;</span>
            <span class="n">b</span><span class="o">=(</span><span class="n">a</span><span class="o">&amp;</span><span class="n">b</span><span class="o">)&lt;&lt;</span><span class="mi">1</span><span class="o">;</span>
            <span class="n">a</span><span class="o">=</span><span class="n">xor</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="-recursive-2">+++++ Recursive</h4><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// T/S: O(1)/O(1)</span>
<span class="c1">// Runtime: 0 ms, faster than 100.00% of Java online submissions for Sum of Two Integers.</span>
<span class="c1">// Memory Usage: 38.8 MB, less than 92.07% of Java online submissions for Sum of Two Integers.</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">getSum</span><span class="o">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">&amp;</span><span class="n">b</span><span class="o">)&lt;&lt;</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><p>.</p><hr /><h1 id="system-design">system design</h1><p>https://github.com/donnemartin/system-design-primer</p><p>.</p><hr /><h1 id="game">game</h1><h2 id="tictactoe">TicTacToe</h2><ul><li>Cells in this array store values that indicate if that cell is empty or stores an X or O.<li>This encoding allows us to have a simple way of testing if a given board configuration is a win for X or O, namely, if the values of a row, column, or diagonal add up to 3 or −3, respectively.</ul><p>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/00codenote/'>00CodeNote</a>, <a href='/categories/ds/'>DS</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Labuladong - Grace&url=https://ocholuo.github.io//posts/Labuladong/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Labuladong - Grace&u=https://ocholuo.github.io//posts/Labuladong/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Labuladong - Grace&url=https://ocholuo.github.io//posts/Labuladong/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Amazon-CloudFront/">AWS Lab - AWS CloudFront</a><li><a href="/posts/Alexa-1stSkill/">AWS Alex First Skill - RedVelvet Time</a><li><a href="/posts/NetworkProtocol-SSL-TLS-Handshake/">NetworkProtocol SSL/TLS Handshake</a><li><a href="/posts/pythonCrash/">Python Crash</a><li><a href="/posts/%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%A7%A3%E9%87%8AAWS/">AWS - 一句话解释AWS</a><li><a href="/posts/GKE/">GCP - Google Cloud Computing - Kubernetes and Kubernetes Engine</a><li><a href="/posts/Go-Note/">Go Note</a><li><a href="/posts/SCPs/">AWS - IdenAccessManage - SCPs (Service Control Policies)</a><li><a href="/posts/CompanyBenefit/">Company Benefit</a><li><a href="/posts/Encryption-SSL&TLS/">Cryptography - SSL/TLS Encryption</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/soc/">SOC</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/DS-Basic1-DS/"><div class="card-body"> <span class="timeago small" >Oct 10, 2021<i class="unloaded">2021-10-10T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Data Structures - Basic 1 - Data Structures</h3><div class="text-muted small"><p> Data Structures - Basic 1 - Data Structures overall pic Linear Structures String String class StringBuilder class ...</p></div></div></a></div><div class="card"> <a href="/posts/DS-Basic0-OOD/"><div class="card-body"> <span class="timeago small" >Oct 10, 2021<i class="unloaded">2021-10-10T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Data Structures - Basic 0 - Object Oriented Programming</h3><div class="text-muted small"><p> Object-oriented programming 面向对象编程 language different 面向过程和OOP在程序流程上的不同之处。 code different OOP inter Basic OOD Goals...</p></div></div></a></div><div class="card"> <a href="/posts/DS-Basic0/"><div class="card-body"> <span class="timeago small" >Oct 10, 2021<i class="unloaded">2021-10-10T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Data Structures - Basic 0</h3><div class="text-muted small"><p> DS Type Base Type Enum Types 枚举 Type Conversions Wrapper Classes and Objects Creating and Using O...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/DS-Basic0/" class="btn btn-outline-primary" prompt="Older"><p>Data Structures - Basic 0</p></a> <a href="/posts/CompanyBenefit/" class="btn btn-outline-primary" prompt="Newer"><p>Company Benefit</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/ocholuo">Grace JyL</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/soc/">SOC</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://ocholuo.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script defer src="/assets/js/dist/pvreport.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-179830187-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-179830187-1'); }); </script>
