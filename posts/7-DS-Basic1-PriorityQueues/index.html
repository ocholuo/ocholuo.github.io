<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="pv-proxy-endpoint" content="https://myochosite-291718.appspot.com/query?id=ahNwfm15b2Nob3NpdGUtMjkxNzE4chULEghBcGlRdWVyeRiAgIDo14eBCgw"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Data Structures - Basic 1 - Priority Queues" /><meta property="og:locale" content="en" /><meta name="description" content="Data Structures Basic 1 Priority Queues Priority Queues ADT: Priority Queue in java Implementing a Priority Queue Entry Interface PriorityQueue Interface defining comparisons Comparable Interface Comparator Interface AbstractPriorityQueue Abstract base class UnsortedPriorityQueue class Unsorted List SortedPriorityQueue class sorted List import java.util.PriorityQueue Binary Heap 堆 The Heap Data Structure The Height of a Heap Implement Priority Queue Implementing a Priority Queue with a Heap Complete Binary Tree Array-Based priority queue heap-based heap in java analyze the binary heap max heap in java min heap in python Bottom-Up Heap Construction Implementation in Java Asymptotic Analysis of Bottom-Up Heap Construction java.util.PriorityQueue Class Sorting with a Priority Queue Selection-Sort Insertion-Sort Heap-Sort Implementing Heap-Sort In-Place Adaptable Priority Queues The Adaptable Priority Queue ADT Location-Aware Entries Implementing an Adaptable Priority Queue" /><meta property="og:description" content="Data Structures Basic 1 Priority Queues Priority Queues ADT: Priority Queue in java Implementing a Priority Queue Entry Interface PriorityQueue Interface defining comparisons Comparable Interface Comparator Interface AbstractPriorityQueue Abstract base class UnsortedPriorityQueue class Unsorted List SortedPriorityQueue class sorted List import java.util.PriorityQueue Binary Heap 堆 The Heap Data Structure The Height of a Heap Implement Priority Queue Implementing a Priority Queue with a Heap Complete Binary Tree Array-Based priority queue heap-based heap in java analyze the binary heap max heap in java min heap in python Bottom-Up Heap Construction Implementation in Java Asymptotic Analysis of Bottom-Up Heap Construction java.util.PriorityQueue Class Sorting with a Priority Queue Selection-Sort Insertion-Sort Heap-Sort Implementing Heap-Sort In-Place Adaptable Priority Queues The Adaptable Priority Queue ADT Location-Aware Entries Implementing an Adaptable Priority Queue" /><link rel="canonical" href="https://ocholuo.github.io//posts/7-DS-Basic1-PriorityQueues/" /><meta property="og:url" content="https://ocholuo.github.io//posts/7-DS-Basic1-PriorityQueues/" /><meta property="og:site_name" content="Grace" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-08-25T11:11:11-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Data Structures - Basic 1 - Priority Queues" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-10-30T21:02:21-04:00","datePublished":"2019-08-25T11:11:11-04:00","description":"Data Structures Basic 1 Priority Queues Priority Queues ADT: Priority Queue in java Implementing a Priority Queue Entry Interface PriorityQueue Interface defining comparisons Comparable Interface Comparator Interface AbstractPriorityQueue Abstract base class UnsortedPriorityQueue class Unsorted List SortedPriorityQueue class sorted List import java.util.PriorityQueue Binary Heap 堆 The Heap Data Structure The Height of a Heap Implement Priority Queue Implementing a Priority Queue with a Heap Complete Binary Tree Array-Based priority queue heap-based heap in java analyze the binary heap max heap in java min heap in python Bottom-Up Heap Construction Implementation in Java Asymptotic Analysis of Bottom-Up Heap Construction java.util.PriorityQueue Class Sorting with a Priority Queue Selection-Sort Insertion-Sort Heap-Sort Implementing Heap-Sort In-Place Adaptable Priority Queues The Adaptable Priority Queue ADT Location-Aware Entries Implementing an Adaptable Priority Queue","headline":"Data Structures - Basic 1 - Priority Queues","mainEntityOfPage":{"@type":"WebPage","@id":"https://ocholuo.github.io//posts/7-DS-Basic1-PriorityQueues/"},"url":"https://ocholuo.github.io//posts/7-DS-Basic1-PriorityQueues/"}</script><title>Data Structures - Basic 1 - Priority Queues | Grace</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Grace"><meta name="application-name" content="Grace"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://myochosite-291718.appspot.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://myochosite-291718.appspot.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/huoye.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Grace</a></div><div class="site-subtitle font-italic">2023 Mar 14 updated</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ocholuo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Data Structures - Basic 1 - Priority Queues</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Data Structures - Basic 1 - Priority Queues</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Grace JyL </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Aug 25, 2019, 11:11 AM -0400" >Aug 25, 2019<i class="unloaded">2019-08-25T11:11:11-04:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Oct 30, 2022, 6:02 PM -0700" >Oct 30, 2022<i class="unloaded">2022-10-30T21:02:21-04:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="10683 words">59 min read</span> <span id="pv" class="pageviews"> <i class="fas fa-spinner fa-spin fa-fw"></i> </span> views</div></div><div class="post-content"><ul><li><a href="#data-structures-basic-1-priority-queues">Data Structures Basic 1 Priority Queues</a><ul><li><a href="#priority-queues">Priority Queues</a><ul><li><a href="#adt-priority-queue-in-java">ADT: Priority Queue in java</a><li><a href="#implementing-a-priority-queue">Implementing a Priority Queue</a><ul><li><a href="#entry-interface">Entry <strong>Interface</strong></a><li><a href="#priorityqueue-interface">PriorityQueue <strong>Interface</strong></a><li><a href="#defining-comparisons">defining comparisons</a><ul><li><a href="#comparable-interface">Comparable <strong>Interface</strong></a><li><a href="#comparator-interface">Comparator <strong>Interface</strong></a></ul><li><a href="#abstractpriorityqueue-abstract-base-class">AbstractPriorityQueue <strong>Abstract base class</strong></a><li><a href="#unsortedpriorityqueue-class-unsorted-list">UnsortedPriorityQueue <strong>class</strong> Unsorted List</a><li><a href="#sortedpriorityqueue-class-sorted-list">SortedPriorityQueue <strong>class</strong> sorted List</a><li><a href="#import-javautilpriorityqueue">import java.util.PriorityQueue</a></ul></ul><li><a href="#binary-heap-堆">Binary Heap 堆</a><ul><li><a href="#the-heap-data-structure">The Heap Data Structure</a><ul><li><a href="#the-height-of-a-heap">The Height of a Heap</a></ul></ul><li><a href="#implement-priority-queue">Implement Priority Queue</a><ul><li><a href="#implementing-a-priority-queue-with-a-heap">Implementing a Priority Queue with a Heap</a><ul><li><a href="#complete-binary-tree-array-based">Complete Binary Tree <strong>Array-Based</strong></a><li><a href="#priority-queue-heap-based">priority queue <strong>heap-based</strong></a><ul><li><a href="#heap-in-java">heap in java</a><ul><li><a href="#analyze-the-binary-heap">analyze the binary heap</a></ul><li><a href="#max-heap-in-java">max heap in java</a><ul><li><a href="#min-heap-in-python">min heap in python</a></ul></ul></ul><li><a href="#bottom-up-heap-construction">Bottom-Up Heap Construction</a><ul><li><a href="#implementation-in-java">Implementation in Java</a><ul><li><a href="#asymptotic-analysis-of-bottom-up-heap-construction">Asymptotic Analysis of Bottom-Up Heap Construction</a></ul></ul><li><a href="#javautilpriorityqueue-class">java.util.PriorityQueue <strong>Class</strong></a></ul><li><a href="#sorting-with-a-priority-queue">Sorting with a Priority Queue</a><ul><li><a href="#selection-sort">Selection-Sort</a><li><a href="#insertion-sort">Insertion-Sort</a><li><a href="#heap-sort">Heap-Sort</a><li><a href="#implementing-heap-sort-in-place">Implementing Heap-Sort In-Place</a></ul><li><a href="#adaptable-priority-queues">Adaptable Priority Queues</a><ul><li><a href="#the-adaptable-priority-queue-adt">The Adaptable Priority Queue ADT</a><ul><li><a href="#location-aware-entries">Location-Aware Entries</a><li><a href="#implementing-an-adaptable-priority-queue">Implementing an Adaptable Priority Queue</a></ul></ul></ul><li>ref<ul><li>DS - pythonds3 - 7. Binary Heap<li>Data Structures and Algorithms in Java, 6th Edition.pdf</ul></ul><hr /><h1 id="data-structures-basic-1-priority-queues">Data Structures Basic 1 Priority Queues</h1><hr /><h2 id="priority-queues">Priority Queues</h2><p><strong>queue</strong></p><ul><li>first-in first-out data structure</ul><p>In practice, there are many applications in which a <code class="language-plaintext highlighter-rouge">queue-like structure</code> is used to manage objects that must be processed in some way, but <code class="language-plaintext highlighter-rouge">the first-in, first-out policy does not suffice</code>.</p><ul><li>It is unlikely that the landing decisions are based purely on a FIFO policy.<li>“first come, first serve” policy might seem reasonable, yet for which other priorities come into play.</ul><p><strong>priority queue</strong></p><ul><li><p>One important variation of Queue</p><li>a collection of <code class="language-plaintext highlighter-rouge">prioritized elements</code> that<ul><li>allows <code class="language-plaintext highlighter-rouge">arbitrary element insertion</code>,<li>and allows <code class="language-plaintext highlighter-rouge">the removal of the element that has first priority</code>.</ul><li>A priority queue acts like a queue that dequeue an item by removing it from the front.<ul><li>However, in a priority queue the <code class="language-plaintext highlighter-rouge">logical order of items</code> inside a queue is determined by their <code class="language-plaintext highlighter-rouge">priority</code>.<li>The highest priority items are at the front of the queue and the lowest priority items are at the back.<li>Thus when you enqueue an item on a priority queue, the new item may move all the way to the front.</ul></ul><p>When an element is added to a priority queue</p><ul><li>the user designates its priority by providing an associated <strong>key</strong>.<li><code class="language-plaintext highlighter-rouge">The element with the minimal key will be the next to be removed</code> from the queue<ul><li>an element with key 1 will be given priority over an element with key 2</ul><li>Although it is quite common for priorities to be expressed numerically, any Java object may be used as a key, as long as there exists means to compare any two instances a and b, in a way that defines a natural order of the keys.<li>With such generality, applications may develop their own notion of priority for each element.<ul><li>For example<li>different financial analysts may assign different ratings (i.e., priorities) to a particular asset, such as a share of stock.</ul></ul><p>Implement a priority queue using <code class="language-plaintext highlighter-rouge">sorting</code> functions and <code class="language-plaintext highlighter-rouge">lists</code>.</p><ul><li>However, inserting into a list is <code class="language-plaintext highlighter-rouge">𝑂(𝑛)</code> and sorting a list is <code class="language-plaintext highlighter-rouge">𝑂(𝑛log𝑛)</code><li>We can do better.<li>The classic way to implement a priority queue is using a data structure called a <code class="language-plaintext highlighter-rouge">binary heap</code>.<ul><li>A binary heap will allow us both enqueue and dequeue items in <code class="language-plaintext highlighter-rouge">𝑂(log𝑛)</code>.</ul></ul><hr /><h3 id="adt-priority-queue-in-java">ADT: Priority Queue in java</h3><ul><li>When an element is added to a priority queue, the user designates its priority by providing an associated key.<li>The element with the minimal key will be the next to be removed from the queue (thus, an element with key 1 will be given priority over an element with key 2).<li>Although it is quite common for priorities to be expressed numerically, any Java object may be used as a key, as long as there exists means to compare any two instances a and b, in a way that defines a natural order of the keys.<li>With such generality, applications may develop their own notion of priority for each element.<ul><li>For example,<li>different financial analysts may assign different ratings (i.e., priorities) to a particular asset,<li>such as a share of stock.</ul></ul><p><code class="language-plaintext highlighter-rouge">insert(k, v)</code>:</p><ul><li>Creates an entry with key k and value v in the priority queue.</ul><p><code class="language-plaintext highlighter-rouge">min()</code>:</p><ul><li>Returns (but does not remove) a priority queue entry (k,v) having minimal key;<li>returns null if the priority queue is empty.</ul><p><code class="language-plaintext highlighter-rouge">removeMin()</code>:</p><ul><li>Removes and returns an entry (k,v) having minimal key fromm the priority queue;<li>returns null if the priority queue is empty.</ul><p><code class="language-plaintext highlighter-rouge">size()</code>:</p><ul><li>Returns the number of entries in the priority queue.</ul><p><code class="language-plaintext highlighter-rouge">isEmpty()</code>:</p><ul><li>Returns a boolean indicating whether the priority queue is empty.</ul><p>total order relation</p><ul><li>it satisfies the following properties for any keys k1, k2, and k3:<li><strong>Comparability property</strong>: k1 ≤ k2 or k2 ≤ k1.<li><strong>Antisymmetric property</strong>: if k1 ≤ k2 and k2 ≤ k1, then k1 = k2.<li><strong>Transitive property</strong>: if k1 ≤ k2 and k2 ≤ k3, then k1 ≤ k3.</ul><div class="table-wrapper"><table><thead><tr><th>Method<th>Unsorted List<th>Sorted List<tbody><tr><td>size<td>O(1)<td>O(1)<tr><td>isEmpty<td>O(1)<td>O(1)<tr><td>insert<td>O(1)<td>O(n)<tr><td>min<td>O(n)<td>O(1)<tr><td>removeMin<td>O(n)<td>O(1)<tr><td>space requirement<td>O(n)<td> </table></div><hr /><h3 id="implementing-a-priority-queue">Implementing a Priority Queue</h3><hr /><h4 id="entry-interface">Entry <strong>Interface</strong></h4><p>implementing a priority queue</p><ul><li>we must keep track of both <code class="language-plaintext highlighter-rouge">an element and its key</code><ul><li>even as entries are relocated within a data structure.</ul><li>This is reminiscent of maintain a list of elements with access frequencies.<ul><li>use <strong>Design Pattern: Composite</strong><li><p>defining an Item class that paired each element with its associated count in our primary data structure.</p><li>For priority queues<ul><li>we use composition to <code class="language-plaintext highlighter-rouge">pair a key k and a value v as a single object</code>.<li>To formalize this, we define the public interface, <code class="language-plaintext highlighter-rouge">Entry</code></ul></ul></ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// ∗ Interface for a key-value pair. ∗/</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">K</span> <span class="nf">getKey</span><span class="o">();</span>
    <span class="no">V</span> <span class="nf">getV</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="priorityqueue-interface">PriorityQueue <strong>Interface</strong></h4><p>use the Entry interface for the priority queue</p><ul><li>This allows us to <code class="language-plaintext highlighter-rouge">return both a key and value as a single object</code> from methods such as min and removeMin.</ul><p>define the insert method to return an entry;</p><ul><li>in a more <strong>advanced adaptable priority queue</strong>, that entry can be subsequently updated or removed.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// ∗∗ Interface for the priority queue ADT. ∗/</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="o">();</span>
    <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">();</span>
    <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">insert</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span><span class="o">;</span>
    <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">mim</span><span class="o">();</span>
    <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">removeMim</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="defining-comparisons">defining comparisons</h4><p><strong>Comparing Keys with Total Orders</strong></p><ul><li>we can allow any type of object to serve as a key<ul><li>but we must be able to compare keys to each other in a meaningful way.<li>More so, the results of the comparisons must not be contradictory.</ul><li><p>For a comparison rule, which we denote by ≤, to be self-consistent, it must define a total order relation, which is to say that it satisfies the following properties for any keys k1, k2, and k3:</p><ul><li><strong>Comparability property</strong>: k1 ≤ k2 or k2 ≤ k1.<ul><li>The comparability property states that comparison rule is defined for every pair of keys.<li>Note that this property implies the following one:<ul><li><strong>Reflexive property</strong>: k ≤ k.</ul></ul><li><strong>Antisymmetric property</strong>: if k1 ≤ k2 and k2 ≤ k1, then k1 = k2.<li><strong>Transitive property</strong>: if k1 ≤ k2 and k2 ≤ k3, then k1 ≤ k3.</ul><li>A comparison rule, ≤, that defines a total order relation will never lead to a contradiction.<li>Such a rule defines a linear ordering among a set of keys;<ul><li>hence, if a (finite) set of elements has a total order defined for it, then the notion of a minimal key, kmin, is well defined, as a key in which kmin ≤ k, for any other key k in our set.</ul><li>Java provides two means for defining comparisons between object types.</ul><hr /><h5 id="comparable-interface">Comparable <strong>Interface</strong></h5><p>a class may define what is known as the natural ordering of its instances by formally implementing the <code class="language-plaintext highlighter-rouge">java.lang.Comparable</code> interface -&gt; method, <code class="language-plaintext highlighter-rouge">compareTo</code>.</p><ul><li>For example,<ul><li>the <strong>compareTo method of the String class</strong> defines the natural ordering of strings to be lexicographic, which is a case-sensitive extension of the alphabetic ordering to Unicode.</ul></ul><p>The syntax <code class="language-plaintext highlighter-rouge">a.compareTo(b)</code> must return an integer i with the following meaning:</p><ul><li>i&lt;0 designates that <code class="language-plaintext highlighter-rouge">a&lt;b</code>.<li>i=0 designates that <code class="language-plaintext highlighter-rouge">a=b</code>.<li>i&gt;0 designates that <code class="language-plaintext highlighter-rouge">a&gt;b</code>.</ul><hr /><h5 id="comparator-interface">Comparator <strong>Interface</strong></h5><ul><li>to compare objects according to some notion other than their natural ordering.<li>For example<ul><li>which of two strings is the shortest<li>defining our own complex rules for judging which of two stocks is more promising.</ul><li>To support generality, Java defines the <code class="language-plaintext highlighter-rouge">java.util.Comparator interface</code>.<ul><li>A comparator is an object that is external to the class of the keys it compares.<li>It provides a method with the signature <code class="language-plaintext highlighter-rouge">compare(a, b)</code> that returns an integer with similar meaning to the <code class="language-plaintext highlighter-rouge">compareTo</code> method described above.</ul></ul><p><strong>Example</strong></p><ul><li>a <strong>comparator</strong> that evaluates strings based on their <code class="language-plaintext highlighter-rouge">length</code> (rather than their natural lexicographic order).</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// /∗∗ Compares two strings according to their lengths. ∗/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringLengthComparator</span> <span class="kd">implements</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">,</span> <span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="err">−</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Comparators and the Priority Queue ADT</strong></p><p>For a general and reusable form of a priority queue</p><ol><li><p>it allow a user to <code class="language-plaintext highlighter-rouge">choose any key type</code> and to <code class="language-plaintext highlighter-rouge">send an appropriate comparator instance as a parameter to the priority queue constructor</code>.</p><ul><li>The priority queue will use that comparator anytime it needs to compare two keys to each other.</ul><li><p>it allow a <code class="language-plaintext highlighter-rouge">default priority queue to instead rely on the natural ordering</code> for the given keys (assuming those keys come from a comparable class).</p><ul><li>In that case, we build our own instance of a DefaultComparator class<li>implements a comparator based upon the natural ordering of its element type.</ul></ol><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultComparator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">,</span> <span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ClassCastException</span> <span class="o">{</span>
      <span class="k">return</span> <span class="o">(</span> <span class="o">(</span><span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;)</span> <span class="n">a</span> <span class="o">).</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="abstractpriorityqueue-abstract-base-class">AbstractPriorityQueue <strong>Abstract base class</strong></h4><ul><li>To manage technical issues common to all our priority queue implementations, we define an <strong>abstract base class</strong> named <code class="language-plaintext highlighter-rouge">AbstractPriorityQueue</code><li>This includes a nested <code class="language-plaintext highlighter-rouge">PQEntry</code> class that implements the public Entry interface.<li>Our abstract class also declares and initializes<ul><li>an instance variable, comp, that stores the comparator being used for the priority queue.<li>a protected method, compare, that invokes the comparator on the keys of two given entries.</ul></ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">pq</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractPriorityQueue</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">//---------------- nested PQEntry class ----------------</span>
    <span class="kd">protected</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">PQEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="no">K</span> <span class="n">k</span><span class="o">;</span>
        <span class="kd">private</span> <span class="no">V</span> <span class="n">v</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">PQEntry</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">){</span>
            <span class="n">k</span><span class="o">=</span><span class="n">key</span><span class="o">;</span>
            <span class="n">v</span><span class="o">=</span><span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// methods of the Entry interface</span>
        <span class="kd">public</span> <span class="no">K</span> <span class="nf">getKey</span><span class="o">(){</span><span class="k">return</span> <span class="n">k</span><span class="o">;}</span>
        <span class="kd">public</span> <span class="no">V</span> <span class="nf">getV</span><span class="o">(){</span><span class="k">return</span> <span class="n">v</span><span class="o">;}</span>
        <span class="c1">// utilities not exposed as part of the Entry interface</span>
        <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">setKey</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">){</span><span class="n">k</span><span class="o">=</span><span class="n">key</span><span class="o">;}</span>
        <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">setValue</span><span class="o">(</span><span class="no">V</span> <span class="n">value</span><span class="o">){</span><span class="n">v</span><span class="o">=</span><span class="n">value</span><span class="o">;}</span>

    <span class="o">}</span>

    <span class="c1">// instance variable for an AbstractPriorityQueue</span>
    <span class="kd">private</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="n">comp</span><span class="o">;</span>
    <span class="kd">protected</span> <span class="nf">AbstractPriorityQueue</span><span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">){</span><span class="n">comp</span> <span class="o">=</span> <span class="n">c</span><span class="o">;}</span>
    <span class="kd">protected</span> <span class="nf">AbstractPriorityQueue</span><span class="o">(){</span> <span class="k">this</span><span class="o">(</span><span class="k">new</span> <span class="nc">DefaultComparator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;());</span> <span class="o">}</span>

    <span class="c1">// /∗∗ Method for comparing two entries according to key ∗/</span>
    <span class="kd">protected</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">comp</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">b</span><span class="o">.</span><span class="na">getKey</span><span class="o">());}</span>

    <span class="c1">// /∗∗ Determines whether a key is valid. ∗/</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">checkKey</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">comp</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">key</span><span class="o">)==</span><span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ClassCastException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Incompatible key."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// /∗∗ Tests whether the priority queue is empty. ∗/</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">(){</span><span class="k">return</span> <span class="n">size</span><span class="o">()==</span><span class="mi">0</span><span class="o">;}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="unsortedpriorityqueue-class-unsorted-list">UnsortedPriorityQueue <strong>class</strong> Unsorted List</h4><p>store entries within an unsorted linked list.</p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">pq</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">list.*</span><span class="o">;</span>

<span class="c1">// ** An implementation of a priority queue with an unsorted list. */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UnsortedPriorityQueue</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractPriorityQueue</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">// ∗∗ primary collection of priority queue entries ∗/</span>
    <span class="kd">private</span> <span class="nc">PositionalList</span><span class="o">&lt;</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedPositionalList</span><span class="o">&lt;&gt;();</span>

    <span class="cm">/** Creates an empty priority queue based on the natural ordering of its keys. */</span>
    <span class="kd">public</span> <span class="nf">UnsortedPriorityQueue</span><span class="o">()</span> <span class="o">{</span> <span class="kd">super</span><span class="o">();</span> <span class="o">}</span>
    <span class="cm">/** Creates an empty priority queue using the given comparator to order keys. */</span>
    <span class="kd">public</span> <span class="nf">UnsortedPriorityQueue</span><span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="n">comp</span><span class="o">)</span> <span class="o">{</span> <span class="kd">super</span><span class="o">(</span><span class="n">comp</span><span class="o">);</span> <span class="o">}</span>

    <span class="cm">/** Returns the Position of an entry having minimal key. */</span>
    <span class="kd">private</span> <span class="nc">Position</span><span class="o">&lt;</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="nf">findMin</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// only called when nonempty</span>
        <span class="nc">Position</span><span class="o">&lt;</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">small</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">first</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Position</span><span class="o">&lt;</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">walk</span> <span class="o">:</span> <span class="n">list</span><span class="o">.</span><span class="na">positions</span><span class="o">())</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compare</span><span class="o">(</span><span class="n">walk</span><span class="o">.</span><span class="na">getElement</span><span class="o">(),</span> <span class="n">small</span><span class="o">.</span><span class="na">getElement</span><span class="o">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">small</span> <span class="o">=</span> <span class="n">walk</span><span class="o">;</span> <span class="c1">// found an even smaller key</span>
        <span class="k">return</span> <span class="n">small</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/** Inserts a key-value pair and returns the entry created. */</span>
    <span class="kd">public</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">insert</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span> <span class="o">{</span>
        <span class="n">checkKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span> <span class="c1">// auxiliary key-checking method (could throw exception)</span>
        <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">newest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PQEntry</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">newest</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">newest</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="cm">/** Returns (but does not remove) an entry with minimal key. */</span>
    <span class="kd">public</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">min</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">findMin</span><span class="o">().</span><span class="na">getElement</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/** Removes and returns an entry with minimal key. */</span>
    <span class="kd">public</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">removeMin</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">findMin</span><span class="o">());</span> <span class="o">}</span>

    <span class="cm">/** Returns the number of items in the priority queue. */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="sortedpriorityqueue-class-sorted-list">SortedPriorityQueue <strong>class</strong> sorted List</h4><ul><li>implementation of a priority queue also uses a positional list, yet maintains entries sorted by nondecreasing keys.<li>This ensures that the first element of the list is an entry with the smallest key.</ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">pq</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">list.*</span><span class="o">;</span>

<span class="c1">// ** An implementation of a priority queue with an unsorted list. */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SortedPriorityQueue</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractPriorityQueue</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">// ∗∗ primary collection of priority queue entries ∗/</span>
    <span class="kd">private</span> <span class="nc">PositionalList</span><span class="o">&lt;</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedPositionalList</span><span class="o">&lt;&gt;();</span>

    <span class="cm">/** Creates an empty priority queue based on the natural ordering of its keys. */</span>
    <span class="kd">public</span> <span class="nf">SortedPriorityQueue</span><span class="o">()</span> <span class="o">{</span> <span class="kd">super</span><span class="o">();</span> <span class="o">}</span>
    <span class="cm">/** Creates an empty priority queue using the given comparator to order keys. */</span>
    <span class="kd">public</span> <span class="nf">SortedPriorityQueue</span><span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="n">comp</span><span class="o">)</span> <span class="o">{</span> <span class="kd">super</span><span class="o">(</span><span class="n">comp</span><span class="o">);</span> <span class="o">}</span>

    <span class="cm">/** Inserts a key-value pair and returns the entry created. */</span>
    <span class="kd">public</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">insert</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span> <span class="o">{</span>
        <span class="n">checkKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span> <span class="c1">// auxiliary key-checking method (could throw exception)</span>
        <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">newest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PQEntry</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="nc">Position</span><span class="o">&lt;</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">walk</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">last</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">walk</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">compare</span><span class="o">(</span><span class="n">newest</span><span class="o">,</span> <span class="n">walk</span><span class="o">.</span><span class="na">getElement</span><span class="o">())&lt;</span><span class="mi">0</span> <span class="o">)</span> <span class="n">walk</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">before</span><span class="o">(</span><span class="n">walk</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">walk</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="n">list</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">newest</span><span class="o">);</span>
        <span class="k">else</span> <span class="n">list</span><span class="o">.</span><span class="na">addAfter</span><span class="o">(</span><span class="n">walk</span><span class="o">,</span> <span class="n">newest</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">newest</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/** Returns the Position of an entry having minimal key. */</span>
    <span class="kd">private</span> <span class="nc">Position</span><span class="o">&lt;</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="nf">findMin</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// only called when nonempty</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">first</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/** Returns (but does not remove) an entry with minimal key. */</span>
    <span class="kd">public</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">min</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">first</span><span class="o">().</span><span class="na">getElement</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/** Removes and returns an entry with minimal key. */</span>
    <span class="kd">public</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">removeMin</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">first</span><span class="o">());</span> <span class="o">}</span>

    <span class="cm">/** Returns the number of items in the priority queue. */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h4 id="import-javautilpriorityqueue">import java.util.PriorityQueue</h4><p>https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html#add(E)</p><hr /><h2 id="binary-heap-堆">Binary Heap 堆</h2><p>two strategies for implementing a priority queue ADT demonstrate an trade-off.</p><ul><li>using an <code class="language-plaintext highlighter-rouge">unsorted</code> list to store entries<ul><li><code class="language-plaintext highlighter-rouge">insertions</code> in <code class="language-plaintext highlighter-rouge">O(1)</code> time,<li>but <code class="language-plaintext highlighter-rouge">finding or removing</code> an element with minimal key <code class="language-plaintext highlighter-rouge">requires an O(n)-time loop</code> through the entire collection.</ul><li>using a <code class="language-plaintext highlighter-rouge">sorted</code> list,<ul><li><code class="language-plaintext highlighter-rouge">find or remove</code> the minimal element in O(1) time,<li>but <code class="language-plaintext highlighter-rouge">adding</code> a new element to the queue <code class="language-plaintext highlighter-rouge">may require O(n) time</code> to restore the sorted order.</ul></ul><p><strong>Heap</strong></p><ul><li>looks a lot like a tree,<li>but we implement it only need a single list as an internal representation.</ul><p><strong>binary heap</strong></p><ul><li>a more efficient realization of a priority queue using a data structure<li><p>This data structure allows both insertions and removals in logarithmic time, a significant improvement over the list-based implementations</p><li>The fundamental way the heap achieves this improvement is to <code class="language-plaintext highlighter-rouge">use the structure of a binary tree</code> to find a compromise between elements being entirely unsorted and perfectly sorted.</ul><p>take advantage of the logarithmic nature of the binary tree</p><ul><li>In order to guarantee logarithmic performance, we must keep our tree balanced.<li>A balanced binary tree has roughly the same number of nodes in the left and right subtrees of the root.<li>keep the tree balanced by creating a <font color="red"> complete binary tree </font>.<ul><li>A complete binary tree is a tree in which each level has all of its nodes.<li>The exception to this is the bottom level of the tree, which we fill in from left to right.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/FzGkeOJ.png" alt="heapOrder" /></p><ul><li>The binary heap has two common variations:<ul><li>min heap, the <font color="red"> smallest key is always at the front </font>,<li>max heap, the <font color="red"> largest key value is always at the front </font>.</ul></ul><hr /><h3 id="the-heap-data-structure">The Heap Data Structure</h3><ul><li>A heap is a binary tree T that stores <code class="language-plaintext highlighter-rouge">entries</code> at its <code class="language-plaintext highlighter-rouge">positions</code>, and that satisfies two additional properties:<ul><li>a <strong>relational property</strong> defined in <code class="language-plaintext highlighter-rouge">keys</code> stored in T<li>and a <strong>structural property</strong> defined in <code class="language-plaintext highlighter-rouge">the shape of T</code> itself.</ul><li><strong>relational property</strong>:<ul><li><strong>Heap-Order Property</strong>:<ul><li><code class="language-plaintext highlighter-rouge">The method to store items in a heap</code> relies on maintaining the <strong>heap order property</strong>.<li>In a heap T , for every position p other than the root, <code class="language-plaintext highlighter-rouge">the key stored at p &gt;= the key stored at p’s parent</code>.<li>consequence:<ul><li>the keys encountered on a path from the root to a leaf of T are in nondecreasing order.<li>Also, a minimal key is always stored at the root of T.<ul><li>easy to locate such an entry when min or removeMin is called</ul></ul></ul></ul><li><strong>structural property</strong>:<ul><li>For the sake of efficiency, <code class="language-plaintext highlighter-rouge">want the heap T to have as small a height as possible</code>.<li>enforce this requirement by insisting that the heap T satisfy an additional structural property; it must be what we term complete.<li><strong>Complete Binary Tree Property</strong>:<ul><li>A <code class="language-plaintext highlighter-rouge">heap T with height h</code> is a complete binary tree if<ul><li>levels <code class="language-plaintext highlighter-rouge">0,1,2,...,h−1</code> of T have the maximal number of nodes possible (level i has 2i nodes, for 0 ≤ i ≤ h − 1)<li>and the remaining nodes at level h reside in the leftmost possible positions at that level.</ul></ul></ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/3SWsjqX.png" alt="Screen Shot 2022-03-31 at 23.57.55" /></p><p>leftmost possible positions,</p><ul><li>level numbering in array-based representation of a binary tree.<li>A complete binary tree with n elements is one that has positions with level numbering 0 through n − 1.<li>For example, in an array-based representation of the above tree, its 13 entries would be stored consecutively <code class="language-plaintext highlighter-rouge">from A[0] to A[12]</code></ul><p><strong>example</strong> a complete binary tree that has the heap order property.</p><p><img data-proofer-ignore data-src="https://i.imgur.com/xWvuclU.png" alt="percUp" /></p><hr /><h4 id="the-height-of-a-heap">The Height of a Heap</h4><p>Proposition 9.2: <strong>A heap T storing n entries has height h = ⌊log n⌋</strong> Justification:</p><ul><li>From the fact that T is complete<li>Let h denote the height of T<li>the number of nodes in <strong>levels 0 through h−1</strong> of T is precisely <code class="language-plaintext highlighter-rouge">1+2+4+···+2^(h−1) = 2^h −1</code>,<li>the number of nodes in <strong>level h</strong> is <code class="language-plaintext highlighter-rouge">at least 1 and at most 2^h</code>.<li>Therefore <code class="language-plaintext highlighter-rouge">n≥2^h−1+1=2^h</code> and <code class="language-plaintext highlighter-rouge">n≤2^h−1+2^h =2^(h+1)−1</code>.<li>By taking the logarithm of both sides of inequality n ≥ 2^h, we see that height <code class="language-plaintext highlighter-rouge">h ≤ log n</code>.<li>By taking the logarithm of both sides of inequality n ≤ 2^(h+1) −1, we see that <code class="language-plaintext highlighter-rouge">h ≥ log(n+1)−1</code>.<li>Since h is an integer, these two inequalities imply that <code class="language-plaintext highlighter-rouge">h = ⌊log n⌋</code>.</ul><p><strong>if we can perform update operations on a heap in time proportional to its height, then those operations will run in logarithmic time.</strong></p><hr /><h2 id="implement-priority-queue">Implement Priority Queue</h2><h3 id="implementing-a-priority-queue-with-a-heap">Implementing a Priority Queue with a Heap</h3><p>to efficiently perform various priority queue methods using a heap.</p><ul><li>use the composition pattern to <code class="language-plaintext highlighter-rouge">store key-value pairs as entries in the heap</code>.<li>The <code class="language-plaintext highlighter-rouge">size</code> and <code class="language-plaintext highlighter-rouge">isEmpty</code> methods can be implemented based on examination of the tree<li>the <code class="language-plaintext highlighter-rouge">min</code> operation is equally trivial because the heap property assures that the element at the root of the tree has a minimal key.<li>The interesting algorithms are the <code class="language-plaintext highlighter-rouge">insert</code> and <code class="language-plaintext highlighter-rouge">removeMin</code> methods.</ul><p><strong>Adding an Entry to the Heap</strong></p><ul><li>to perform <code class="language-plaintext highlighter-rouge">insert(k, v)</code> on a priority queue implemented with a heap T .<li>store the pair (k, v) as an entry at a new node of the tree.<li>To maintain the complete binary tree property<ul><li>new node should be placed at a position p just beyond the <code class="language-plaintext highlighter-rouge">rightmost node at the bottom level of the tree</code>, or as the <code class="language-plaintext highlighter-rouge">leftmost position of a new level</code> (if the bottom level is already full or if the heap is empty).</ul></ul><p><strong>Up-Heap Bubbling After an Insertion</strong></p><ul><li>After this action, the tree T is complete<li>but it may violate the <strong>heap-order property</strong>.<li>Hence, unless position p is the root of T (the priority queue was empty before the insertion), we compare the key at position p to that of p’s parent, which we denote as q.<li>If key <code class="language-plaintext highlighter-rouge">kp ≥ kq</code>, the heap-order property is satisfied and the algorithm terminates.<li>If instead <code class="language-plaintext highlighter-rouge">kp &lt; kq</code><ul><li>then we need to restore the heap-order property, which can be locally achieved by <code class="language-plaintext highlighter-rouge">swapping the entries stored at positions p and q</code>.<li>This swap causes the new entry to move up one level.<li>Again, the heap-order property may be violated, so we repeat the process,<li>going up in T until no violation of the heap-order property occurs.</ul><li>The upward movement of the newly inserted entry by means of swaps is conventionally called <strong>up-heap bubbling</strong>.<li>A swap either resolves the violation of the heap-order property or propagates it one level up in the heap.<li>In the worst case, up-heap bubbling causes the <code class="language-plaintext highlighter-rouge">new entry to move all the way up to the root of heap T</code> .<ul><li>Thus the number of swaps performed in insert == the height of T, that bound is <code class="language-plaintext highlighter-rouge">⌊log n⌋</code>.</ul></ul><p><strong>Removing the Entry with Minimal Key</strong></p><ul><li>to method removeMin of the priority queue ADT.<li>an entry with the smallest key is stored at the root r of T (even if there is more than one entry with smallest key).<ul><li>However, cannot simply delete node r,<li>because this would leave two disconnected subtrees.</ul><li>to ensure that the shape of the heap respects the complete binary tree property<ul><li>deleting the leaf at the last position p of T (the rightmost position at the bottommost level of the tree).<li>To preserve the entry from the <code class="language-plaintext highlighter-rouge">last position p</code>, we copy it to the root r (the entry with minimal key that is being removed by the operation).<li>with minimal entry being removed from the root and replaced by entry from the last position.<li>The node at the last position is removed from the tree.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/cjkPQ2P.png" alt="Screen Shot 2022-04-01 at 09.43.23" /></p><p><strong>Down-Heap Bubbling After a Removal</strong></p><ul><li>even though T is now complete, it likely violates the heap-order property.<li>If T has only one node (the root), then the heap-order property is trivially satisfied and the algorithm terminates.<li>Otherwise, two cases, where p initially denotes the root of T:<ul><li>If p has no right child, let c be the left child of p.<li>Otherwise (p has both children), let c be a child of p with minimal key.<ul><li>If key kp ≤ kc, the heap-order property is satisfied and the algorithm terminates.<li>If instead kp &gt; kc, then we need to restore the heap-order property. This can be locally achieved by swapping the entries stored at p and c.<li>It is worth noting that when p has two children, we intentionally consider the smaller key of the two children.<li>Not only is the key of c smaller than that of p, it is at least as small as the key at c’s sibling.<li>This ensures that the heap-order property is locally restored when that smaller key is promoted above the key that had been at p and that at c’s sibling.</ul></ul><li>Having restored the heap-order property for node p relative to its children, there may be a violation of this property at c;<li>hence, we may have to continue swapping down T until no violation of the heap-order property occurs.<li>This downward swapping process is called <strong>down-heap bubbling</strong>.<li>A swap either resolves the violation of the heap-order property or propagates it one level down in the heap.<li>In the worst case, an entry moves all the way down to the bottom level.<ul><li>the number of swaps performed in removeMin == the height of heap T, <code class="language-plaintext highlighter-rouge">log n⌋</code></ul></ul><hr /><h4 id="complete-binary-tree-array-based">Complete Binary Tree <strong>Array-Based</strong></h4><ul><li>array-based binary tree is especially suitable for a complete binary tree.<li>the elements of the tree are stored in an <code class="language-plaintext highlighter-rouge">array-based list A</code> such that the element at position p is stored in A with index equal to the level number f(p) of p, defined as follows:<ul><li>If p is the root,then f(p)=0.<li>If p is the left child of position q, then f(p) = 2f(q)+1.<li>If p is the right child of position q, then f(p) = 2f(q)+2.</ul><li>For a tree with of size n, the elements have contiguous indices in the range [0, n − 1] and the last position of is always at index n − 1.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/04PxEIi.png" alt="Screen Shot 2022-04-01 at 11.56.09" /></p><p>The <strong>array-based heap representation</strong></p><ul><li>avoids some complexities of a linked tree structure.<ul><li>methods <code class="language-plaintext highlighter-rouge">insert</code> and <code class="language-plaintext highlighter-rouge">removeMin</code> depend on locating the last position of a heap.<li>With the array-based representation of a heap of size n, the last position is simply at index <code class="language-plaintext highlighter-rouge">n − 1</code>.<li>Locating the last position in a heap implemented with a linked tree structure requires more effort.</ul><li>If the size of a priority queue is not known in advance,<ul><li>use of an array-based representation does introduce the need to dynamically resize the array on occasion, done with ArrayList.</ul><li>The space usage of such an array-based representation of a complete binary tree with n nodes is <code class="language-plaintext highlighter-rouge">O(n)</code><li>the time bounds of methods for <code class="language-plaintext highlighter-rouge">adding</code> or <code class="language-plaintext highlighter-rouge">removing</code> elements become amortized</ul><hr /><h4 id="priority-queue-heap-based">priority queue <strong>heap-based</strong></h4><ul><li><p>Java implementation of a heap-based priority queue.</p><li>Although we think of our heap as a binary tree, we do not formally think of our heap as a binary tree, do not formally use the binary tree ADT.<ul><li>prefer to use the more efficient array-based representation of a tree,<li>maintaining a Java <code class="language-plaintext highlighter-rouge">ArrayList</code> of entry composites.<li>To allow us to formalize our algorithms using tree-like terminology of parent, left, and right, the class includes protected utility methods that compute the <strong>level numbering</strong> of a parent or child of another position<li>However, the “positions” in this representation are simply integer indices into the array-list.</ul><li>Our class also has protected utilities swap, upheap, and downheap for the low-level movement of entries within the array-list.<ul><li>A new entry is added the end of the array-list, and then repositioned as needed with <strong>upheap</strong>.<li>To remove the entry with minimal key (which resides at index 0), we move the last entry of the array-list from index n − 1 to index 0, and then invoke <strong>downheap</strong> to reposition it.</ul></ul><hr /><h5 id="heap-in-java">heap in java</h5><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">pq</span><span class="o">;</span>

<span class="cm">/** An implementation of a priority queue using an array-based heap. */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HeapPriorityQueue</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractPriorityQueue</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="cm">/** primary collection of priority queue entries */</span>
    <span class="kd">protected</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">heap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="cm">/** Creates an empty priority queue based on the natural ordering of its keys. */</span>
    <span class="kd">public</span> <span class="nf">HeapPriorityQueue</span><span class="o">()</span> <span class="o">{</span> <span class="kd">super</span><span class="o">();</span> <span class="o">}</span>
    <span class="cm">/** Creates an empty priority queue using the given comparator to order keys. */</span>
    <span class="kd">public</span> <span class="nf">HeapPriorityQueue</span><span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="n">comp</span><span class="o">)</span> <span class="o">{</span> <span class="kd">super</span><span class="o">(</span><span class="n">comp</span><span class="o">);</span> <span class="o">}</span>

    <span class="c1">// protected utilities</span>
    <span class="kd">protected</span> <span class="kt">int</span> <span class="nf">parent</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="o">}</span> <span class="c1">// truncating division</span>
    <span class="kd">protected</span> <span class="kt">int</span> <span class="nf">left</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">protected</span> <span class="kt">int</span> <span class="nf">right</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">hasLeft</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">left</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">}</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">hasRight</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">right</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">}</span>

    <span class="cm">/** Exchanges the entries at indices i and j of the array list. */</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="n">heap</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
        <span class="n">heap</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">temp</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/** Moves the entry at index j higher, if necessary, to restore the heap property. */</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">upheap</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// continue until reaching root (or break statement)</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compare</span><span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">),</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span> <span class="c1">// heap property verified</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">p</span><span class="o">);</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// continue from the parent's location</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/** Moves the entry at index j lower, if necessary, to restore the heap property. */</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">downheap</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">hasLeft</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// continue to bottom (or break statement)</span>
            <span class="kt">int</span> <span class="n">leftIndex</span> <span class="o">=</span> <span class="n">left</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">smallChildIndex</span> <span class="o">=</span> <span class="n">leftIndex</span><span class="o">;</span>  <span class="c1">// although right may be smaller</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">hasRight</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">rightIndex</span> <span class="o">=</span> <span class="n">right</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">compare</span><span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">leftIndex</span><span class="o">),</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">rightIndex</span><span class="o">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">smallChildIndex</span> <span class="o">=</span> <span class="n">rightIndex</span><span class="o">;</span> <span class="c1">// right child is smaller</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compare</span><span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">smallChildIndex</span><span class="o">),</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span> <span class="c1">// heap property has been restored</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">smallChildIndex</span><span class="o">);</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">smallChildIndex</span><span class="o">;</span>  <span class="c1">// continue at position of the child</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// public methods</span>
    <span class="cm">/** Returns the number of items in the priority queue. */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(</span> <span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">(</span> <span class="o">);</span> <span class="o">}</span>
    <span class="cm">/** Returns (but does not remove) an entry with minimal key (if any). */</span>
    <span class="kd">public</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">min</span><span class="o">(</span> <span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/** Inserts a key-value pair and returns the entry created. */</span>
    <span class="kd">public</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">insert</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span> <span class="o">{</span>
        <span class="n">checkKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span> <span class="c1">// auxiliary key-checking method (could throw exception)</span>
        <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">newest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PQEntry</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="n">heap</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newest</span><span class="o">);</span> <span class="c1">// add to the end of the list</span>
        <span class="n">upheap</span><span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// upheap newly added entry</span>
        <span class="k">return</span> <span class="n">newest</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/** Removes and returns an entry with minimal key (if any). */</span>
    <span class="kd">public</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">removeMin</span><span class="o">(</span> <span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="n">swap</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// put minimum item at the end</span>
        <span class="n">heap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// and remove it from the list;</span>
        <span class="n">downheap</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// then fix new root</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><hr /><h6 id="analyze-the-binary-heap">analyze the binary heap</h6><ul><li>assuming that<ul><li>two keys can be compared in O(1) time<li>and the heap T is implemented with an array-based or linked-based tree representation.</ul></ul><p>In short, each of the priority queue ADT methods can be performed in O(1) or in O(logn) time, where n is the number of entries at the time the method is executed.</p><p>The analysis of the running time of the methods is based on the following:</p><ul><li>The heap T has n nodes, each storing a reference to a key-value entry.<li>The <code class="language-plaintext highlighter-rouge">height of heap T is O(log n)</code>, since T is complete<li>The <strong>min</strong> operation runs in <code class="language-plaintext highlighter-rouge">O(1)</code>: the root of the tree contains such an element.<li>for <strong>insert</strong> and <strong>removeMin</strong>: Locating the last position of a heap can be performed in <code class="language-plaintext highlighter-rouge">O(1)</code> time for an array-based representation, or <code class="language-plaintext highlighter-rouge">O(log n)</code> time for a linked-tree representation<li><p>In the worst case, <strong>up-heap and down-heap bubbling</strong> perform a number of swaps equal to the height of T <code class="language-plaintext highlighter-rouge">O(log n)</code></p><li>size, isEmpty, min: <code class="language-plaintext highlighter-rouge">𝑂(1)</code><li>insert: <code class="language-plaintext highlighter-rouge">𝑂(log𝑛)</code><li>removeMin: <code class="language-plaintext highlighter-rouge">𝑂(log𝑛)</code><li>up-heap and down-heap bubbling: <code class="language-plaintext highlighter-rouge">𝑂(log𝑛)</code></ul><hr /><hr /><h5 id="max-heap-in-java">max heap in java</h5><p><code class="language-plaintext highlighter-rouge">swim(int k)</code></p><p><img data-proofer-ignore data-src="https://i.imgur.com/ITg3gBR.gif" alt="swim" /></p><p><code class="language-plaintext highlighter-rouge">sink(int k)</code></p><p><img data-proofer-ignore data-src="https://i.imgur.com/1yOPINm.gif" alt="sink" /></p><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxPQ</span>
    <span class="o">&lt;</span><span class="nc">Key</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;&gt;</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Key</span><span class="o">[]</span> <span class="n">pq</span><span class="o">;</span>    <span class="c1">// 存储元素的数组</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   <span class="c1">// 当前 Priority Queue 中的元素个数</span>

    <span class="kd">public</span> <span class="nf">MaxPQ</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 索引 0 不用，所以多分配一个空间</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Key</span><span class="o">[])</span> <span class="k">new</span> <span class="nc">Comparable</span><span class="o">[</span><span class="n">cap</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="cm">/* 返回当前队列中最大元素 */</span>
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">max</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">pq</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="c1">// /* 插入元素 e */ 插入和删除元素的时间复杂度为 O(logK)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="nc">Key</span> <span class="n">e</span><span class="o">)</span>
      <span class="no">N</span><span class="o">++;</span>
      <span class="c1">// 先把新元素加到最后</span>
      <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
      <span class="c1">// 然后让它上浮到正确的位置</span>
      <span class="n">swim</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// /* 删除并返回当前队列中最大元素 */ 插入和删除元素的时间复杂度为 O(logK)</span>
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">delMax</span><span class="o">()</span> <span class="o">{</span>
      <span class="c1">// 最大堆的堆顶就是最大元素</span>
      <span class="nc">Key</span> <span class="n">max</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
      <span class="c1">// 把这个最大元素换到最后，删除之</span>
      <span class="n">exch</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="no">N</span><span class="o">);</span>
      <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="no">N</span><span class="o">--;</span>
      <span class="c1">// 让 pq[1] 下沉到正确位置</span>
      <span class="n">sink</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 上浮第 k 个元素，以维护最大堆性质 */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swim</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 如果浮到堆顶，就不能再上浮了</span>
      <span class="k">while</span><span class="o">(</span><span class="n">k</span><span class="o">&gt;</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">parent</span><span class="o">(</span><span class="n">k</span><span class="o">),</span> <span class="n">k</span><span class="o">)){</span>
        <span class="c1">// 如果第 k 个元素比上层大</span>
        <span class="c1">// 将 k 换上去</span>
        <span class="n">exch</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">parent</span><span class="o">(</span><span class="n">k</span><span class="o">));</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">parent</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* 下沉第 k 个元素，以维护最大堆性质 */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">sink</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 如果沉到堆底，就沉不下去了</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 先假设左边节点较大</span>
            <span class="kt">int</span> <span class="n">older</span> <span class="o">=</span> <span class="n">left</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
            <span class="c1">// 如果右边节点存在，比一下大小</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">right</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">older</span><span class="o">,</span> <span class="n">right</span><span class="o">(</span><span class="n">k</span><span class="o">)))</span>
                <span class="n">older</span> <span class="o">=</span> <span class="n">right</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
            <span class="c1">// 结点 k 比俩孩子都大，就不必下沉了</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">less</span><span class="o">(</span><span class="n">older</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span> <span class="k">break</span><span class="o">;</span>
            <span class="c1">// 否则，不符合最大堆的结构，下沉 k 结点</span>
            <span class="n">exch</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">older</span><span class="o">);</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">older</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* 交换数组的两个元素 */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">exch</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Key</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="n">pq</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* pq[i] 是否比 pq[j] 小？ */</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">less</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">compareTo</span><span class="o">(</span><span class="n">pq</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* 还有 left, right, parent 三个方法 */</span>



<span class="o">}</span>


</pre></table></code></div></div><hr /><p>heap in python</p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1"># an empty binary heap has a single zero as the first element of heapList and that this zero is not used, but is there so that simple integer division can be used in later methods.
</span><span class="k">class</span> <span class="nc">BinHeap</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">heapList</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="mi">0</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">insert</code></p><ul><li>most efficient way to add an item to a list is to simply append the item to the end of the list.<li>The good news about appending is that it guarantees that we will maintain the complete tree property.<li>The bad news about appending is that we will very likely violate the heap structure property.<li>However, it is possible to write a method to regain the <strong>heap structure property</strong> by comparing the newly added item with its parent.<ul><li>If the newly added item is less than its parent, then we can swap the item with its parent.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/xWvuclU.png" alt="percUp" /></p><p>when we percolate 扩散 an item up</p><ul><li>we are restoring the heap property between the newly added item and the parent.<li>We are also preserving the heap property for any siblings.<li>Of course, if the newly added item is very small, we may still need to swap it up another level.<li>In fact, we may need to keep swapping until we get to the top of the tree.</ul><p><code class="language-plaintext highlighter-rouge">percUp</code></p><ul><li>percolates a new item as far up in the tree as it needs to go to maintain the heap property.<li>Here is where our wasted element in heapList is important.<li>Notice that we can compute the parent of any node by using simple integer division.<li>The parent of the current node can be computed by dividing the index of the current node by 2.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">percUp</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]:</span>
         <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
         <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
         <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
    <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">self</span><span class="p">.</span><span class="nf">percUp</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">currentSize</span><span class="p">)</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">delMin</code></p><blockquote><p>to keep complete binary tree, replace the last item with the root</p></blockquote><ul><li>Since the heap property requires that the root of the tree be the smallest item in the tree, finding the minimum item is easy.<li>The hard part of delMin is restoring full compliance with the heap structure and heap order properties after the root has been removed.</ul><p>restore our heap in two steps.</p><ul><li>First, restore the root item by taking the last item in the list and moving it to the root position.<ul><li>It maintains our heap structure property.<li>But we have probably destroyed the heap order property of our binary heap.</ul><li>Second, restore the heap order property by pushing the new root node down the tree to its proper position.<ul><li>to maintain the heap order property,<li>swap the root with its smallest child less than the root.<li>After the initial swap, we may repeat the swapping process with a <code class="language-plaintext highlighter-rouge">node</code> and <code class="language-plaintext highlighter-rouge">its children</code> until the node is swapped into a position on the tree where it is already less than both children.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/I1kHltA.png" alt="percDown" /></p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">percDown</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
    <span class="nf">while </span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span><span class="p">:</span>
        <span class="n">mc</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">minChild</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">mc</span><span class="p">]:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">mc</span><span class="p">]</span>
            <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">mc</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">mc</span>

<span class="k">def</span> <span class="nf">minChild</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="c1"># i * 2 + 1 &lt;= self.currentSize
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">delMin</code></p><ul><li>the hard work is handled by a helper function, in this case percDown.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">delMin</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">currentSize</span><span class="p">]</span>
    <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
    <span class="n">self</span><span class="p">.</span><span class="nf">percDown</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">retval</span>
</pre></table></code></div></div><p>build an entire heap from a list of keys.</p><p>build a heap by inserting each key one at a time.</p><ul><li>a list of one item, the list is sorted<li>use binary search to find the right position to insert the next key at a cost of approximately <code class="language-plaintext highlighter-rouge">𝑂(log𝑛)</code> operations.<li>However, inserting an item in the middle of the list may require <code class="language-plaintext highlighter-rouge">𝑂(𝑛)</code> operations to shift the rest of the list over to make room for the new key.<li>Therefore, to insert <code class="language-plaintext highlighter-rouge">𝑛</code> keys into the heap would require a total of <code class="language-plaintext highlighter-rouge">𝑂(𝑛log𝑛)</code> operations.</ul><p>if we start with an entire list then we can build the whole heap in <code class="language-plaintext highlighter-rouge">𝑂(𝑛)</code> operations.</p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">buildHeap</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">alist</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
    <span class="n">self</span><span class="p">.</span><span class="n">heapList</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">alist</span><span class="p">[:]</span>
    <span class="nf">while </span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">percDown</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="https://i.imgur.com/KjU539s.png" alt="buildheap" /></p><p><code class="language-plaintext highlighter-rouge">percDown</code> method ensures that the largest child is always moved down the tree.</p><ul><li>Because the heap is a complete binary tree, any nodes past the halfway point will be leaves and therefore have no children.<li>when <code class="language-plaintext highlighter-rouge">i=1</code>, we are percolating down from the root of the tree, so this may require multiple swaps.</ul><p>As you can see in the rightmost two trees of Figure 4,</p><ul><li>first the 9 is moved out of the root position,<li>but after 9 is moved down one level in the tree,<li>percDown ensures that we check the next set of children farther down in the tree to ensure that it is pushed as low as it can go.<li>In this case it results in a second swap with 3. Now that 9 has been moved to the lowest level of the tree, no further swapping can be done.<li>It is useful to compare the list representation of this series of swaps as shown in Figure 4 with the tree representation.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
</pre></table></code></div></div><p>The assertion that we can build the heap in <code class="language-plaintext highlighter-rouge">𝑂(𝑛)</code> is beyond the scope of this book. However, the key to understanding that you can build the heap in <code class="language-plaintext highlighter-rouge">𝑂(𝑛)</code> is to remember that the <code class="language-plaintext highlighter-rouge">log𝑛</code> factor is derived from the height of the tree.</p><p>For most of the work in buildHeap, the tree is shorter than <code class="language-plaintext highlighter-rouge">log𝑛</code></p><p>Using the fact that you can build a heap from a list in <code class="language-plaintext highlighter-rouge">𝑂(𝑛)</code> time, you will construct a sorting algorithm that uses a heap and sorts a list in <code class="language-plaintext highlighter-rouge">𝑂(𝑛log𝑛))</code> as an exercise at the end of this chapter.</p><hr /><h6 id="min-heap-in-python">min heap in python</h6><ul><li><code class="language-plaintext highlighter-rouge">BinaryHeap()</code><ul><li>creates a new, empty, binary heap.</ul><li><code class="language-plaintext highlighter-rouge">insert(k)</code><ul><li>adds a new item to the heap.</ul><li><code class="language-plaintext highlighter-rouge">findMin()</code><ul><li>returns the item with the minimum key value, leaving item in the heap.</ul><li><code class="language-plaintext highlighter-rouge">delMin()</code><ul><li>returns the item with the minimum key value, removing the item from the heap.</ul><li><code class="language-plaintext highlighter-rouge">isEmpty()</code><ul><li>returns true if the heap is empty, false otherwise.</ul><li><code class="language-plaintext highlighter-rouge">size()</code><ul><li>returns the number of items in the heap.</ul><li><code class="language-plaintext highlighter-rouge">buildHeap(list)</code><ul><li>builds a new heap from a list of keys.</ul></ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">pythonds.trees</span> <span class="kn">import</span> <span class="n">BinHeap</span>

<span class="k">class</span> <span class="nc">BinHeap</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">heapList</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">percUp</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]:</span>
             <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
             <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
             <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
      <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
      <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">self</span><span class="p">.</span><span class="nf">percUp</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">currentSize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">percDown</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
      <span class="nf">while </span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span><span class="p">:</span>
          <span class="n">mc</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">minChild</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">mc</span><span class="p">]:</span>
              <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
              <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">mc</span><span class="p">]</span>
              <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">mc</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">mc</span>

    <span class="k">def</span> <span class="nf">minChild</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
              <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">delMin</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
      <span class="n">retval</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">currentSize</span><span class="p">]</span>
      <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="n">self</span><span class="p">.</span><span class="n">heapList</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
      <span class="n">self</span><span class="p">.</span><span class="nf">percDown</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">retval</span>

    <span class="k">def</span> <span class="nf">buildHeap</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">alist</span><span class="p">):</span>
      <span class="n">i</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
      <span class="n">self</span><span class="p">.</span><span class="n">currentSize</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
      <span class="n">self</span><span class="p">.</span><span class="n">heapList</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">alist</span><span class="p">[:]</span>
      <span class="nf">while </span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
          <span class="n">self</span><span class="p">.</span><span class="nf">percDown</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">bh</span> <span class="o">=</span> <span class="nc">BinHeap</span><span class="p">()</span>
<span class="n">bh</span><span class="p">.</span><span class="nf">buildHeap</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>

<span class="nf">print</span><span class="p">(</span><span class="n">bh</span><span class="p">.</span><span class="nf">delMin</span><span class="p">())</span>
<span class="nf">print</span><span class="p">(</span><span class="n">bh</span><span class="p">.</span><span class="nf">delMin</span><span class="p">())</span>
<span class="nf">print</span><span class="p">(</span><span class="n">bh</span><span class="p">.</span><span class="nf">delMin</span><span class="p">())</span>
<span class="nf">print</span><span class="p">(</span><span class="n">bh</span><span class="p">.</span><span class="nf">delMin</span><span class="p">())</span>
<span class="nf">print</span><span class="p">(</span><span class="n">bh</span><span class="p">.</span><span class="nf">delMin</span><span class="p">())</span>
</pre></table></code></div></div><p>Notice that no matter the order that we add items to the heap, the smallest is removed each time.</p><hr /><h3 id="bottom-up-heap-construction">Bottom-Up Heap Construction</h3><ul><li>If we start with an initially empty heap, n successive calls to the insert operation will run in <code class="language-plaintext highlighter-rouge">O(nlogn)</code> time in the worst case.<li>However, if <code class="language-plaintext highlighter-rouge">all n key-value pairs to be stored in the heap are given in advance</code>, such as during the first phase of the heap-sort algorithm, there is an alternative bottom-up construction method that runs in <code class="language-plaintext highlighter-rouge">O(n)</code> time.</ul><p>In this section, we describe the bottom-up heap construction, and provide an implementation that can be used by the constructor of a heap-based priority queue.</p><p>For simplicity of exposition, we describe this bottom-up heap construction assuming</p><ul><li>the number of keys, n, is an integer that <code class="language-plaintext highlighter-rouge">n = 2^(h+1) − 1</code><ul><li>the heap is a complete binary tree with every level being full,</ul><li>so the heap has height <code class="language-plaintext highlighter-rouge">h = log(n + 1) − 1</code>.<li>Viewed non recursively, bottom-up heap construction consists of the following <code class="language-plaintext highlighter-rouge">h + 1 = log(n + 1)</code> steps:</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/nJevOoi.png" alt="Screen Shot 2022-04-01 at 13.20.09" /></p><ol><li>construct <code class="language-plaintext highlighter-rouge">(n + 1)/2</code> elementary heaps storing one entry each.<li>form <code class="language-plaintext highlighter-rouge">(n+1)/4</code> heaps, each storing three entries, by joining pairs of elementary heaps and adding a new entry.<ol><li>The new entry is placed at the root and may have to be swapped with the entry stored at a child to preserve the heap-order property.</ol><li>form <code class="language-plaintext highlighter-rouge">(n + 1)/8</code> heaps, each storing 7 entries, by joining pairs of 3-entry heaps (constructed in the previous step) and adding a new entry. The new entry is placed initially at the root, but may have to move down with a down-heap bubbling to preserve the heap-order property.<li>In the generic i^th step, 2 ≤ i ≤ h, we form <code class="language-plaintext highlighter-rouge">(n+1)/2^i</code> heaps, each storing 2i −1 entries, by joining pairs of heaps storing (2i−1 − 1) entries (constructed in the previous step) and adding a new entry. The new entry is placed initially at the root, but may have to move down with a down-heap bubbling to preserve the heap-order property.<li>In the last ste, form the final heap,<ol><li>storing all the n entries, by joining two heaps storing <code class="language-plaintext highlighter-rouge">(n − 1)/2</code> entries (constructed in the previous step)<li>and adding a new entry.<li>The new entry is placed initially at the root, but may have to move down with a down-heap bubbling to preserve the heap-order property.</ol></ol><hr /><h4 id="implementation-in-java">Implementation in Java</h4><p>Implementing a bottom-up heap construction is quite easy, given the existence of a “down-heap” utility method.</p><ul><li>The “merging” of two equally sized heaps that are subtrees of a common position p can be accomplished simply by down-heaping p’s entry.<ul><li>For example, that is what happened to the key 14 in going from Figure 9.5(f ) to (g).</ul><li>With our array-based representation of a heap<ul><li>if we initially store all n entries in arbitrary order within the array,<li>we can implement the bottom-up heap construction process with a single loop that makes a call to downheap from each position of the tree, as long as those calls are ordered starting with the deepest level and ending with the root of the tree.</ul><li><p>In fact, that loop can start with the deepest internal position, since there is no effect when down-heap is called at an external position.</p><li>augment the original HeapPriorityQueue class to provide support for the <strong>bottom-up construction</strong> of an initial collection.<li>a nonpublic utility method, <code class="language-plaintext highlighter-rouge">heapify</code>, that calls downheap on each nonleaf position, beginning with the deepest and concluding with a call at the root of the tree.<li>an additional constructor for the class that accepts an initial sequence of keys and values, parameterized as two coordinate arrays that are presumed to have the same length.<ul><li>create new entries,<li>pairing the first key with the first value, the second key with the second value, and so on.<li>then call the heapify utility to establish the heap ordering.</ul><li>For brevity, we omit a similar constructor that accepts a nondefault comparator for the priority queue.</ul><h5 id="asymptotic-analysis-of-bottom-up-heap-construction">Asymptotic Analysis of Bottom-Up Heap Construction</h5><ul><li><code class="language-plaintext highlighter-rouge">Bottom-up heap construction</code> is <strong>asymptotically faster</strong> than incrementally inserting n entries into an initially empty heap.<li>it performing a single down-heap operation at each position in the tree, rather than a single up-heap operation from each.<li>Since more nodes are closer to the bottom of a tree than the top, the sum of the downward paths is linear</ul><p><strong>Proposition 9.3</strong>:</p><ul><li>Bottom-up construction of a heap with n entries takes O(n) time, assuming two keys can be compared in O(1) time. <strong>Justification</strong>:<li>The primary cost of the construction is due to the <strong>down-heap steps</strong> performed at <code class="language-plaintext highlighter-rouge">each nonleaf position</code>.<li>Let <code class="language-plaintext highlighter-rouge">πv</code> denote the path of T from nonleaf node v to its “inorder successor” leaf<ul><li>the path that starts at v, goes to the right child of v, and then goes down leftward until it reaches a leaf.</ul><li>Although, <code class="language-plaintext highlighter-rouge">πv</code> is not necessarily the path followed by the down-heap bubbling step from v, its number of edges <code class="language-plaintext highlighter-rouge">∥πv∥</code> is proportional to the height of the subtree rooted at v, and thus a bound on the complexity of the down-heap operation at v.<li>The total running time of the bottom-up heap construction algorithm is therefore bounded by the <code class="language-plaintext highlighter-rouge">sum ∑v ∥πv∥</code>.<li><p>For intuition, Figure 9.6 illustrates the justification “visually,” marking each edge with the label of the nonleaf node v whose path <code class="language-plaintext highlighter-rouge">πv</code> contains that edge.</p><li>We claim that the paths <code class="language-plaintext highlighter-rouge">πv</code> for all nonleaf v are edge-disjoint, and thus the sum of the path lengths is bounded by the number of total edges in the tree, hence O(n). To show this, we consider what we term “right-leaning” and “left-leaning” edges (i.e., those going from a parent to a right, respectively left, child). A particular right- leaning edge e can only be part of the path <code class="language-plaintext highlighter-rouge">πv</code> for node v that is the parent in the relationship represented by e. Left-leaning edges can be partitioned by considering the leaf that is reached if continuing down leftward until reaching a leaf. Each nonleaf node only uses left-leaning edges in the group leading to that nonleaf node’s inorder successor. Since each nonleaf node must have a different inorder successor, no two such paths can contain the same left-leaning edge.<li>We conclude that the bottom-up construction of heap T takes <code class="language-plaintext highlighter-rouge">O(n)</code> time.</ul><hr /><h3 id="javautilpriorityqueue-class">java.util.PriorityQueue <strong>Class</strong></h3><p>There is no priority queue interface built into Java, but Java does include a <strong>class</strong>, <code class="language-plaintext highlighter-rouge">java.util.PriorityQueue</code>, which implements the <code class="language-plaintext highlighter-rouge">java.util.Queue</code> <strong>interface</strong>.</p><ul><li>Instead of adding and removing elements according to the standard FIFO policy used by most queues<li><code class="language-plaintext highlighter-rouge">java.util.PriorityQueue</code> <strong>class</strong> processes its entries according to a priority<ul><li>The “front” of the queue will always be a minimal element<li>with priorities based either on the natural ordering of the elements, or in accordance with a <code class="language-plaintext highlighter-rouge">comparator</code> <strong>object</strong> sent as a parameter when constructing the priority queue.<li>java.util.PriorityQueue class relies on a single element type. That element is effectively treated as a key.<li>If a user wishes to insert distinct keys and values, the burden is on the user to define and insert appropriate composite objects, and to ensure that those objects can be compared based on their keys.</ul><li>The java.util.PriorityQueue class is implemented with a heap<ul><li>so it guarantees <code class="language-plaintext highlighter-rouge">O(logn)</code> time performance for methods <code class="language-plaintext highlighter-rouge">add</code> and <code class="language-plaintext highlighter-rouge">remove</code>,<li>and <code class="language-plaintext highlighter-rouge">O(1)</code> constant-time performance for accessors <code class="language-plaintext highlighter-rouge">peek</code>, <code class="language-plaintext highlighter-rouge">size</code>, and <code class="language-plaintext highlighter-rouge">isEmpty</code>.<li>In addition, it provides a parameterized method, <code class="language-plaintext highlighter-rouge">remove(e)</code> that removes a specific element e from the priority queue runs in <code class="language-plaintext highlighter-rouge">O(n)</code> time, performing a sequential search to locate the element within the heap.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/IJfWqbT.png" alt="Screen Shot 2022-04-08 at 01.02.45" /></p><hr /><h2 id="sorting-with-a-priority-queue">Sorting with a Priority Queue</h2><p>The algorithm for sorting a <code class="language-plaintext highlighter-rouge">sequence S</code> with a <code class="language-plaintext highlighter-rouge">priority queue P</code> is quite simple and consists of the following two phases:</p><ol><li>insert the elements of <code class="language-plaintext highlighter-rouge">S</code> as keys into an initially empty <code class="language-plaintext highlighter-rouge">priority queue P</code> by means of a series of n insert operations, one for each element.<li>extract the elements from P in nondecreasing order by means of a series of n removeMin operations, putting them back into S in that order.</ol><p>The algorithm works correctly for any priority queue P, no matter how P is implemented.</p><ul><li>but the running time of the algorithm is determined by running times of operations insert and removeMin, which do depend on how P is implemented.<li>Indeed, pqSort should be considered more a sorting “scheme” than a sorting “algorithm,” because it does not specify how the priority queue P is implemented.<li>The pqSort scheme is the paradigm of several popular sorting algorithms, including selection-sort, insertion-sort, and heap-sort.</ul><hr /><h3 id="selection-sort">Selection-Sort</h3><p><img data-proofer-ignore data-src="https://i.imgur.com/Ortlmyb.png" alt="Screen Shot 2022-04-08 at 01.17.26" /></p><blockquote><p>If we implement P with an unsorted list</p></blockquote><ul><li>In Phase 1 of the pqSort scheme, we insert all elements into a priority queue P;<ul><li>takes <code class="language-plaintext highlighter-rouge">O(n)</code> time, insert each element in O(1) time.</ul><li>in Phase 2 we repeatedly <code class="language-plaintext highlighter-rouge">remove the minimal element from P</code> using the <strong>removeMin</strong> method.<ul><li>the running time of each <strong>removeMin</strong> operation is proportional to the size of P.<ul><li>the bottleneck computation is the <font color="red"> repeated “selection” of the minimum element in Phase 2. </font><li>For this reason, this algorithm is better known as <strong>selection-sort</strong><li>the bottleneck is in Phase 2: <code class="language-plaintext highlighter-rouge">repeatedly remove an entry with smallest key from the priority queue P</code>.<ul><li>The size of P starts at n and incrementally decreases with each removeMin until it becomes 0.<li>Thus, the first removeMin operation takes time O(n),<li>the second one takes time O(n − 1), and so on,<li>until the last (nth) operation takes time O(1).<li>Therefore, the total time needed for the second phase is <code class="language-plaintext highlighter-rouge">􏰎∑n 􏰏 O(n+(n−1)+···+2+1)</code><li>∑ni=1 i = n(n + 1)/2.</ul><li>Phase 2 takes time<code class="language-plaintext highlighter-rouge"> O(n^2)</code>, as does the entire selection-sort algorithm.</ul></ul></ul><hr /><h3 id="insertion-sort">Insertion-Sort</h3><blockquote><p>implement the priority queue P using a sorted list</p></blockquote><ul><li>then the running time of Phase 2 improves to O(n), for each operation removeMin on P now takes O(1) time.<li>Unfortunately, Phase 1 now becomes the bottleneck for the running time,<ul><li>in the worst case, each insert operation takes time proportional to the size of P.<li>This sorting algorithm is therefore better known as <strong>insertion-sort</strong><li>for the bottleneck in this sorting algorithm involves the <font color="red"> repeated “insertion” of a new element at the appropriate position in a sorted list </font>.</ul><li><p>In Phase 1, we repeatedly remove the first element of S and insert it into P.</p><li><p>In Phase 2, we repeatedly perform the removeMin operation on P and add the returned element to the end of S.</p><li>Analyzing the running time of Phase 1 of insertion-sort, we note that it is <code class="language-plaintext highlighter-rouge">􏰎∑n 􏰏 O(1+2+...+(n−1)+n)</code><li><p>Phase 1 runs in <code class="language-plaintext highlighter-rouge">O(n^2)</code> time, and hence, so does the entire insertion-sort algorithm.</p><li>Alternatively, we could change our definition of insertion-sort so that we <code class="language-plaintext highlighter-rouge">insert elements starting from the end of the priority-queue list</code> in Phase 1, in which case performing insertion-sort on a sequence that is already sorted would run in O(n) time.<li>Indeed, the running time of insertion-sort in this case is <code class="language-plaintext highlighter-rouge">O(n+I)</code>, where I is the number of inversions in the sequence, that is, the number of pairs of elements that start out in the input sequence in the wrong relative order.</ul><hr /><h3 id="heap-sort">Heap-Sort</h3><ul><li>priority queue with heap: all the methods in the priority queue ADT run in logarithmic time or better.<ul><li>Hence, this realization is suitable for applications where fast running times are sought for all the priority queue methods.</ul></ul><p>consider the pqSort scheme using a heap-based implementation of the priority queue.</p><ul><li>During Phase 1, <code class="language-plaintext highlighter-rouge">O(n log n)</code> time.<ul><li>since the heap has i entries after the operation is performed, the i th <strong>insert</strong> operation takes <code class="language-plaintext highlighter-rouge">O(log i)</code> time.<li>It could be improved to O(n) with the bottom-up heap construction</ul><li>During the second phase of method pqSort<ul><li>the j th <strong>removeMin</strong> operation runs in <code class="language-plaintext highlighter-rouge">O(log(n − j + 1))</code>, since the heap has <code class="language-plaintext highlighter-rouge">n − j + 1</code> entries at the time the operation is performed.<li>Summing over all j, this phase takes <code class="language-plaintext highlighter-rouge">O(nlogn)</code> time,<li>so the entire priority-queue sorting algorithm runs in <code class="language-plaintext highlighter-rouge">O(nlogn)</code> time when we use a heap to implement the priority queue.</ul><li>This sorting algorithm is better known as <strong>heap-sort</strong></ul><p><strong>Proposition 9.4</strong>:</p><ul><li>The heap-sort algorithm sorts a sequence S of n elements in O(n log n) time, assuming two elements of S can be compared in O(1) time.<li>the O(n log n) running time of heap-sort is considerably better than the O(n^2) selection-sort and insertion-sort.</ul><hr /><h3 id="implementing-heap-sort-in-place">Implementing Heap-Sort In-Place</h3><ul><li>If the <code class="language-plaintext highlighter-rouge">sequence S</code> to be sorted is implemented by means of an array-based sequence, such as an ArrayList in Java, we can speed up heap-sort and reduce its space requirement by a constant factor by using a portion of the array itself to store the heap, thus avoiding the use of an auxiliary heap data structure.</ul><p>This is accomplished by modifying the algorithm as follows:</p><ol><li>redefine the heap operations to be a maximum-oriented heap<ol><li>each position key &gt;= its children.<li>This can be done by recoding the algorithm/providing a new comparator that reverses the outcome of each comparison.<li>At any time during the execution of the algorithm,<ol><li>we use the left portion of <code class="language-plaintext highlighter-rouge">S</code>, up to a certain index i − 1, to store the <code class="language-plaintext highlighter-rouge">entries of the heap</code>,<li>and the right portion of <code class="language-plaintext highlighter-rouge">S</code>, from index i to n − 1, to store the <code class="language-plaintext highlighter-rouge">elements of the sequence</code>.</ol><li>Thus, the first i elements of S (at indices 0,…,i−1) provide the array-list representation of the heap.</ol></ol><p>Implementing</p><ol><li>In the first phase of the algorithm, we start with an empty heap and move the boundary between the heap and the sequence from left to right, one step at a time.<ol><li>In step i, for i = 1,…,n, we expand the heap by adding the element at index i − 1.</ol><li>In the second phase of the algorithm, we start with an empty sequence and move the boundary between the heap and the sequence from right to left, one step at a time.<ol><li>At step i, for i = 1,…,n, we remove a maximal element from the heap and store it at index n − i.</ol></ol><p>In general, we say that a sorting algorithm is <strong>in-place</strong> if it uses only a <code class="language-plaintext highlighter-rouge">small amount of memory</code> in addition to the sequence storing the objects to be sorted.</p><ul><li>The variation of heap-sort above qualifies as in-place;<li>instead of transferring elements out of the sequence and then back in, we simply rearrange them.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/pXjmBUs.png" alt="Screen Shot 2022-04-08 at 01.51.31" /></p><hr /><h2 id="adaptable-priority-queues">Adaptable Priority Queues</h2><p>The methods of the priority queue ADT are sufficient for most basic applications of priority queues, such as sorting. However, there are situations in which additional methods would be useful</p><p>Example: the standby airline passenger application.</p><ul><li>A standby passenger with a pessimistic attitude may become tired of waiting and decide to leave ahead of the boarding time, requesting to be removed from the waiting list.<ul><li>Thus, we would like to remove from the priority queue the entry associated with this passenger.<li>Operation <code class="language-plaintext highlighter-rouge">removeMin</code> does not suffice since the passenger leaving does not necessarily have first priority.<li>In- stead, we want a new operation, remove, that removes an arbitrary entry.</ul><li>Another standby passenger finds her gold frequent-flyer card and shows it to the agent.<ul><li>Thus, her priority has to be modified accordingly.<li>To achieve this change of priority, have a new operation <code class="language-plaintext highlighter-rouge">replaceKey</code> to replace the key of an existing entry with a new key.</ul><li>Finally, a third standby passenger notices her name is misspelled on the ticket and asks it to be corrected.<ul><li>To update the passenger’s record. have a new operation <code class="language-plaintext highlighter-rouge">replaceValue</code>, allowing us to replace the value of an existing entry with a new value.</ul></ul><h3 id="the-adaptable-priority-queue-adt">The Adaptable Priority Queue ADT</h3><p>The above scenarios motivate the definition of a new adaptable priority queue ADT that extends the priority queue ADT with additional functionality.</p><p>To implement methods <code class="language-plaintext highlighter-rouge">remove</code>, <code class="language-plaintext highlighter-rouge">replaceKey</code>, and <code class="language-plaintext highlighter-rouge">replaceValue</code> efficiently</p><ul><li>need a mechanism for finding a user’s element within a priority queue, ideally in a way that avoids performing a linear search through the entire collection.<li>in priority queue ADT, <code class="language-plaintext highlighter-rouge">insert(k, v)</code> formally returns an instance of type Entry to the user.<li>to be able to update or remove an entry in our new adaptable priority queue ADT, the user must retain that Entry object as a token that can be sent back as a parameter to identify the relevant entry. Formally, the adaptable priority queue ADT includes the following methods:<ul><li><code class="language-plaintext highlighter-rouge">remove(e)</code>: Removes entry e from the priority queue.<li><code class="language-plaintext highlighter-rouge">replaceKey(e, k)</code>: Replaces the key of existing entry e with k.<li><code class="language-plaintext highlighter-rouge">replaceValue(e, v)</code>: Replaces the value of existing entry e with v.</ul></ul><h4 id="location-aware-entries">Location-Aware Entries</h4><p>To allow an entry instance to encode a location within a priority queue</p><ul><li>extend the PQEntry class, adding a third field that designates the current index of an entry within the array-based representation of the heap<li>When perform priority queue operations on our heap, causing entries to be relocated within structure, make sure to update the third field of each affected entry to reflect its new index within the array.<li>example,<ul><li>after a call to removeMin().<li>The heap operation causes the minimal entry, (4,C), to be removed,<li>and the last entry, (16,X), to be temporarily moved from the last position to the root, followed by a down-heap bubble phase.<li>During the down-heap, element (16,X) is swapped with its left child, (5,A), at index 1 of the list, then swapped with its right child, (9,F), at index 4 of the list.<li>In the final configuration, the last field for all affected entries has been modified to reflect their new location.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/ZjEu5GT.png" alt="Screen Shot 2022-04-08 at 02.05.53" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/XGPiRjh.png" alt="Screen Shot 2022-04-08 at 02.03.07" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/OKkQjxI.png" alt="Screen Shot 2022-04-08 at 02.08.26" /></p><h4 id="implementing-an-adaptable-priority-queue">Implementing an Adaptable Priority Queue</h4><p>Java implementation of an adaptable priority queue as a subclass of the HeapPriorityQueue class</p><ul><li>defining a nested <code class="language-plaintext highlighter-rouge">AdaptablePQEntry</code> class extends the inherited PQEntry class, augmenting it with an additional index field.<ul><li>The inherited insert method is overridden, create and initialize an instance of the AdaptablePQEntry class (not the original PQEntry class).</ul><li><p>original <code class="language-plaintext highlighter-rouge">HeapPriorityQueue</code> class relies exclusively on a protected swap method for all low-level data movement during up-heap or down-heap operations.</p><li><p>The <code class="language-plaintext highlighter-rouge">AdaptablePriorityQueue</code> class overrides that utility in order to update the stored indices of our location-aware entries when they are relocated (as discussed on the previous page).</p><li>When an entry is sent as a parameter to remove, replaceKey, or replaceValue, we rely on the new index field of that entry to designate where the element resides in the heap (a fact that is easily validated).<ul><li>When a key of an existing entry is replaced, that new key may violate the heap-order property by being either too big or too small. We provide a new bubble utility that determines whether an up- heap or down-heap bubbling step is warranted. When removing an arbitrary entry, we replace it with the last entry in the heap (to maintain the complete binary tree property) and perform the bubbling step, since the displaced element may have a key that is too large or too small for its new location.</ul><li>Performance of Adaptable Priority Queue Implementations<ul><li><p>The performance of an adaptable priority queue by means of our location-aware heap structure is summarized in Table 9.5. The new class provides the same asymp- totic efficiency and space usage as the nonadaptive version, and provides logarith- mic performance for the new locator-based remove and replaceKey methods, and constant-time performance for the new replaceValuemethod.</p><li><code class="language-plaintext highlighter-rouge">size, isEmpty, min</code>: O(1)<li><code class="language-plaintext highlighter-rouge">insert</code>: O(log n)<li><code class="language-plaintext highlighter-rouge">remove</code>: O(log n)<li><code class="language-plaintext highlighter-rouge">removeMin</code>: O(log n)<li><code class="language-plaintext highlighter-rouge">replaceKey</code>: O(log n)<li><code class="language-plaintext highlighter-rouge">replaceValue</code>: O(1)</ul></ul><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">pq</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>

<span class="c1">// /∗∗ An implementation of an adaptable priority queue using an array-based heap. ∗/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HeapAdaptablePriorityQueue</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">HeapPriorityQueue</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">AdaptablePriorityQueue</span><span class="o">{</span>

    <span class="c1">//---------------- nested AdaptablePQEntry class ----------------</span>
    <span class="c1">// /∗∗ Extension of the PQEntry to include location information. ∗/</span>
    <span class="kd">protected</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">AdaptablePQEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">PQEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">index</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">AdaptablePQEntry</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getIndex</span><span class="o">(){</span><span class="k">return</span> <span class="n">index</span><span class="o">;}</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span><span class="n">index</span> <span class="o">=</span> <span class="n">j</span><span class="o">;}</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="nf">HeapAdaptablePriorityQueue</span><span class="o">(){</span> <span class="kd">super</span><span class="o">();</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">HeapAdaptablePriorityQueue</span><span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="n">comp</span><span class="o">){</span> <span class="kd">super</span><span class="o">(</span><span class="n">comp</span><span class="o">);</span> <span class="o">}</span>

    <span class="c1">// protected utilites</span>
    <span class="c1">// /∗∗ Validates an entry to ensure it is location-aware. ∗/</span>
    <span class="kd">protected</span> <span class="nc">AdaptablePQEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">validate</span><span class="o">(</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">entry</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">entry</span> <span class="k">instanceof</span> <span class="nc">AdaptablePQEntry</span><span class="o">))</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Invalid entry"</span><span class="o">);</span> <span class="nc">AdaptablePQEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">locator</span> <span class="o">=</span> <span class="o">(</span><span class="nc">AdaptablePQEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span> <span class="n">entry</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">locator</span><span class="o">.</span><span class="na">getIndex</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">||</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">!=</span> <span class="n">locator</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Invalid entry"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">locator</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// /∗∗ Exchanges the entries at indices i and j of the array list. ∗/</span>
    <span class="c1">// safe</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">swap</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">);</span>
        <span class="o">((</span><span class="nc">AdaptablePQEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)).</span><span class="na">setIndex</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">((</span><span class="nc">AdaptablePQEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">)).</span><span class="na">setIndex</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="c1">// /∗∗ Restores the heap property by moving the entry at index j upward/downward.∗/</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">bubble</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">compare</span><span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">),</span> <span class="n">heap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">parent</span><span class="o">(</span><span class="n">j</span><span class="o">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">upheap</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">downheap</span><span class="o">(</span><span class="n">j</span><span class="o">);</span> <span class="c1">// although it might not need to move</span>
    <span class="o">}</span>

    <span class="c1">// /∗∗ Inserts a key-value pair and returns the entry created. ∗/</span>
    <span class="kd">public</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">insert</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span> <span class="o">{</span>
        <span class="n">checkKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span> <span class="c1">// might throw an exception</span>
        <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">newest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AdaptablePQEntry</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
        <span class="n">heap</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newest</span><span class="o">);</span> <span class="c1">// add to the end of the list</span>
        <span class="n">upheap</span><span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// upheap newly added entry</span>
        <span class="k">return</span> <span class="n">newest</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="c1">// /∗∗ Removes the given entry from the priority queue. ∗/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">entry</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span> <span class="o">{</span>
        <span class="nc">AdaptablePQEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">locator</span> <span class="o">=</span> <span class="n">validate</span><span class="o">(</span><span class="n">entry</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">locator</span><span class="o">.</span><span class="na">getIndex</span><span class="o">(</span> <span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">(</span> <span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">heap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">(</span> <span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">heap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">(</span> <span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">bubble</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="c1">// /∗∗ Replaces the key of an entry. ∗/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">replaceKey</span><span class="o">(</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">entry</span><span class="o">,</span> <span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span> <span class="o">{</span>
        <span class="nc">AdaptablePQEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">locator</span> <span class="o">=</span> <span class="n">validate</span><span class="o">(</span><span class="n">entry</span><span class="o">);</span>
        <span class="n">checkKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="n">locator</span><span class="o">.</span><span class="na">setKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="n">bubble</span><span class="o">(</span><span class="n">locator</span><span class="o">.</span><span class="na">getIndex</span><span class="o">());</span>
    <span class="o">}</span>


    <span class="c1">// /∗∗ Replaces the value of an entry. ∗/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">replaceValue</span><span class="o">(</span><span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">entry</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span> <span class="o">{</span>
        <span class="nc">AdaptablePQEntry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">locator</span> <span class="o">=</span> <span class="n">validate</span><span class="o">(</span><span class="n">entry</span><span class="o">);</span>
        <span class="n">locator</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">value</span><span class="o">);</span> <span class="c1">// method inherited from PQEntry</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/00codenote/'>00CodeNote</a>, <a href='/categories/ds/'>DS</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Data Structures - Basic 1 - Priority Queues - Grace&url=https://ocholuo.github.io//posts/7-DS-Basic1-PriorityQueues/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Data Structures - Basic 1 - Priority Queues - Grace&u=https://ocholuo.github.io//posts/7-DS-Basic1-PriorityQueues/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Data Structures - Basic 1 - Priority Queues - Grace&url=https://ocholuo.github.io//posts/7-DS-Basic1-PriorityQueues/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Amazon-CloudFront/">AWS Lab - AWS CloudFront</a><li><a href="/posts/Alexa-1stSkill/">AWS Alex First Skill - RedVelvet Time</a><li><a href="/posts/NetworkProtocol-SSL-TLS-Handshake/">NetworkProtocol SSL/TLS Handshake</a><li><a href="/posts/pythonCrash/">Python Crash</a><li><a href="/posts/%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%A7%A3%E9%87%8AAWS/">AWS - 一句话解释AWS</a><li><a href="/posts/GKE/">GCP - Google Cloud Computing - Kubernetes and Kubernetes Engine</a><li><a href="/posts/Go-Note/">Go Note</a><li><a href="/posts/SCPs/">AWS - IdenAccessManage - SCPs (Service Control Policies)</a><li><a href="/posts/CompanyBenefit/">Company Benefit</a><li><a href="/posts/Encryption-SSL&TLS/">Cryptography - SSL/TLS Encryption</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/soc/">SOC</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/DS-Basic1-DS/"><div class="card-body"> <span class="timeago small" >Oct 10, 2021<i class="unloaded">2021-10-10T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Data Structures - Basic 1 - Data Structures</h3><div class="text-muted small"><p> Data Structures - Basic 1 - Data Structures overall pic Linear Structures String String class StringBuilder class ...</p></div></div></a></div><div class="card"> <a href="/posts/DS-Basic0-OOD/"><div class="card-body"> <span class="timeago small" >Oct 10, 2021<i class="unloaded">2021-10-10T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Data Structures - Basic 0 - Object Oriented Programming</h3><div class="text-muted small"><p> Object-oriented programming 面向对象编程 language different 面向过程和OOP在程序流程上的不同之处。 code different OOP inter Basic OOD Goals...</p></div></div></a></div><div class="card"> <a href="/posts/DS-Basic0/"><div class="card-body"> <span class="timeago small" >Oct 10, 2021<i class="unloaded">2021-10-10T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Data Structures - Basic 0</h3><div class="text-muted small"><p> DS Type Base Type Enum Types 枚举 Type Conversions Wrapper Classes and Objects Creating and Using O...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/6-Sorting-and-Searching/" class="btn btn-outline-primary" prompt="Older"><p>DS - pythonds3 - 6. Algorithms Sorting and Searching</p></a> <a href="/posts/7-Tree/" class="btn btn-outline-primary" prompt="Newer"><p>Data Structures - Basic 1 - Tree</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/ocholuo">Grace JyL</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/soc/">SOC</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://ocholuo.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script defer src="/assets/js/dist/pvreport.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-179830187-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-179830187-1'); }); </script>
