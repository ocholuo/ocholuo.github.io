<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="pv-proxy-endpoint" content="https://myochosite-291718.appspot.com/query?id=ahNwfm15b2Nob3NpdGUtMjkxNzE4chULEghBcGlRdWVyeRiAgIDo14eBCgw"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="DS - pythonds3 - 6. Algorithms Sorting and Searching" /><meta property="og:locale" content="en" /><meta name="description" content="DS - pythonds3 - 6. Algorithms Sorting and Searching summary Searching The Sequential Search 一个个找 Sequential Search of an Unordered List Sequential Search of an ordered List divide and conquer strategy. The Binary Search 𝑂(log𝑛) 从中间查找 Binary Search in python analyze the binary search Hashing Hash Functions Collision Resolution Collision Resolution with Linear Probing¶ Collision Resolution with Quadratic Probing Collision Resolution with Chaining Implementing the Map Abstract Data Type The complete hash table example Analysis of Hashing Sorting normal strategy The Bubble Sort 𝑂(𝑛^2) 两个两个 带着大的那个往上滚 bubbleSort in python analyze the bubble sort the short bubble The Selection Sort 𝑂(𝑛^2) 8-&gt;1，从1找到最大数location，放最后，切掉最后一个数字再继续 Selection sort in python analyze the Selection sort The Insertion Sort 𝑂(𝑛^2) 从2nd开始 往前比大小 小数字往前挪 Insertion Sort in Java Insertion Sort in python analyze the Insertion sort The Shell Sort between 𝑂(𝑛) and 𝑂(𝑛^2) gap拆开 分别不停的的insertion sort Shell sort in python analyze the Insertion sort divide and conquer strategy Merge Sort 𝑂(𝑛log𝑛) 从中间分开直到只剩一个-&gt;两个比大小 sort 再合起来 Merge sort in python analyze the mergeSort sort Quick Sort 𝑂(𝑛log𝑛) to 𝑂(𝑛^2), pivot, 从前往后数小的，从后往前数大的，卡住就换，最后 small &lt; pivot &lt; large QuickSort in python analyze the quickSort sort Other sorting Bucket Sort Radix Sort" /><meta property="og:description" content="DS - pythonds3 - 6. Algorithms Sorting and Searching summary Searching The Sequential Search 一个个找 Sequential Search of an Unordered List Sequential Search of an ordered List divide and conquer strategy. The Binary Search 𝑂(log𝑛) 从中间查找 Binary Search in python analyze the binary search Hashing Hash Functions Collision Resolution Collision Resolution with Linear Probing¶ Collision Resolution with Quadratic Probing Collision Resolution with Chaining Implementing the Map Abstract Data Type The complete hash table example Analysis of Hashing Sorting normal strategy The Bubble Sort 𝑂(𝑛^2) 两个两个 带着大的那个往上滚 bubbleSort in python analyze the bubble sort the short bubble The Selection Sort 𝑂(𝑛^2) 8-&gt;1，从1找到最大数location，放最后，切掉最后一个数字再继续 Selection sort in python analyze the Selection sort The Insertion Sort 𝑂(𝑛^2) 从2nd开始 往前比大小 小数字往前挪 Insertion Sort in Java Insertion Sort in python analyze the Insertion sort The Shell Sort between 𝑂(𝑛) and 𝑂(𝑛^2) gap拆开 分别不停的的insertion sort Shell sort in python analyze the Insertion sort divide and conquer strategy Merge Sort 𝑂(𝑛log𝑛) 从中间分开直到只剩一个-&gt;两个比大小 sort 再合起来 Merge sort in python analyze the mergeSort sort Quick Sort 𝑂(𝑛log𝑛) to 𝑂(𝑛^2), pivot, 从前往后数小的，从后往前数大的，卡住就换，最后 small &lt; pivot &lt; large QuickSort in python analyze the quickSort sort Other sorting Bucket Sort Radix Sort" /><link rel="canonical" href="https://ocholuo.github.io//posts/6-Sorting-and-Searching/" /><meta property="og:url" content="https://ocholuo.github.io//posts/6-Sorting-and-Searching/" /><meta property="og:site_name" content="Grace" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-08-25T11:11:11-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="DS - pythonds3 - 6. Algorithms Sorting and Searching" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-10-30T21:02:21-04:00","datePublished":"2019-08-25T11:11:11-04:00","description":"DS - pythonds3 - 6. Algorithms Sorting and Searching summary Searching The Sequential Search 一个个找 Sequential Search of an Unordered List Sequential Search of an ordered List divide and conquer strategy. The Binary Search 𝑂(log𝑛) 从中间查找 Binary Search in python analyze the binary search Hashing Hash Functions Collision Resolution Collision Resolution with Linear Probing¶ Collision Resolution with Quadratic Probing Collision Resolution with Chaining Implementing the Map Abstract Data Type The complete hash table example Analysis of Hashing Sorting normal strategy The Bubble Sort 𝑂(𝑛^2) 两个两个 带着大的那个往上滚 bubbleSort in python analyze the bubble sort the short bubble The Selection Sort 𝑂(𝑛^2) 8-&gt;1，从1找到最大数location，放最后，切掉最后一个数字再继续 Selection sort in python analyze the Selection sort The Insertion Sort 𝑂(𝑛^2) 从2nd开始 往前比大小 小数字往前挪 Insertion Sort in Java Insertion Sort in python analyze the Insertion sort The Shell Sort between 𝑂(𝑛) and 𝑂(𝑛^2) gap拆开 分别不停的的insertion sort Shell sort in python analyze the Insertion sort divide and conquer strategy Merge Sort 𝑂(𝑛log𝑛) 从中间分开直到只剩一个-&gt;两个比大小 sort 再合起来 Merge sort in python analyze the mergeSort sort Quick Sort 𝑂(𝑛log𝑛) to 𝑂(𝑛^2), pivot, 从前往后数小的，从后往前数大的，卡住就换，最后 small &lt; pivot &lt; large QuickSort in python analyze the quickSort sort Other sorting Bucket Sort Radix Sort","headline":"DS - pythonds3 - 6. Algorithms Sorting and Searching","mainEntityOfPage":{"@type":"WebPage","@id":"https://ocholuo.github.io//posts/6-Sorting-and-Searching/"},"url":"https://ocholuo.github.io//posts/6-Sorting-and-Searching/"}</script><title>DS - pythonds3 - 6. Algorithms Sorting and Searching | Grace</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Grace"><meta name="application-name" content="Grace"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://myochosite-291718.appspot.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://myochosite-291718.appspot.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/huoye.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Grace</a></div><div class="site-subtitle font-italic">2023 Mar 14 updated</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ocholuo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>DS - pythonds3 - 6. Algorithms Sorting and Searching</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>DS - pythonds3 - 6. Algorithms Sorting and Searching</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Grace JyL </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Aug 25, 2019, 11:11 AM -0400" >Aug 25, 2019<i class="unloaded">2019-08-25T11:11:11-04:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Oct 30, 2022, 6:02 PM -0700" >Oct 30, 2022<i class="unloaded">2022-10-30T21:02:21-04:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="9245 words">51 min read</span> <span id="pv" class="pageviews"> <i class="fas fa-spinner fa-spin fa-fw"></i> </span> views</div></div><div class="post-content"><ul><li><a href="#ds---pythonds3---6-algorithms-sorting-and-searching">DS - pythonds3 - 6. Algorithms Sorting and Searching</a><ul><li><a href="#summary">summary</a><li><a href="#searching">Searching</a><ul><li><a href="#the-sequential-search-一个个找">The Sequential Search 一个个找</a><ul><li><a href="#sequential-search-of-an-unordered-list">Sequential Search of an Unordered List</a><li><a href="#sequential-search-of-an-ordered-list">Sequential Search of an ordered List</a></ul><li><a href="#divide-and-conquer-strategy">divide and conquer strategy.</a><ul><li><a href="#the-binary-search">The Binary Search</a><ul><li><a href="#𝑂log𝑛-从中间查找"><code class="language-plaintext highlighter-rouge">𝑂(log𝑛)</code> 从中间查找</a><li><a href="#binary-search-in-python">Binary Search in python</a><li><a href="#analyze-the-binary-search">analyze the binary search</a></ul></ul><li><a href="#hashing">Hashing</a><ul><li><a href="#hash-functions">Hash Functions</a><li><a href="#collision-resolution">Collision Resolution</a><li><a href="#collision-resolution-with-linear-probing">Collision Resolution with Linear Probing¶</a><li><a href="#collision-resolution-with-quadratic-probing">Collision Resolution with Quadratic Probing</a><li><a href="#collision-resolution-with-chaining">Collision Resolution with Chaining</a></ul><li><a href="#implementing-the-map-abstract-data-type">Implementing the Map Abstract Data Type</a><ul><li><a href="#the-complete-hash-table-example">The complete hash table example</a><li><a href="#analysis-of-hashing">Analysis of Hashing</a></ul></ul><li><a href="#sorting">Sorting</a><ul><li><a href="#normal-strategy">normal strategy</a><ul><li><a href="#the-bubble-sort">The Bubble Sort</a><ul><li><a href="#𝑂𝑛2-两个两个-带着大的那个往上滚"><code class="language-plaintext highlighter-rouge">𝑂(𝑛^2)</code> 两个两个 带着大的那个往上滚</a><li><a href="#bubblesort-in-python">bubbleSort in python</a><li><a href="#analyze-the-bubble-sort">analyze the bubble sort</a><li><a href="#the-short-bubble">the short bubble</a></ul><li><a href="#the-selection-sort">The Selection Sort</a><ul><li><a href="#𝑂𝑛2-8-1从1找到最大数location放最后切掉最后一个数字再继续"><code class="language-plaintext highlighter-rouge">𝑂(𝑛^2)</code> 8-&gt;1，从1找到最大数location，放最后，切掉最后一个数字再继续</a><li><a href="#selection-sort-in-python">Selection sort in python</a><li><a href="#analyze-the-selection-sort">analyze the Selection sort</a></ul><li><a href="#the-insertion-sort">The Insertion Sort</a><ul><li><a href="#𝑂𝑛2-从2nd开始-往前比大小-小数字往前挪"><code class="language-plaintext highlighter-rouge">𝑂(𝑛^2)</code> 从2nd开始 往前比大小 小数字往前挪</a><li><a href="#insertion-sort-in-java">Insertion Sort in Java</a><li><a href="#insertion-sort-in-python">Insertion Sort in python</a><li><a href="#analyze-the-insertion-sort">analyze the Insertion sort</a></ul><li><a href="#the-shell-sort">The Shell Sort</a><ul><li><a href="#between-𝑂𝑛-and-𝑂𝑛2-gap拆开-分别不停的的insertion-sort"><code class="language-plaintext highlighter-rouge">between 𝑂(𝑛) and 𝑂(𝑛^2)</code> gap拆开 分别不停的的insertion sort</a><li><a href="#shell-sort-in-python">Shell sort in python</a><li><a href="#analyze-the-insertion-sort-1">analyze the Insertion sort</a></ul></ul><li><a href="#divide-and-conquer-strategy-1">divide and conquer strategy</a><ul><li><a href="#merge-sort">Merge Sort</a><ul><li><a href="#𝑂𝑛log𝑛-从中间分开直到只剩一个-两个比大小-sort-再合起来"><code class="language-plaintext highlighter-rouge">𝑂(𝑛log𝑛)</code> 从中间分开直到只剩一个-&gt;两个比大小 sort 再合起来</a><li><a href="#merge-sort-in-python">Merge sort in python</a><li><a href="#analyze-the-mergesort-sort">analyze the mergeSort sort</a></ul><li><a href="#quick-sort">Quick Sort</a><ul><li><a href="#𝑂𝑛log𝑛-to-𝑂𝑛2-pivot-从前往后数小的从后往前数大的卡住就换最后-small--pivot--large"><code class="language-plaintext highlighter-rouge">𝑂(𝑛log𝑛) to 𝑂(𝑛^2)</code>, pivot, 从前往后数小的，从后往前数大的，卡住就换，最后 small &lt; pivot &lt; large</a><li><a href="#quicksort-in-python">QuickSort in python</a><li><a href="#analyze-the-quicksort-sort">analyze the quickSort sort</a></ul></ul><li><a href="#other-sorting">Other sorting</a><ul><li><a href="#bucket-sort">Bucket Sort</a><li><a href="#radix-sort">Radix Sort</a></ul></ul></ul></ul><hr /><h1 id="ds---pythonds3---6-algorithms-sorting-and-searching">DS - pythonds3 - 6. Algorithms Sorting and Searching</h1><hr /><h2 id="summary">summary</h2><p>A sequential search is <code class="language-plaintext highlighter-rouge">𝑂(𝑛)</code> for ordered and unordered lists.</p><p>A binary search of an ordered list is <code class="language-plaintext highlighter-rouge">𝑂(log𝑛)</code> in the worst case.</p><p>Hash tables can provide <code class="language-plaintext highlighter-rouge">constant</code> time searching.</p><p>A bubble sort, a selection sort, and an insertion sort are <code class="language-plaintext highlighter-rouge">𝑂(𝑛^2)</code> algorithms.</p><p>A shell sort improves on the insertion sort by sorting incremental sublists. It falls between <code class="language-plaintext highlighter-rouge">𝑂(𝑛) to 𝑂(𝑛^2)</code>.</p><p>A merge sort is <code class="language-plaintext highlighter-rouge">𝑂(𝑛log𝑛)</code>, but requires <strong>additional space</strong> for the merging process.</p><p>A quick sort is <code class="language-plaintext highlighter-rouge">𝑂(𝑛log𝑛) to 𝑂(𝑛2)</code> degrade if the split points are not near the middle of the list. It <strong>does not require additional space</strong>.</p><hr /><h2 id="searching">Searching</h2><p>Searching is the algorithmic process of finding a particular item in a collection of items.</p><ul><li>A search typically answers either <code class="language-plaintext highlighter-rouge">True</code> or <code class="language-plaintext highlighter-rouge">False</code> as to whether the item is present.<li>On occasion it may be modified to return where the item is found.</ul><p>In Python, there is a very easy way to ask whether an item is in a list of items.</p><p>use the <code class="language-plaintext highlighter-rouge">in</code> operator.</p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="mi">15</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">3</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></table></code></div></div><p>many different ways to search for the item.</p><p>how these algorithms work and how they compare to one another.</p><hr /><h3 id="the-sequential-search-一个个找">The Sequential Search 一个个找</h3><p>When data items are stored in a collection such as a list, they have a <strong>linear or sequential relationship</strong>.</p><ul><li>Each data item is stored in a position <code class="language-plaintext highlighter-rouge">relative to the others</code>.<li>In Python lists, these relative positions are the <code class="language-plaintext highlighter-rouge">index</code> values of the individual items.<ul><li>index values are ordered, possible for us to visit them in sequence.<li>This process gives rise to our first searching technique, the sequential search.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/crvHNDy.png" alt="seqsearch" /></p><ul><li>simply move from item to item,<li>following the underlying sequential ordering until find it or run out of items.<li>If run out of items, the item we were searching for was not present.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">sequentialSearch</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
  <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
  <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">alist</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
      <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span>
  <span class="k">return</span> <span class="n">found</span>
<span class="n">testlist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">sequentialSearch</span><span class="p">(</span><span class="n">testlist</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">sequentialSearch</span><span class="p">(</span><span class="n">testlist</span><span class="p">,</span> <span class="mi">13</span><span class="p">))</span>
</pre></table></code></div></div><h4 id="sequential-search-of-an-unordered-list">Sequential Search of an Unordered List</h4><p><img data-proofer-ignore data-src="https://i.imgur.com/hYcuowN.png" alt="Screen Shot 2021-09-26 at 3.43.55 AM" /></p><p>To analyze searching algorithms, we need to decide on a <strong>basic unit of computation</strong>.</p><ul><li>typically the common step that must be repeated in order to solve the problem.<li>For searching, it makes sense to count the number of comparisons performed.<li>Each comparison may or may not discover the item we are looking for.<li>In addition, we make another assumption here.<li>The list of items is not ordered in any way.<li>The items have been placed randomly into the list.<li>In other words, the probability that the item we are looking for is in any particular position is exactly the same for each position of the list.</ul><p>If the item is not in the list,</p><ul><li>the only way to know it is to <strong>compare it against every item present</strong>.<li>If there are <code class="language-plaintext highlighter-rouge">𝑛</code> items, then the sequential search requires <code class="language-plaintext highlighter-rouge">𝑛</code> comparisons to discover that the item is not there.<li>In the case where the item is in the list, the analysis is not so straightforward.<li>There are actually three different scenarios that can occur.<ul><li>best case, find the item in the first place, need only one comparison.<li>worst case, not discover the item until the very last comparison, the <code class="language-plaintext highlighter-rouge">nth</code> comparison.<li>the average case<ul><li>On average, we will find the item about halfway into the list;<li>we will compare against <code class="language-plaintext highlighter-rouge">n/2</code> items.<li>however, that as <code class="language-plaintext highlighter-rouge">n</code> gets large, the coefficients, no matter what they are, become insignificant in our approximation,<li>so the complexity of the sequential search, is <code class="language-plaintext highlighter-rouge">𝑂(𝑛)</code>.<li>Table 1 summarizes these results.</ul></ul></ul><h4 id="sequential-search-of-an-ordered-list">Sequential Search of an ordered List</h4><p>We assumed earlier that the items in our collection had been randomly placed, no relative order between the items.</p><ul><li>What would happen to the sequential search if the items were ordered in some way?<li>Would we be able to gain any efficiency in our search technique?</ul><p>Assume that the list of items was constructed so that the items were in ascending order, from low to high.</p><ul><li>If the item we are looking for is present in the list, the chance of it being in any one of the <code class="language-plaintext highlighter-rouge">n</code> positions is still the same as before.<li>We will still have the same number of comparisons to find the item.<li>However, if the item is not present there is a slight advantage.<ul><li>the algorithm does not have to continue looking through all of the items to report that the item was not found. It can stop immediately.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/FS7vkQZ.png" alt="Screen Shot 2021-09-26 at 3.44.52 AM" /></p><ul><li>the best case we might discover that the item is not in the list by looking at only one item.<li>On average, we will know after looking through only 𝑛/2 items.<li>However, this technique is still 𝑂(𝑛).</ul><p>In summary, a sequential search is improved by ordering the list only in the case where we do not find the item.</p><p><img data-proofer-ignore data-src="https://i.imgur.com/hYcuowN.png" alt="Screen Shot 2021-09-26 at 3.43.55 AM" /> <img data-proofer-ignore data-src="https://i.imgur.com/FS7vkQZ.png" alt="Screen Shot 2021-09-26 at 3.44.52 AM" /></p><hr /><h3 id="divide-and-conquer-strategy">divide and conquer strategy.</h3><h4 id="the-binary-search">The Binary Search</h4><h5 id="𝑂log𝑛-从中间查找"><code class="language-plaintext highlighter-rouge">𝑂(log𝑛)</code> 从中间查找</h5><p>take greater advantage of the ordered list</p><ul><li>In the sequential search, compare against the first item, there are at most <code class="language-plaintext highlighter-rouge">𝑛−1</code> more items to look through if the first item is not what we are looking for.</ul><p>binary search</p><ul><li>start by examining the middle item.<li>If that item is the one, we are done.<li>If not, use the ordered nature of the list to eliminate half of the remaining items.<li>If the item searching for is &gt; the middle item, the entire lower half of the list as well as the middle item can be eliminated from further consideration.<li>The item, if it is in the list, must be in the upper half.</ul><p>We can then repeat the process with the upper half.</p><ul><li>Start at the middle item and compare it against what we are looking for.<li>Again, we either find it or split the list in half, therefore eliminating another large part of our possible search space.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/137Zfsb.png" alt="binsearch" /></p><h5 id="binary-search-in-python">Binary Search in python</h5><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
  <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">last</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
  <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>

  <span class="k">while</span> <span class="n">first</span><span class="o">&lt;=</span><span class="n">last</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
    <span class="n">midpoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">first</span> <span class="o">+</span> <span class="n">last</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">alist</span><span class="p">[</span><span class="n">midpoint</span><span class="p">]</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
      <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">item</span> <span class="o">&lt;</span> <span class="n">alist</span><span class="p">[</span><span class="n">midpoint</span><span class="p">]:</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">midpoint</span><span class="o">-</span><span class="mi">1</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">midpoint</span><span class="o">+</span><span class="mi">1</span>
  <span class="k">return</span> <span class="n">found</span>

<span class="n">testlist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">42</span><span class="p">,]</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">binarySearch</span><span class="p">(</span><span class="n">testlist</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">binarySearch</span><span class="p">(</span><span class="n">testlist</span><span class="p">,</span> <span class="mi">13</span><span class="p">))</span>
</pre></table></code></div></div><p>great example of a <code class="language-plaintext highlighter-rouge">divide and conquer</code> strategy.</p><ul><li>Divide and conquer<li>divide the problem into smaller pieces, solve the smaller pieces in some way, and then reassemble the whole problem to get the result.</ul><p>When we perform a binary search of a list,</p><ul><li>we first check the middle item.<li>If the item we are searching for is less than the middle item, we can simply perform a binary search of the left half of the original list.<li>Likewise, if the item is greater, we can perform a binary search of the right half.<li>Either way, this is a recursive call to the binary search function passing a smaller list.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
  <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">False</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">midpoint</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">alist</span><span class="p">[</span><span class="n">midpoint</span><span class="p">]</span><span class="o">==</span><span class="n">item</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">item</span><span class="o">&lt;</span><span class="n">alist</span><span class="p">[</span><span class="n">midpoint</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="n">alist</span><span class="p">[:</span><span class="n">midpoint</span><span class="p">],</span><span class="n">item</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="n">alist</span><span class="p">[</span><span class="n">midpoint</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span><span class="n">item</span><span class="p">)</span>
<span class="n">testlist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">42</span><span class="p">,]</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">binarySearch</span><span class="p">(</span><span class="n">testlist</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">binarySearch</span><span class="p">(</span><span class="n">testlist</span><span class="p">,</span> <span class="mi">13</span><span class="p">))</span>
</pre></table></code></div></div><h5 id="analyze-the-binary-search">analyze the binary search</h5><ul><li>each comparison eliminates about half of the remaining items from consideration.<li>What is the maximum number of comparisons this algorithm will require to check the entire list?<ul><li>If we start with <code class="language-plaintext highlighter-rouge">n</code> items, about <code class="language-plaintext highlighter-rouge">𝑛/2</code> items will be left after the first comparison.<li>After the second comparison, there will be about <code class="language-plaintext highlighter-rouge">𝑛/4</code>. Then <code class="language-plaintext highlighter-rouge">𝑛/8, 𝑛/16, and so on</code>.</ul><li>How many times can we split the list<ul><li>When we split the list enough times, we end up with a list that has just one item.<li>Either that is the item we are looking for or it is not.<li>Either way, we are done.</ul><li>The number of comparisons necessary to get to this point is <code class="language-plaintext highlighter-rouge">i</code> where <code class="language-plaintext highlighter-rouge">n/2^i = 1</code>.<ul><li>Solving for <code class="language-plaintext highlighter-rouge">i</code>: <code class="language-plaintext highlighter-rouge">𝑖=log𝑛</code>.<li>The maximum number of comparisons is logarithmic with respect to the number of items in the list.<li>Therefore, the binary search is <code class="language-plaintext highlighter-rouge">𝑂(log𝑛)</code>.</ul></ul><p>One additional analysis issue needs to be addressed. In the recursive solution shown above, the recursive call,</p><ul><li>uses the slice operator to create the left half of the list that is then passed to the next invocation (similarly for the right half as well).<li>The analysis that we did above assumed that the slice operator takes <code class="language-plaintext highlighter-rouge">constant time</code>.<li>However, we know that the slice operator in Python is actually <code class="language-plaintext highlighter-rouge">O(k)</code>.<li>This means that the binary search using slice will not perform in strict logarithmic time.<li>Luckily this can be remedied by passing the list along with the starting and ending indices.</ul><p>Even though a binary search is generally better than a sequential search, it is important to note that</p><ul><li><strong>for small values of n, the additional cost of sorting is probably not worth it.</strong><li>In fact, we should always consider whether it is cost effective to take on the extra work of <code class="language-plaintext highlighter-rouge">sorting</code> to gain <code class="language-plaintext highlighter-rouge">searching</code> benefits.<li>If we can sort once and then search many times, the cost of the sort is not so significant.<li>However, for large lists, <code class="language-plaintext highlighter-rouge">sorting even once can be so expensive</code> that simply performing a sequential search from the start may be the best choice.</ul><hr /><h3 id="hashing">Hashing</h3><ul><li>Binary Search: make improvements by taking advantage of information about where items are stored in the collection with respect to one another.<ul><li>For example, by knowing that a list was ordered, we could search in logarithmic time using a binary search.</ul><li>In this section we will attempt to go one step further by building a <code class="language-plaintext highlighter-rouge">data structure</code> that can be searched in <code class="language-plaintext highlighter-rouge">𝑂(1)</code> time.<li>This concept is referred to as <code class="language-plaintext highlighter-rouge">hashing</code>.</ul><p>In order to do this, we will need to know even more about where the items might be when we go to look for them in the collection.</p><ul><li>If every item is where it should be, then the search can use a single comparison to discover the presence of an item.<ul><li>We will see, however, that this is typically not the case.</ul></ul><p>A hash table is a collection of items which are stored in such a way as to make it easy to find them later.</p><ul><li>Each position of the hash table, often called a <code class="language-plaintext highlighter-rouge">slot</code>, can hold an item and is named by an integer value starting at 0.<li>For example, we will have a slot named 0, a slot named 1, a slot named 2, and so on.<li>Initially, the hash table contains no items so every slot is empty.<li>We can implement a hash table by using a list with each element initialized to the special Python value <code class="language-plaintext highlighter-rouge">None</code>.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/kBYvacm.png" alt="hashtable" /></p><p><code class="language-plaintext highlighter-rouge">The mapping between an item and the slot</code> where that item belongs in the hash table is called the <code class="language-plaintext highlighter-rouge">hash function</code>.</p><ul><li>The hash function will take any item in the collection and return an integer in the range of slot names, between 0 and m-1.<li>Assume that we have the set of integer items 54, 26, 93, 17, 77, and 31.<li>Our first hash function, sometimes referred to as the “remainder method,” simply takes an item and divides it by the table size, returning the remainder as its hash value (ℎ(𝑖𝑡𝑒𝑚)=𝑖𝑡𝑒𝑚%11).<li>Table 4 gives all of the hash values for our example items.<li><p>Note that this remainder method (modulo arithmetic) will typically be present in some form in all hash functions, since the result must be in the range of slot names.</p><li>Once the hash values have been computed, insert each item into the hash table at the designated position<li>Note that 6 of the 11 slots are now occupied.<li><p>This is referred to as the <code class="language-plaintext highlighter-rouge">load factor</code>, and is commonly denoted by <code class="language-plaintext highlighter-rouge">𝜆=𝑛𝑢𝑚𝑏𝑒𝑟𝑜𝑓𝑖𝑡𝑒𝑚𝑠 / 𝑡𝑎𝑏𝑙𝑒𝑠𝑖𝑧𝑒</code>. For this example, <code class="language-plaintext highlighter-rouge">𝜆=6/11</code>.</p><li>to search for an item,<ul><li>simply use the hash function to compute the slot name for the item<li>and then check the hash table to see if it is present.<li>This searching operation is 𝑂(1),<li>since a constant amount of time is required to <code class="language-plaintext highlighter-rouge">compute the hash value</code> and then <code class="language-plaintext highlighter-rouge">index the hash table at that location</code>.<li>If everything is where it should be, we have found a constant time search algorithm.</ul></ul><p>You can probably already see that this technique is going to work only if each item maps to a unique location in the hash table.</p><ul><li>For example, if the item 44 had been the next item in our collection, it would have a hash value of 0 (44%11==0).<li>Since 77 also had a hash value of 0, we would have a problem.<li>According to the hash function, two or more items would need to be in the same slot.<li>This is referred to as a <code class="language-plaintext highlighter-rouge">collision/clash</code></ul><h4 id="hash-functions">Hash Functions</h4><ul><li>Given a collection of items, a hash function that <code class="language-plaintext highlighter-rouge">maps each item into a unique slot</code> is referred to as a perfect hash function.<li>If we know the items and the collection will never change, then it is possible to construct a perfect hash function (refer to the exercises for more about perfect hash functions).<li>Unfortunately, given an arbitrary collection of items, there is no systematic way to construct a perfect hash function.<li>Luckily, we do not need the hash function to be perfect to still gain performance efficiency.</ul><p>to always have a perfect hash function</p><ul><li><code class="language-plaintext highlighter-rouge">increase the size of the hash table</code> so that each possible value in the item range can be accommodated.<li>This guarantees that each item will have a unique slot.<li>Although this is practical for small numbers of items, it is not feasible when the number of possible items is large.<li>For example, if the items were nine-digit Social Security numbers, this method would require almost one billion slots.<li>If we only want to store data for a class of 25 students, we will be wasting an enormous amount of memory.</ul><p>Our goal is to create a hash function that</p><ul><li><code class="language-plaintext highlighter-rouge">minimizes the number of collisions</code>,<li>easy to compute,<li>evenly distributes the items in the hash table.</ul><p><strong>remainder method</strong></p><ul><li>The folding method for constructing hash functions begins by dividing the item into <code class="language-plaintext highlighter-rouge">equal-size pieces</code> (the last piece may not be of equal size).<li>These pieces are then added together to give the resulting hash value.<li>For example<li>item was the phone number 436-555-4601.<li>we would take the digits and divide them into groups of 2 (43,65,55,46,01).<li>After the addition, 43+65+55+46+01, we get 210.<li>If we assume our hash table has 11 slots, then we need to perform the extra step of dividing by 11 and keeping the remainder.<li>In this case 210 % 11 is 1, so the phone number 436-555-4601 hashes to slot 1.<li>Some folding methods go one step further and reverse every other piece before the addition.<li>For the above example, we get 43+56+55+64+01=219 which gives 219 % 11=10.</ul><p><strong>mid-square method</strong></p><ul><li>Another numerical technique for constructing a hash function is called the <code class="language-plaintext highlighter-rouge">mid-square method</code>.<li>We first square the item, and then extract some portion of the resulting digits.<li>For example, if the item were 44, we would first compute 44^2=1,936.<li>By extracting the middle two digits, 93, and performing the remainder step, we get 5 (93 % 11).</ul><p>the remainder method and the mid-square method.</p><ul><li>You should verify that you understand how these values were computed.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/9OrXzlU.png" alt="Screen Shot 2021-09-26 at 4.37.38 AM" /></p><p>We can also create hash functions for character-based items such as strings.</p><ul><li>The word “cat” can be thought of as a sequence of ordinal values.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nf">ord</span><span class="p">(</span><span class="s">'c'</span><span class="p">)</span>
<span class="mi">99</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>
<span class="mi">97</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">ord</span><span class="p">(</span><span class="s">'t'</span><span class="p">)</span>
<span class="mi">116</span>
</pre></table></code></div></div><ul><li>take these three ordinal values,<li>add them up,<li>and use the <code class="language-plaintext highlighter-rouge">remainder</code> method to get a hash value</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/yJZZee2.png" alt="stringhash" /></p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="n">astring</span><span class="p">,</span> <span class="n">tablesize</span><span class="p">):</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">astring</span><span class="p">)):</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">+</span> <span class="nf">ord</span><span class="p">(</span><span class="n">astring</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="o">%</span><span class="n">tablesize</span>
</pre></table></code></div></div><p>It is interesting to note that when using this hash function,</p><ul><li>anagrams will always be given the same hash value.<li>To remedy this, we could use the position of the character as a weight.<li>Figure 7 shows one possible way to use the positional value as a weighting factor.<li>The modification to the hash function is left as an exercise.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/hCZwbS8.png" alt="stringhash2" /></p><p>You may be able to think of a number of additional ways to compute hash values for items in a collection.</p><ul><li>The important thing to remember is that the hash function has to be <code class="language-plaintext highlighter-rouge">efficient</code> so that it does not become the dominant part of the storage and search process.<li>If the hash function is too complex, then it becomes more work to compute the slot name than it would be to simply do a basic sequential or binary search as described earlier.<li>This would quickly defeat the purpose of hashing.</ul><h4 id="collision-resolution">Collision Resolution</h4><p>When two items hash to the same slot,</p><ul><li>we must have a systematic method for placing the second item in the hash table.<li>This process is called <code class="language-plaintext highlighter-rouge">collision resolution</code>.<li>if the hash function is perfect, collisions will never occur.<li>However, since this is often not possible, collision resolution becomes a very important part of hashing.</ul><p>One method for resolving collisions</p><h4 id="collision-resolution-with-linear-probing">Collision Resolution with Linear Probing¶</h4><ul><li>looks into the hash table and tries to find another open slot to hold the item that caused the collision.<li><code class="language-plaintext highlighter-rouge">start at the original hash value position</code> and then <code class="language-plaintext highlighter-rouge">move in a sequential manner through the slots until we encounter the first slot that is empty</code>.<li>Note that we may need to go back to the first slot (circularly) to cover the entire hash table.<li>This collision resolution process is referred to as open addressing in that it tries to find the next open slot or address in the hash table.<li>By systematically visiting each slot one at a time, we are performing an open addressing technique called linear probing.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/5s3n6tV.png" alt="hashtable2" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/f3odMnr.png" alt="linearprobing1" /></p><p>an extended set of integer items under the simple <code class="language-plaintext highlighter-rouge">remainder</code> method hash function (54,26,93,17,77,31,44,55,20).</p><ul><li>When we attempt to place 44 into slot 0, a collision occurs.<li>Under linear probing, look sequentially, slot by slot, until we find an open position slot 1.<li>Again, 55 should go in slot 0 but must be placed in slot 2 since it is the next open position.<li>The final value of 20 hashes to slot 9. Since slot 9 is full, do <code class="language-plaintext highlighter-rouge">linear probing</code>, finally find an empty slot at position 3.</ul><p><strong>search for items</strong> Once we have built a hash table using open addressing and linear probing, it is essential that we utilize the same methods to search for items.</p><p>to look up the item 93.</p><ul><li>When we compute the hash value, we get 5.<li>Looking in slot 5 reveals 93, and we can return True.</ul><p>looking for 20?</p><ul><li>Now the hash value is 9, and slot 9 is currently holding 31.<li>We cannot simply return False since we know that there could have been collisions.<li>We are now forced to do a sequential search, starting at position 10, looking until either we find the item 20 or we find an empty slot.</ul><p><strong>clustering</strong></p><ul><li>A disadvantage to linear probing is the <code class="language-plaintext highlighter-rouge">tendency</code> for <code class="language-plaintext highlighter-rouge">clustering</code> 聚集;<li>items become clustered in the table.<li>This means that if many collisions occur at the same hash value, a number of surrounding slots will be filled by the linear probing resolution.<li>This will have an impact on other items that are being inserted, as we saw when we tried to add the item 20 above.<li><p>A cluster of values hashing to 0 had to be skipped to finally find an open position</p><li>One way to deal with clustering<li>extend the linear probing technique, instead of looking sequentially for the next open slot, we skip slots, thereby more evenly distributing the items that have caused collisions.<li>This will potentially reduce the clustering that occurs.<li>Figure 10 shows the items when collision resolution is done with a “plus 3” probe.<li>This means that once a collision occurs, we will look at every third slot until we find one that is empty.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/HdixzUR.png" alt="linearprobing2" /></p><p><strong>rehashing</strong></p><ul><li>The general name for this process of looking for another slot after a collision is rehashing.<li>With simple <code class="language-plaintext highlighter-rouge">linear probing</code>, the rehash function is<ul><li>newhashvalue = rehash(oldhashvalue)<li>rehash(pos) = (pos+1)%table_size</ul><li>The “plus 3” rehash can be defined as<ul><li>rehash(pos) = (pos+3)%table_size</ul><li>In general<ul><li>rehash(pos) = (pos+skip)%table_size</ul><li>It is important to note that the size of the “skip” must be such that all the slots in the table will eventually be visited.<li>Otherwise, part of the table will be unused.<li>To ensure this, it is often suggested that the table size be a prime number.<li>This is the reason we have been using 11 in our examples.</ul><h4 id="collision-resolution-with-quadratic-probing">Collision Resolution with Quadratic Probing</h4><ul><li>A variation of the linear probing idea is called quadratic probing.<li>Instead of using a constant “skip” value, we use a <code class="language-plaintext highlighter-rouge">rehash function</code> that <code class="language-plaintext highlighter-rouge">increments the hash value by 1, 3, 5, 7, 9, and so on</code>.<li>This means that if the first hash value is <code class="language-plaintext highlighter-rouge">h</code>, the successive values are <code class="language-plaintext highlighter-rouge">ℎ+1, ℎ+4, ℎ+9, ℎ+16</code>, and so on.<li>In general, the i will be <code class="language-plaintext highlighter-rouge">i^2 𝑟𝑒ℎ𝑎𝑠ℎ(𝑝𝑜𝑠)=(ℎ+𝑖^2)</code>.<li>In other words, quadratic probing uses a skip consisting of successive perfect squares.<li>Figure 11 shows our example values after they are placed using this technique.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/jUuUlbe.png" alt="quadratic" /></p><h4 id="collision-resolution-with-chaining">Collision Resolution with Chaining</h4><ul><li>An alternative method for handling the collision problem is to allow each slot to hold a reference to a collection (or chain) of items.<li>Chaining allows many items to exist at the same location in the hash table.<li>When collisions happen, the item is still placed in the proper slot of the hash table.<li>As more and more items hash to the same location, the difficulty of searching for the item in the collection increases.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/tC4Hhw8.png" alt="chaining" /></p><p>When we want to search for an item, we use the hash function to generate the slot where it should reside.</p><ul><li>Since each slot holds a collection, we use a searching technique to decide whether the item is present.<li>The advantage is that on the average there are likely to be many fewer items in each slot, so the search is perhaps more efficient. We will look at the analysis for hashing at the end of this section.</ul><hr /><h3 id="implementing-the-map-abstract-data-type">Implementing the Map Abstract Data Type</h3><p>dictionary is an associative data type where you can store key–data pairs.</p><ul><li>The key is used to look up the associated data value.<li>We often refer to this idea as a map.</ul><p>The map abstract data type is defined as follows.</p><ul><li>The structure is an unordered collection of associations between a key and a data value.<li>The keys in a map are all unique so that there is a one-to-one relationship between a key and a value.<li><p>The operations are given below.</p><li><code class="language-plaintext highlighter-rouge">Map()</code><ul><li>Create a new, empty map. It returns an empty map collection.</ul><li><code class="language-plaintext highlighter-rouge">put(key,val)</code><ul><li>Add a new key-value pair to the map. If the key is already in the map then replace the old value with the new value.</ul><li><code class="language-plaintext highlighter-rouge">get(key)</code><ul><li>Given a key, return the value stored in the map or None otherwise.</ul><li><code class="language-plaintext highlighter-rouge">del</code><ul><li>Delete the key-value pair from the map using a statement of the form del map[key].</ul><li><code class="language-plaintext highlighter-rouge">len()</code><ul><li>Return the number of key-value pairs stored in the map.</ul><li><code class="language-plaintext highlighter-rouge">in</code><ul><li>Return True for a statement of the form key in map, if the given key is in the map, False otherwise.</ul></ul><p>One of the great benefits of a dictionary is the fact that given a key, we can look up the associated data value very quickly.</p><ul><li>In order to provide this fast look up capability, we need an implementation that supports an efficient search.<li>We could use a list with <code class="language-plaintext highlighter-rouge">sequential or binary search</code> but it would be even better to use a hash table as described above since looking up an item in a hash table can approach <code class="language-plaintext highlighter-rouge">𝑂(1)</code> performance.</ul><p>use two lists to create a <code class="language-plaintext highlighter-rouge">HashTable</code> class that implements the <code class="language-plaintext highlighter-rouge">Map abstract data type</code>.</p><ul><li>One list, called <code class="language-plaintext highlighter-rouge">slots</code>, will hold the key items<li>a parallel list, called <code class="language-plaintext highlighter-rouge">data</code>, will hold the data values.<li>When we look up a key, the corresponding position in the data list will hold the associated data value.<li>We will treat the key list as a hash table using the ideas presented earlier.<li>Note that the initial size for the hash table has been chosen to be 11.<li>Although this is arbitrary, it is important that the size be a prime number so that the collision resolution algorithm can be as efficient as possible.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">HashTable</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">11</span>
        <span class="n">self</span><span class="p">.</span><span class="n">slots</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span>
</pre></table></code></div></div><p>hashfunction implements the simple <code class="language-plaintext highlighter-rouge">remainder</code> method.</p><ul><li>The <code class="language-plaintext highlighter-rouge">collision resolution technique</code> is <code class="language-plaintext highlighter-rouge">linear probing</code> with a <code class="language-plaintext highlighter-rouge">“plus 1”</code> rehash function.<li>The <code class="language-plaintext highlighter-rouge">put</code> function<ul><li>assumes that there will eventually be an empty slot unless the key is already present in the <code class="language-plaintext highlighter-rouge">self.slots</code>.<li>It computes the original hash value<li>and if that slot is not empty, iterates the rehash function until an empty slot occurs.<li>If a nonempty slot already contains the key, the old data value is replaced with the new data value.<li>Dealing with the situation where there are no empty slots left is an exercise.</ul></ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
  <span class="n">hashvalue</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">hashfunction</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">))</span>

  <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
    <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
      <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>  <span class="c1">#replace
</span>    <span class="k">else</span><span class="p">:</span>
      <span class="n">nextslot</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">rehash</span><span class="p">(</span><span class="n">hashvalue</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">))</span>
      <span class="k">while</span> <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> \
                      <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
        <span class="n">nextslot</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">rehash</span><span class="p">(</span><span class="n">nextslot</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">))</span>

      <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span><span class="o">=</span><span class="n">key</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span><span class="o">=</span><span class="n">data</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span> <span class="c1">#replace
</span>
<span class="k">def</span> <span class="nf">hashfunction</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">size</span><span class="p">):</span>
     <span class="k">return</span> <span class="n">key</span><span class="o">%</span><span class="n">size</span>

<span class="k">def</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">oldhash</span><span class="p">,</span><span class="n">size</span><span class="p">):</span>
    <span class="nf">return </span><span class="p">(</span><span class="n">oldhash</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">size</span>
</pre></table></code></div></div><ul><li>get function<ul><li>begins by computing the initial hash value.<li>If the value is not in the initial slot, rehash is used to locate the next possible position.<li>Notice that line 15 guarantees that the search will terminate by checking to make sure that we have not returned to the initial slot.<li>If that happens, we have exhausted all possible slots and the item must not be present.</ul></ul><p>The final methods of the HashTable class provide additional dictionary functionality.</p><ul><li>We overload the <code class="language-plaintext highlighter-rouge">__getitem__</code> and <code class="language-plaintext highlighter-rouge">__setitem__</code> methods to allow access using<code class="language-plaintext highlighter-rouge">[]</code>.<li>This means that once a HashTable has been created, the familiar index operator will be available.<li>We leave the remaining methods as exercises.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
  <span class="n">startslot</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">hashfunction</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">))</span>

  <span class="n">data</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="bp">False</span>
  <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
  <span class="n">position</span> <span class="o">=</span> <span class="n">startslot</span>
  <span class="k">while</span> <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
     <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
       <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
       <span class="n">data</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">position</span><span class="p">]</span>
     <span class="k">else</span><span class="p">:</span>
       <span class="n">position</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="nf">rehash</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">))</span>
       <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="n">startslot</span><span class="p">:</span>
           <span class="n">stop</span> <span class="o">=</span> <span class="bp">True</span>
  <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
    <span class="n">self</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>
</pre></table></code></div></div><p>The following session shows the HashTable class in action.</p><ul><li>First we will create a hash table and store some items with integer keys and string data values.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="o">=</span><span class="nc">HashTable</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">[</span><span class="mi">54</span><span class="p">]</span><span class="o">=</span><span class="s">"cat"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="o">=</span><span class="s">"dog"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">[</span><span class="mi">93</span><span class="p">]</span><span class="o">=</span><span class="s">"lion"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span><span class="o">=</span><span class="s">"tiger"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">[</span><span class="mi">77</span><span class="p">]</span><span class="o">=</span><span class="s">"bird"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span><span class="o">=</span><span class="s">"cow"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">[</span><span class="mi">44</span><span class="p">]</span><span class="o">=</span><span class="s">"goat"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">[</span><span class="mi">55</span><span class="p">]</span><span class="o">=</span><span class="s">"pig"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="o">=</span><span class="s">"chicken"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">.</span><span class="n">slots</span>
<span class="p">[</span><span class="mi">77</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">93</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">54</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">.</span><span class="n">data</span>
<span class="p">[</span><span class="s">'bird'</span><span class="p">,</span> <span class="s">'goat'</span><span class="p">,</span> <span class="s">'pig'</span><span class="p">,</span> <span class="s">'chicken'</span><span class="p">,</span> <span class="s">'dog'</span><span class="p">,</span> <span class="s">'lion'</span><span class="p">,</span> <span class="s">'tiger'</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s">'cow'</span><span class="p">,</span> <span class="s">'cat'</span><span class="p">]</span>

<span class="c1"># Next we will access and modify some items in the hash table.
# Note that the value for the key 20 is being replaced.
</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span>
<span class="s">'chicken'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span>
<span class="s">'tiger'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="o">=</span><span class="s">'duck'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span>
<span class="s">'duck'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">.</span><span class="n">data</span>
<span class="p">[</span><span class="s">'bird'</span><span class="p">,</span> <span class="s">'goat'</span><span class="p">,</span> <span class="s">'pig'</span><span class="p">,</span> <span class="s">'duck'</span><span class="p">,</span> <span class="s">'dog'</span><span class="p">,</span> <span class="s">'lion'</span><span class="p">,</span> <span class="s">'tiger'</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s">'cow'</span><span class="p">,</span> <span class="s">'cat'</span><span class="p">]</span>
<span class="o">&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="mi">99</span><span class="p">])</span>
<span class="bp">None</span>
</pre></table></code></div></div><h4 id="the-complete-hash-table-example">The complete hash table example</h4><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">HashTable</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">11</span>
        <span class="n">self</span><span class="p">.</span><span class="n">slots</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
      <span class="n">hashvalue</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">hashfunction</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">))</span>

      <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
          <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">hashvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>  <span class="c1">#replace
</span>        <span class="k">else</span><span class="p">:</span>
          <span class="n">nextslot</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">rehash</span><span class="p">(</span><span class="n">hashvalue</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">))</span>
          <span class="k">while</span> <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> \
                          <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">nextslot</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">rehash</span><span class="p">(</span><span class="n">nextslot</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">))</span>

          <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span><span class="o">=</span><span class="n">key</span>
            <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span><span class="o">=</span><span class="n">data</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">nextslot</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span> <span class="c1">#replace
</span>
    <span class="k">def</span> <span class="nf">hashfunction</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">size</span><span class="p">):</span>
         <span class="k">return</span> <span class="n">key</span><span class="o">%</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">oldhash</span><span class="p">,</span><span class="n">size</span><span class="p">):</span>
        <span class="nf">return </span><span class="p">(</span><span class="n">oldhash</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
      <span class="n">startslot</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">hashfunction</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">))</span>

      <span class="n">data</span> <span class="o">=</span> <span class="bp">None</span>
      <span class="n">stop</span> <span class="o">=</span> <span class="bp">False</span>
      <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
      <span class="n">position</span> <span class="o">=</span> <span class="n">startslot</span>
      <span class="k">while</span> <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span>  \
                           <span class="ow">not</span> <span class="n">found</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
           <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
           <span class="n">data</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">position</span><span class="p">]</span>
         <span class="k">else</span><span class="p">:</span>
           <span class="n">position</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="nf">rehash</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">slots</span><span class="p">))</span>
           <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="n">startslot</span><span class="p">:</span>
               <span class="n">stop</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>

<span class="n">H</span><span class="o">=</span><span class="nc">HashTable</span><span class="p">()</span>
<span class="n">H</span><span class="p">[</span><span class="mi">54</span><span class="p">]</span><span class="o">=</span><span class="s">"cat"</span>
<span class="n">H</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="o">=</span><span class="s">"dog"</span>
<span class="n">H</span><span class="p">[</span><span class="mi">93</span><span class="p">]</span><span class="o">=</span><span class="s">"lion"</span>
<span class="n">H</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span><span class="o">=</span><span class="s">"tiger"</span>
<span class="n">H</span><span class="p">[</span><span class="mi">77</span><span class="p">]</span><span class="o">=</span><span class="s">"bird"</span>
<span class="n">H</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span><span class="o">=</span><span class="s">"cow"</span>
<span class="n">H</span><span class="p">[</span><span class="mi">44</span><span class="p">]</span><span class="o">=</span><span class="s">"goat"</span>
<span class="n">H</span><span class="p">[</span><span class="mi">55</span><span class="p">]</span><span class="o">=</span><span class="s">"pig"</span>
<span class="n">H</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="o">=</span><span class="s">"chicken"</span>
<span class="nf">print</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="n">slots</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="mi">20</span><span class="p">])</span>

<span class="nf">print</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="mi">17</span><span class="p">])</span>
<span class="n">H</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="o">=</span><span class="s">'duck'</span>
<span class="nf">print</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="mi">20</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="mi">99</span><span class="p">])</span>
</pre></table></code></div></div><hr /><h4 id="analysis-of-hashing">Analysis of Hashing</h4><p>best case hashing would provide a <code class="language-plaintext highlighter-rouge">𝑂(1)</code>, constant time search technique.</p><ul><li>However, due to collisions, the number of comparisons is typically not so simple.<li>Even though a complete analysis of hashing is beyond the scope of this text, we can state some well-known results that approximate the number of comparisons necessary to search for an item.</ul><p>The most important piece of information we need to analyze the use of a hash table is the <code class="language-plaintext highlighter-rouge">load factor</code>, <code class="language-plaintext highlighter-rouge">𝜆</code>.</p><ul><li>Conceptually, if <code class="language-plaintext highlighter-rouge">𝜆</code> is small, then there is a lower chance of collisions, meaning that items are more likely to be in the slots where they belong.<li>If <code class="language-plaintext highlighter-rouge">𝜆</code> is large, meaning that the table is filling up, then there are more and more collisions.<li>This means that collision resolution is more difficult, requiring more comparisons to find an empty slot.<li>With chaining, increased collisions means an increased number of items on each chain.</ul><p>Result for both a successful and an unsuccessful search.</p><ul><li>For a successful search using <code class="language-plaintext highlighter-rouge">open addressing</code> with <code class="language-plaintext highlighter-rouge">linear probing</code><ul><li>the average number of comparisons is approximately <code class="language-plaintext highlighter-rouge">1/2(1+1/(1−𝜆))</code><li>and an unsuccessful search gives <code class="language-plaintext highlighter-rouge">1/2 (1+ (1/(1−𝜆))^2 )</code></ul><li>If we are using <code class="language-plaintext highlighter-rouge">chaining</code>,<ul><li>the average number of comparisons is <code class="language-plaintext highlighter-rouge">1+𝜆/2</code> for the successful case,<li>and simply <code class="language-plaintext highlighter-rouge">𝜆</code> comparisons if the search is unsuccessful.</ul></ul><hr /><h2 id="sorting">Sorting</h2><ul><li>the process of placing elements from a collection in some kind of order.<ul><li>For example,<li>a list of words could be sorted alphabetically or by length.<li>A list of cities could be sorted by population, by area, or by zip code.</ul><li>We have already seen a number of algorithms that were able to benefit from having a sorted list (recall the final anagram example and the binary search).</ul><p>There are many, many sorting algorithms that have been developed and analyzed. This suggests that sorting is an important area of study in computer science.</p><ul><li>Sorting a large number of items can take a substantial amount of computing resources.<li>Like searching, the efficiency of a sorting algorithm is related to the number of items being processed.<li>For small collections, a complex sorting method may be more trouble than it is worth. The overhead may be too high.<li>On the other hand, for larger collections, we want to take advantage of as many improvements as possible.</ul><p>the operations to analyze a sorting process.</p><ul><li>First, it will be necessary to compare two values to see which is smaller (or larger).<ul><li>In order to sort a collection, it will be necessary to have some systematic way to compare values to see if they are out of order.<li>The <code class="language-plaintext highlighter-rouge">total number of comparisons</code> will be the most common way to measure a sort procedure.</ul><li>Second, when values are not in the correct position with respect to one another, it may be necessary to exchange them.<ul><li>This exchange is a costly operation and the total number of exchanges will also be important for evaluating the overall efficiency of the algorithm.</ul></ul><hr /><h3 id="normal-strategy">normal strategy</h3><hr /><h4 id="the-bubble-sort">The Bubble Sort</h4><h5 id="𝑂𝑛2-两个两个-带着大的那个往上滚"><code class="language-plaintext highlighter-rouge">𝑂(𝑛^2)</code> 两个两个 带着大的那个往上滚</h5><p>The bubble sort makes multiple passes through a list.</p><ul><li>It compares adjacent items and exchanges those that are out of order.<li>Each pass through the list places the next largest value in its proper place.<li>In essence, each item “bubbles” up to the location where it belongs.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/IYs8zcP.png" alt="bubblepass" /></p><p>first pass:</p><ul><li>n items in the list, <code class="language-plaintext highlighter-rouge">𝑛−1</code> pairs of items that need to be compared<li>It is important to note that once the largest value in the list is part of a pair, it will continually be moved along until the pass is complete.</ul><p>second pass:</p><ul><li>the largest value is now in place.<li>There are <code class="language-plaintext highlighter-rouge">𝑛−1</code> items left to sort, meaning that there will be <code class="language-plaintext highlighter-rouge">𝑛−2</code> pairs.</ul><p>Since each pass places the next largest value in place, the total number of passes necessary will be <code class="language-plaintext highlighter-rouge">𝑛−1</code>.</p><p>After completing the 𝑛−1 passes, the smallest item must be in the correct position with no further processing required.</p><h5 id="bubblesort-in-python">bubbleSort in python</h5><ul><li>It takes the list as a parameter, and modifies it by exchanging items as necessary.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">passnum</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">passnum</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>

<span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">54</span><span class="p">,</span><span class="mi">26</span><span class="p">,</span><span class="mi">93</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">77</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">44</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="nf">bubbleSort</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</pre></table></code></div></div><p>The exchange operation, “swap,”</p><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">temp</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
<span class="n">alist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
</pre></table></code></div></div><ul><li>is slightly different in Python than in most other programming languages.<li>Typically, swapping two elements in a list requires a <code class="language-plaintext highlighter-rouge">temporary storage location (an additional memory location)</code>.<li>A code fragment will exchange the ith and jth items in the list.<li>Without the temporary storage, one of the values would be overwritten.</ul><p>In Python, it is possible to perform <strong>simultaneous assignment</strong>.</p><ul><li>The statement <code class="language-plaintext highlighter-rouge">a,b=b,a</code> will result in two assignment statements being done at the same time<li>Using simultaneous assignment, the exchange operation can be done in one statement.</ul><hr /><h5 id="analyze-the-bubble-sort">analyze the bubble sort</h5><blockquote><p>the number of comparisons for each pass.</p></blockquote><p><img data-proofer-ignore data-src="https://i.imgur.com/i0u3HYx.png" alt="Screen Shot 2021-09-27 at 1.54.47 AM" /></p><blockquote><p>the sum of the first <code class="language-plaintext highlighter-rouge">n</code> integers: <code class="language-plaintext highlighter-rouge">n+(n-1)+(n-2)+...+1</code></p><ul><li> \[= \frac{n}{2} *(n+1)\]<li> \[= \frac{1}{2} *n^2 + \frac{1}{2} * n\]<li> \[= \frac{1}{2} n^{2} + \frac{1}{2} n\]</ul></blockquote><p>the sum of the first <code class="language-plaintext highlighter-rouge">n-1</code> integers: <code class="language-plaintext highlighter-rouge">(n-1)+(n-2)+...+1</code></p><ul><li> \[= \frac{1}{2} n^{2} + \frac{1}{2} n - n\]<li> \[= \frac{1}{2} n^{2} - \frac{1}{2}n\]</ul><p><strong>Time</strong></p><ul><li><strong>worse case</strong>:<ul><li>every comparison will cause an exchange.<li>regardless of how the items are arranged in the initial list,<li><code class="language-plaintext highlighter-rouge">𝑛−1</code> passes is needs to sort a list of size <code class="language-plaintext highlighter-rouge">n</code>.<li>The total number of <strong>comparisons</strong> is the sum of the first <code class="language-plaintext highlighter-rouge">𝑛−1 integers</code>.<li> \[= \frac{1}{2} n^{2} - \frac{1}{2}n\]<li>still <font color="red"> 𝑂(𝑛&amp;2) </font> comparisons,</ul><li><strong>best case</strong>,<ul><li>the list is already ordered,<li>no exchanges will be made.</ul><li>On average, we exchange half of the time.</ul><p>bubble sort is often considered the <strong>most inefficient sorting</strong> method</p><ul><li><strong>inefficient</strong><ul><li>since it must exchange items before the final location is known.<li>These “wasted” exchange operations are very costly.</ul><li>However, because the bubble sort <strong>makes passes through the entire unsorted portion of the list</strong>, it has the capability to do something most sorting algorithms cannot.<ul><li>In particular, if during a pass there are no exchanges, then we know that the list must be sorted.<li>A bubble sort can be modified to stop early if it finds that the list has become sorted. This means that for lists that require just a few passes, a bubble sort may have an advantage in that it will recognize the sorted list and stop.</ul></ul><hr /><h5 id="the-short-bubble">the short bubble</h5><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">shortBubbleSort</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="n">exchanges</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">passnum</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">while</span> <span class="n">passnum</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">exchanges</span><span class="p">:</span>
       <span class="n">exchanges</span> <span class="o">=</span> <span class="bp">False</span>
       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">passnum</span><span class="p">):</span>
           <span class="k">if</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
               <span class="n">exchanges</span> <span class="o">=</span> <span class="bp">True</span>
               <span class="n">temp</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
               <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
               <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
       <span class="n">passnum</span> <span class="o">=</span> <span class="n">passnum</span><span class="o">-</span><span class="mi">1</span>

<span class="n">alist</span><span class="o">=</span><span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
<span class="nf">shortBubbleSort</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</pre></table></code></div></div><hr /><h4 id="the-selection-sort">The Selection Sort</h4><h5 id="𝑂𝑛2-8-1从1找到最大数location放最后切掉最后一个数字再继续"><code class="language-plaintext highlighter-rouge">𝑂(𝑛^2)</code> 8-&gt;1，从1找到最大数location，放最后，切掉最后一个数字再继续</h5><ul><li>The selection sort improves on the bubble sort by <code class="language-plaintext highlighter-rouge">making only one exchange for every pass through the list</code>.<ul><li>selection sort <code class="language-plaintext highlighter-rouge">looks for the largest value</code> as it makes a pass<li>and after completing the pass, places it in the proper location.</ul><li>As with a bubble sort, after the first pass, the largest item is in the correct place.<li>After the second pass, the next largest is in place.<li>This process continues and requires <code class="language-plaintext highlighter-rouge">𝑛−1</code> passes to sort n items, since the final item must be in place after the (𝑛−1) st pass.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/ninnEUi.png" alt="selectionsortnew" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/vIUtyfF.jpg" alt="0_J2ta_c6YA870MKor" /></p><h5 id="selection-sort-in-python">Selection sort in python</h5><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">selectionSort</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
   <span class="k">for</span> <span class="n">fillslot</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
       <span class="n">positionOfMax</span><span class="o">=</span><span class="mi">0</span>
       <span class="k">for</span> <span class="n">location</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">fillslot</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
           <span class="k">if</span> <span class="n">alist</span><span class="p">[</span><span class="n">location</span><span class="p">]</span><span class="o">&gt;</span><span class="n">alist</span><span class="p">[</span><span class="n">positionOfMax</span><span class="p">]:</span>
               <span class="n">positionOfMax</span> <span class="o">=</span> <span class="n">location</span>
       <span class="n">temp</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">fillslot</span><span class="p">]</span>
       <span class="n">alist</span><span class="p">[</span><span class="n">fillslot</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">positionOfMax</span><span class="p">]</span>
       <span class="n">alist</span><span class="p">[</span><span class="n">positionOfMax</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>

<span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">54</span><span class="p">,</span><span class="mi">26</span><span class="p">,</span><span class="mi">93</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">77</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">44</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="nf">selectionSort</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</pre></table></code></div></div><h5 id="analyze-the-selection-sort">analyze the Selection sort</h5><p>You may see that the selection sort makes the same number of comparisons as the bubble sort and is therefore also <code class="language-plaintext highlighter-rouge">𝑂(𝑛^2)</code>.</p><ul><li>However, due to the reduction in the number of exchanges, the selection sort typically executes faster in benchmark studies.<li>In fact, for our list, the bubble sort <code class="language-plaintext highlighter-rouge">makes 20 exchanges</code>, while the selection sort <code class="language-plaintext highlighter-rouge">makes only 8</code>.<li><code class="language-plaintext highlighter-rouge">make change != compare change</code></ul><hr /><h4 id="the-insertion-sort">The Insertion Sort</h4><h5 id="𝑂𝑛2-从2nd开始-往前比大小-小数字往前挪"><code class="language-plaintext highlighter-rouge">𝑂(𝑛^2)</code> 从2nd开始 往前比大小 小数字往前挪</h5><ul><li><p>considering one element at a time, placing the element in the correct order relative to those before it.</p><li>It always maintains a sorted sublist in the lower positions of the list.<li>Each new item is then “inserted” back into the previous sublist such that the sorted sublist is one item larger.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/96gXhrx.png" alt="insertionsort" /></p><p>Step</p><ul><li>We begin by assuming that a list with one item (position 0) is already sorted. (trivially sorted by itself.)<li>On each pass, one for each item 1 through <code class="language-plaintext highlighter-rouge">𝑛−1</code>, the current item is checked against those in the already sorted sublist.<li>we shift those items that are greater to the right. When we reach a smaller item or the end of the sublist, the current item can be inserted.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/s9Wm7lx.png" alt="insertionpass" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/0l3PjxJ.png" alt="Screen Shot 2022-03-03 at 15.18.37" /></p><p>the fifth pass in detail.</p><ul><li>At this point in the algorithm, a sorted sublist of five items consisting of 17, 26, 54, 77, and 93 exists.<li>insert 31 back into the already sorted items.<li>The first comparison against 93 causes 93 to be shifted to the right.<li>77 and 54 are also shifted.<li>When the item 26 is encountered, the shifting process stops and 31 is placed in the open position.<li>Now we have a sorted sublist of six items.</ul><h5 id="insertion-sort-in-java">Insertion Sort in Java</h5><div class="language-java highlighter-rouge"><div class="code-header" text-data="java"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// for k from 1 to n − 1 do</span>
<span class="c1">// Insert A[k] at its proper location within A[0], A[1], ..., A[k].</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">insertionSort</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="kt">char</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">]&lt;</span><span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">){</span>
            <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
            <span class="n">j</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h5 id="insertion-sort-in-python">Insertion Sort in python</h5><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">insertionSort</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)):</span>
    <span class="n">currentvalue</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">index</span>
    <span class="n">prevalue</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">position</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">currentvalue</span><span class="p">:</span>
      <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="p">]</span><span class="o">=</span><span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
      <span class="n">position</span> <span class="o">=</span> <span class="n">position</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="p">]</span><span class="o">=</span><span class="n">currentvalue</span>

<span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">54</span><span class="p">,</span><span class="mi">26</span><span class="p">,</span><span class="mi">93</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">77</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">44</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="nf">insertionSort</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</pre></table></code></div></div><h5 id="analyze-the-insertion-sort">analyze the Insertion sort</h5><ul><li><code class="language-plaintext highlighter-rouge">𝑛−1</code> passes to sort <code class="language-plaintext highlighter-rouge">n</code> items.<li>The iteration starts at position 1 and moves through position <code class="language-plaintext highlighter-rouge">𝑛−1</code>, as these are the items that need to be inserted back into the sorted sublists.<li>Line 8 performs the shift operation that moves a value up one position in the list, making room behind it for the insertion. Remember that this is not a complete exchange as was performed in the previous algorithms.</ul><font color="red"> worse case </font><p>:</p><ul><li>The maximum number of comparisons for an insertion sort is the sum of the <code class="language-plaintext highlighter-rouge">first 𝑛−1 integers</code>. <code class="language-plaintext highlighter-rouge">𝑂(𝑛^2)</code>.</ul><font color="red"> best case </font><p>:</p><ul><li>However, in the best case, only <code class="language-plaintext highlighter-rouge">one comparison needs to be done on each pass</code>.<li>This would be the case for an already sorted list.</ul><p>One note about <code class="language-plaintext highlighter-rouge">shifting</code> versus <code class="language-plaintext highlighter-rouge">exchanging</code> is also important.</p><ul><li>In general, a shift operation requires approximately a third of the processing work of an exchange since only one assignment is performed.<li>In benchmark studies, <font color="red"> insertion sort will show very good performance </font>.</ul><hr /><h4 id="the-shell-sort">The Shell Sort</h4><h5 id="between-𝑂𝑛-and-𝑂𝑛2-gap拆开-分别不停的的insertion-sort"><code class="language-plaintext highlighter-rouge">between 𝑂(𝑛) and 𝑂(𝑛^2)</code> gap拆开 分别不停的的insertion sort</h5><ul><li>sometimes called the “diminishing increment sort,”<li>improves on the insertion sort by<ul><li>breaking the original list into a number of smaller sublists,<li>each of which is sorted using an <code class="language-plaintext highlighter-rouge">insertion sort</code>.</ul><li>The unique way that these sublists are chosen is the key to the shell sort.<ul><li>Instead of breaking the list into sublists of contiguous items, the shell sort uses an increment <code class="language-plaintext highlighter-rouge">i</code>, sometimes called the gap, to create a sublist by choosing all items that are <code class="language-plaintext highlighter-rouge">i</code> items apart.</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/kbG4fea.png" alt="shellsortA" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/fevQIlG.png" alt="shellsortB" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/KmH7Hv3.png" alt="shellsortC" /></p><p>list has nine items.</p><ul><li>use an increment of three, there are three sublists, each of which can be sorted by an insertion sort.<li>After completing these sorts, Although this list is not completely sorted, something very interesting has happened.<li>By sorting the sublists, moved the items closer to where they actually belong.<li>a final insertion sort using an increment of one; in other words, a standard insertion sort.<li>Note that by performing the earlier sublist sorts, we have now <strong>reduced the total number of shifting operations</strong> necessary to put the list in its final order.<li>For this case, we need only four more shifts to complete the process.</ul><h5 id="shell-sort-in-python">Shell sort in python</h5><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">shellSort</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="n">sublistcount</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
    <span class="k">while</span> <span class="n">sublistcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">startposition</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">sublistcount</span><span class="p">):</span>
        <span class="nf">gapInsertionSort</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="n">startposition</span><span class="p">,</span> <span class="n">sublistcount</span><span class="p">)</span>
      <span class="nf">print</span><span class="p">(</span><span class="s">"After increments of size"</span><span class="p">,</span><span class="n">sublistcount</span><span class="p">,</span> <span class="s">"The list is"</span><span class="p">,</span><span class="n">alist</span><span class="p">)</span>
      <span class="n">sublistcount</span> <span class="o">=</span> <span class="n">sublistcount</span> <span class="o">//</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">gapInsertionSort</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">gap</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">start</span><span class="o">+</span><span class="n">gap</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">),</span><span class="n">gap</span><span class="p">):</span>
        <span class="n">currentvalue</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">while</span> <span class="n">position</span><span class="o">&gt;=</span><span class="n">gap</span> <span class="ow">and</span> <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="o">-</span><span class="n">gap</span><span class="p">]</span><span class="o">&gt;</span><span class="n">currentvalue</span><span class="p">:</span>
            <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="p">]</span><span class="o">=</span><span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="o">-</span><span class="n">gap</span><span class="p">]</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">position</span><span class="o">-</span><span class="n">gap</span>
        <span class="n">alist</span><span class="p">[</span><span class="n">position</span><span class="p">]</span><span class="o">=</span><span class="n">currentvalue</span>

<span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">54</span><span class="p">,</span><span class="mi">26</span><span class="p">,</span><span class="mi">93</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">77</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">44</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="nf">shellSort</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>the partially sorted lists after each increment, with the final sort being an insertion sort with an increment of one.</ul><h5 id="analyze-the-insertion-sort-1">analyze the Insertion sort</h5><ul><li>At first glance you may think that a shell sort cannot be better than an insertion sort, since it does a complete insertion sort as the last step.<li>It turns out, however, that this final insertion sort does not need to do very many comparisons (or shifts) since the list has been pre-sorted by earlier incremental insertion sorts, as described above.<li>In other words, each pass produces a list that is “more sorted” than the previous one.<li>This makes the final pass very efficient.</ul><p>Although a general analysis of the shell sort is well beyond the scope of this text, we can say that it tends to fall somewhere <code class="language-plaintext highlighter-rouge">between 𝑂(𝑛) and 𝑂(𝑛^2)</code>, based on the behavior described above.</p><ul><li>For the increments shown in Listing 5, the performance is <code class="language-plaintext highlighter-rouge">𝑂(𝑛^2)</code>.<li>By changing the increment, for example using 2^𝑘−1 (1, 3, 7, 15, 31, and so on), a shell sort can perform at <code class="language-plaintext highlighter-rouge">𝑂(𝑛^ 3/2)</code>.</ul><hr /><h3 id="divide-and-conquer-strategy-1">divide and conquer strategy</h3><p>We now turn our attention to using a <code class="language-plaintext highlighter-rouge">divide and conquer strategy</code> as a way to improve the performance of sorting algorithms.</p><hr /><h4 id="merge-sort">Merge Sort</h4><h5 id="𝑂𝑛log𝑛-从中间分开直到只剩一个-两个比大小-sort-再合起来"><code class="language-plaintext highlighter-rouge">𝑂(𝑛log𝑛)</code> 从中间分开直到只剩一个-&gt;两个比大小 sort 再合起来</h5><p>Merge sort</p><ul><li>recursive algorithm that continually splits a list in half. If the list is empty or has one item, it is sorted by definition (the base case).<li>If the list has more than one item, we split the list and recursively invoke a <code class="language-plaintext highlighter-rouge">merge sort</code> on both halves.<li>Once the two halves are sorted, the fundamental operation, called a merge, is performed.<li>Merging is the process of taking two smaller sorted lists and combining them together into a single, sorted, new list.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/IDnIkoE.png" alt="mergesortA" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/a4iSRLU.png" alt="mergesortB" /></p><h5 id="merge-sort-in-python">Merge sort in python</h5><p>The mergeSort function</p><ul><li>divide and conquer algorithm.<li><p>It continuously divides an array into two halves, recurses on both the left subarray and right subarray and then merges the two sorted halves。</p><li>begins by asking the base case question.<ul><li>If the length of the list is less than or equal to one, already have a sorted list，no more processing is necessary.<li>If the length is greater than one, use the Python slice operation to extract the left and right halves.</ul><li>It is important to note that the list may not have an even number of items. That does not matter, as the lengths will differ by at most one.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Splitting "</span><span class="p">,</span><span class="n">alist</span><span class="p">)</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">lefthalf</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[:</span><span class="n">mid</span><span class="p">]</span>
        <span class="n">righthalf</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">mid</span><span class="p">:]</span>

        <span class="nf">mergeSort</span><span class="p">(</span><span class="n">lefthalf</span><span class="p">)</span>
        <span class="nf">mergeSort</span><span class="p">(</span><span class="n">righthalf</span><span class="p">)</span>
        <span class="c1"># Once the mergeSort function is invoked on the left half and the right half, it is assumed they are sorted.
</span>
        <span class="c1"># The rest of the function is responsible for merging the two smaller sorted lists into a larger sorted list.
</span>        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">lefthalf</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">righthalf</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lefthalf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">righthalf</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">alist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">lefthalf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">righthalf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">lefthalf</span><span class="p">):</span>
            <span class="n">alist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">lefthalf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span>

        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">righthalf</span><span class="p">):</span>
            <span class="n">alist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">righthalf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Merging "</span><span class="p">,</span><span class="n">alist</span><span class="p">)</span>

<span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">54</span><span class="p">,</span><span class="mi">26</span><span class="p">,</span><span class="mi">93</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">77</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">44</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="nf">mergeSort</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>Notice that the merge operation places the items back into the original list (alist) one at a time by repeatedly taking the smallest item from the sorted lists.<li>Note that the statement <code class="language-plaintext highlighter-rouge">lefthalf[i] &lt;= righthalf[j]</code> ensures that the algorithm is stable.<li>A stable algorithm <code class="language-plaintext highlighter-rouge">maintains the order of duplicate items</code> in a list and is preferred in most cases.</ul><h5 id="analyze-the-mergesort-sort">analyze the mergeSort sort</h5><p>mergeSort: consider the two distinct processes that make up its implementation.</p><ul><li>First, the list is split into halves.<ul><li>binary search: we can divide a list in half <code class="language-plaintext highlighter-rouge">log𝑛</code> times where <code class="language-plaintext highlighter-rouge">n</code> is the length of the list.<ul><li><code class="language-plaintext highlighter-rouge">n/2, 𝑛/4, 𝑛/8, 𝑛/16, ....</code><li><code class="language-plaintext highlighter-rouge">n/2^i = 1</code><li><code class="language-plaintext highlighter-rouge">𝑖=log𝑛</code></ul></ul><li>The second process is the merge.<ul><li>Each item in the list will eventually be processed and placed on the sorted list.<li>So the merge operation which <code class="language-plaintext highlighter-rouge">results in a list</code> of size <code class="language-plaintext highlighter-rouge">n</code> requires <code class="language-plaintext highlighter-rouge">n</code> operations.<li>The result of this analysis is that <code class="language-plaintext highlighter-rouge">log𝑛</code> splits, each of which costs <code class="language-plaintext highlighter-rouge">𝑛</code> for a total of <code class="language-plaintext highlighter-rouge">𝑛log𝑛</code> operations.</ul><li><p>A merge sort is an <code class="language-plaintext highlighter-rouge">𝑂(𝑛log𝑛)</code> algorithm.</p><li>the slicing operator is <code class="language-plaintext highlighter-rouge">𝑂(𝑘)</code> where <code class="language-plaintext highlighter-rouge">k</code> is the size of the slice.<li>In order to guarantee that mergeSort will be <code class="language-plaintext highlighter-rouge">𝑂(𝑛log𝑛)</code> we will need to remove the slice operator.<li>simply pass the starting and ending indices along with the list when we make the recursive call.<li>We leave this as an exercise.</ul><p>It is important to notice that the mergeSort function <code class="language-plaintext highlighter-rouge">requires extra space</code> to hold the two halves as they are extracted with the slicing operations.</p><p>This additional space can be a critical factor if the list is large and can make this sort problematic when working on large data sets.</p><hr /><h4 id="quick-sort">Quick Sort</h4><h5 id="𝑂𝑛log𝑛-to-𝑂𝑛2-pivot-从前往后数小的从后往前数大的卡住就换最后-small--pivot--large"><code class="language-plaintext highlighter-rouge">𝑂(𝑛log𝑛) to 𝑂(𝑛^2)</code>, pivot, 从前往后数小的，从后往前数大的，卡住就换，最后 small &lt; pivot &lt; large</h5><blockquote><p>Quick sort can be <code class="language-plaintext highlighter-rouge">O(n log n)</code>, but if the pivot points are not well chosen and the list is just so, it can be <code class="language-plaintext highlighter-rouge">O(n^2)</code>.</p></blockquote><blockquote><p>Merge Sort is the only guaranteed <code class="language-plaintext highlighter-rouge">O(n log n)</code> even in the worst case. The cost is that merge sort uses more memory.</p></blockquote><p><img data-proofer-ignore data-src="https://i.imgur.com/Foy0S8c.gif" alt="quicksort" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/pnDV79v.png" alt="Screen Shot 2021-09-27 at 7.05.59 PM" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/y5sZEhi.png" alt="Screen Shot 2021-09-27 at 7.25.03 PM" /></p><p>The quick sort uses <strong>divide and conquer</strong> to gain the same advantages as the merge sort, <code class="language-plaintext highlighter-rouge">while not using additional storage</code>.</p><ul><li>As a trade-off, however, it is possible that the list may not be divided in half.<li>When this happens, performance is diminished.</ul><p>A quick sort first selects a value, <code class="language-plaintext highlighter-rouge">pivot value</code>.</p><ul><li>many different ways to choose the pivot value, we will simply use the first item in the list.<li>The role of the pivot value is to assist with splitting the list.<li>The actual position where the pivot value belongs in the final sorted list, commonly called the <code class="language-plaintext highlighter-rouge">split point</code>, will be used to divide the list for subsequent calls to the quick sort.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">sq</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">l</span><span class="o">&gt;</span><span class="n">r</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">arr</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nf">partitioning</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="nf">qs</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">p</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="nf">qs</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">p</span><span class="p">:],</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></table></code></div></div><p><strong>Partitioning</strong></p><ul><li>The goal of the partition process is to move items that are on the wrong side with respect to the pivot value while also converging on the split point.</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/dCJunDA.png" alt="firstsplit" /></p><ol><li>begins by locating two position markers<ol><li><code class="language-plaintext highlighter-rouge">leftmark</code> and <code class="language-plaintext highlighter-rouge">rightmark</code>,<li>at the beginning and end of the remaining items in the list</ol><li>incrementing <code class="language-plaintext highlighter-rouge">leftmark</code> until locate a value <font color="blue"> greater than the pivot value </font>.<li><p>then decrement <code class="language-plaintext highlighter-rouge">rightmark</code> until find a value <font color="blue"> less than the pivot value </font>.</p><li>we have two items that are out of place with respect to the eventual split point.<ol><li>For our example, this occurs at 93 and 20.</ol><li><p>Now exchange these two items and then repeat the process again.</p><li><p>At the point where <code class="language-plaintext highlighter-rouge">rightmark</code> becomes less than <code class="language-plaintext highlighter-rouge">leftmark</code>, we stop.</p><li><p>The position of <code class="language-plaintext highlighter-rouge">rightmark</code> is now the split point.</p><li><p>The pivot value can be exchanged with the contents of the <code class="language-plaintext highlighter-rouge">split point</code> and the <code class="language-plaintext highlighter-rouge">pivot value</code> is now in place</p><li>now:<ol><li>all the items to the left of the split point are less than the pivot value,<li>all the items to the right of the split point are greater than the pivot value.</ol><li>The list can now be divided at the split point and the quick sort can be invoked recursively on the two halves.</ol><p><img data-proofer-ignore data-src="https://i.imgur.com/jQPiRut.png" alt="partitionA" /></p><p><img data-proofer-ignore data-src="https://i.imgur.com/rKFSiX3.png" alt="partitionB" /></p><ul><li>54 will serve as our first pivot value.<li>54 will eventually end up in the position currently holding 31.<li>The partition process will happen next. It will find the split point and at the same time move other items to the appropriate side of the list, either less than or greater than the pivot value.</ul><h5 id="quicksort-in-python">QuickSort in python</h5><p>The quickSort function invokes a recursive function, quickSortHelper. quickSortHelper begins with the same base case as the merge sort.</p><ul><li>If the length of the list is less than or equal to one, it is already sorted.<li>If it is greater, then it can be partitioned and recursively sorted.</ul><div class="language-py highlighter-rouge"><div class="code-header" text-data="py"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">quickSort</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
  <span class="nf">quickSortHelper</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">quickSortHelper</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span><span class="n">first</span><span class="p">,</span><span class="n">last</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">first</span><span class="o">&lt;</span><span class="n">last</span><span class="p">:</span>
    <span class="n">splitpoint</span> <span class="o">=</span> <span class="nf">partition</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span><span class="n">first</span><span class="p">,</span><span class="n">last</span><span class="p">)</span>
    <span class="nf">quickSortHelper</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span><span class="n">first</span><span class="p">,</span><span class="n">splitpoint</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="nf">quickSortHelper</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span><span class="n">splitpoint</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">last</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span><span class="n">first</span><span class="p">,</span><span class="n">last</span><span class="p">):</span>
  <span class="n">pivotvalue</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">first</span><span class="p">]</span>

  <span class="n">leftmark</span> <span class="o">=</span> <span class="n">first</span><span class="o">+</span><span class="mi">1</span>
  <span class="n">rightmark</span> <span class="o">=</span> <span class="n">last</span>

  <span class="n">done</span> <span class="o">=</span> <span class="bp">False</span>
  <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
    <span class="k">while</span> <span class="n">leftmark</span> <span class="o">&lt;=</span> <span class="n">rightmark</span> <span class="ow">and</span> <span class="n">alist</span><span class="p">[</span><span class="n">leftmark</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivotvalue</span><span class="p">:</span>
      <span class="n">leftmark</span> <span class="o">=</span> <span class="n">leftmark</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">leftmark</span> <span class="o">&lt;=</span> <span class="n">rightmark</span> <span class="ow">and</span> <span class="n">alist</span><span class="p">[</span><span class="n">rightmark</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">pivotvalue</span><span class="p">:</span>
      <span class="n">rightmark</span> <span class="o">=</span> <span class="n">rightmark</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">if</span> <span class="n">leftmark</span> <span class="o">&gt;</span> <span class="n">rightmark</span><span class="p">:</span>
      <span class="n">done</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">temp</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">leftmark</span><span class="p">]</span>
      <span class="n">alist</span><span class="p">[</span><span class="n">leftmark</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">rightmark</span><span class="p">]</span>
      <span class="n">alist</span><span class="p">[</span><span class="n">rightmark</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>

  <span class="n">temp</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">first</span><span class="p">]</span>
  <span class="n">alist</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">rightmark</span><span class="p">]</span>
  <span class="n">alist</span><span class="p">[</span><span class="n">rightmark</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
  <span class="k">return</span> <span class="n">rightmark</span>

<span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">54</span><span class="p">,</span><span class="mi">26</span><span class="p">,</span><span class="mi">93</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">77</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">44</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="nf">quickSort</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</pre></table></code></div></div><h5 id="analyze-the-quicksort-sort">analyze the quickSort sort</h5><ul><li>Stable: No<li>Time Complexity:<ul><li>Best Case: O(nlog(n))<li>Worst Case: O(n^2)<li>Average Case: O(nlog(n))</ul></ul><p><img data-proofer-ignore data-src="https://i.imgur.com/zqs7LSY.png" alt="Screen Shot 2021-09-27 at 7.32.56 PM" /></p><p>for a list of length <code class="language-plaintext highlighter-rouge">n</code>,</p><ul><li>if the partition always occurs in the middle of the list, there will again be <code class="language-plaintext highlighter-rouge">log𝑛</code> divisions.<li>In order to find the split point, each of the <code class="language-plaintext highlighter-rouge">n</code> items needs to be checked against the pivot value. The result is <code class="language-plaintext highlighter-rouge">𝑛log𝑛</code>.<li>In addition, there is <strong>no need for additional memory</strong> as in the merge sort process.</ul><p>Unfortunately, worst case, the split points may not be in the middle and can be very skewed to the left or the right, leaving a very uneven division.</p><ul><li>In this case,<ul><li>sorting a list of <code class="language-plaintext highlighter-rouge">n</code> items divides into sorting a list of <code class="language-plaintext highlighter-rouge">0</code> items and a list of <code class="language-plaintext highlighter-rouge">𝑛−1</code> items.<li>Then sorting a list of <code class="language-plaintext highlighter-rouge">𝑛−1</code> divides into a list of size 0 and a list of size <code class="language-plaintext highlighter-rouge">𝑛−2</code>, and so on.</ul><li>The result is an <code class="language-plaintext highlighter-rouge">𝑂(𝑛^2)</code> sort with all of the overhead that recursion requires.</ul><p>different ways to choose the pivot value.</p><ul><li>In particular, we can attempt to alleviate some of the potential for an uneven division by using a technique called <strong>median of three</strong>.</ul><p><strong>median of three</strong></p><ul><li>To choose the pivot value, consider the <code class="language-plaintext highlighter-rouge">first, the middle, and the last element in the list</code>.<ul><li>In our example, those are 54, 77, and 20.</ul><li>Now pick the median value, in our case 54, and use it for the pivot value (of course, that was the pivot value we used originally).<li>The idea is that in the case where the first item in the list does not belong toward the middle of the list, <strong>the median of three</strong> will choose a better “middle” value.<li>This will be particularly useful when the original list is somewhat sorted to begin with.</ul><hr /><h3 id="other-sorting">Other sorting</h3><hr /><h4 id="bucket-sort">Bucket Sort</h4><ul><li>works by distributing the elements of an array into a number of buckets.<li>Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm</ul><p><strong>Time Complexity</strong>:</p><ul><li>Best Case: Ω(n + k)<li>Worst Case: O(n^2)<li>Average Case:Θ(n + k)</ul><p><img data-proofer-ignore data-src="https://i.imgur.com/GZphZCB.png" alt="bucketsort" /></p><hr /><h4 id="radix-sort">Radix Sort</h4><ul><li>like bucket sort,<li>distributes elements of an array into a number of buckets.<li>However, radix sort differs from bucket sort by ‘re-bucketing’ the array after the initial pass as opposed to sorting each bucket and merging</ul><p>Time Complexity:</p><ul><li>Best Case: Ω(nk)<li>Worst Case: O(nk)<li>Average Case: Θ(nk)</ul><p>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/00codenote/'>00CodeNote</a>, <a href='/categories/pythonnote/'>PythonNote</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=DS - pythonds3 - 6. Algorithms Sorting and Searching - Grace&url=https://ocholuo.github.io//posts/6-Sorting-and-Searching/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=DS - pythonds3 - 6. Algorithms Sorting and Searching - Grace&u=https://ocholuo.github.io//posts/6-Sorting-and-Searching/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=DS - pythonds3 - 6. Algorithms Sorting and Searching - Grace&url=https://ocholuo.github.io//posts/6-Sorting-and-Searching/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Amazon-CloudFront/">AWS Lab - AWS CloudFront</a><li><a href="/posts/Alexa-1stSkill/">AWS Alex First Skill - RedVelvet Time</a><li><a href="/posts/NetworkProtocol-SSL-TLS-Handshake/">NetworkProtocol SSL/TLS Handshake</a><li><a href="/posts/pythonCrash/">Python Crash</a><li><a href="/posts/%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%A7%A3%E9%87%8AAWS/">AWS - 一句话解释AWS</a><li><a href="/posts/GKE/">GCP - Google Cloud Computing - Kubernetes and Kubernetes Engine</a><li><a href="/posts/Go-Note/">Go Note</a><li><a href="/posts/SCPs/">AWS - IdenAccessManage - SCPs (Service Control Policies)</a><li><a href="/posts/CompanyBenefit/">Company Benefit</a><li><a href="/posts/Encryption-SSL&TLS/">Cryptography - SSL/TLS Encryption</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/soc/">SOC</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/5-Recursion-Exercises/"><div class="card-body"> <span class="timeago small" >Aug 25, 2019<i class="unloaded">2019-08-25T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DS - pythonds3 - 5. Recursion - Exercises</h3><div class="text-muted small"><p> DS - pythonds3 - 5. Recursion - Exercises check the reverse words check the mirror words exchange the coins factorial of a number recursive tree Fibonacc...</p></div></div></a></div><div class="card"> <a href="/posts/8-Graphy/"><div class="card-body"> <span class="timeago small" >Aug 25, 2019<i class="unloaded">2019-08-25T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DS - pythonds3 - 8. Graphs and Graph Algorithms</h3><div class="text-muted small"><p> pythonds3 - 8. Graphs and Graph Algorithms Graphs Vocabulary and Definitions The Graph Abstract Data Type An Adjacency Matrix 邻...</p></div></div></a></div><div class="card"> <a href="/posts/pythonCrash/"><div class="card-body"> <span class="timeago small" >Oct 11, 2019<i class="unloaded">2019-10-11T11:11:11-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Python Crash</h3><div class="text-muted small"><p> Python Crash String List dictionary Tuple Sorted Functions lambda zip, map filter test except RegularExpression Data ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/5-Recursion-Exercises/" class="btn btn-outline-primary" prompt="Older"><p>DS - pythonds3 - 5. Recursion - Exercises</p></a> <a href="/posts/7-DS-Basic1-PriorityQueues/" class="btn btn-outline-primary" prompt="Newer"><p>Data Structures - Basic 1 - Priority Queues</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/ocholuo">Grace JyL</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/cyberattack/">CyberAttack</a> <a class="post-tag" href="/tags/lab/">Lab</a> <a class="post-tag" href="/tags/cyberattacktools/">CyberAttackTools</a> <a class="post-tag" href="/tags/gcp/">GCP</a> <a class="post-tag" href="/tags/sysadmin/">Sysadmin</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/soc/">SOC</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://ocholuo.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script defer src="/assets/js/dist/pvreport.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-179830187-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-179830187-1'); }); </script>
